// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: validate/validate.proto
// Protobuf C++ Version: 6.31.1

#include "validate/validate.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace validate {

inline constexpr UInt64Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{::uint64_t{0u}},
        lt_{::uint64_t{0u}},
        lte_{::uint64_t{0u}},
        gt_{::uint64_t{0u}},
        gte_{::uint64_t{0u}},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR UInt64Rules::UInt64Rules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UInt64Rules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UInt64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UInt64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UInt64RulesDefaultTypeInternal() {}
  union {
    UInt64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UInt64RulesDefaultTypeInternal _UInt64Rules_default_instance_;

inline constexpr UInt32Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{0u},
        lt_{0u},
        lte_{0u},
        gt_{0u},
        gte_{0u},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR UInt32Rules::UInt32Rules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UInt32Rules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UInt32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UInt32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UInt32RulesDefaultTypeInternal() {}
  union {
    UInt32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UInt32RulesDefaultTypeInternal _UInt32Rules_default_instance_;

inline constexpr StringRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        pattern_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        prefix_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        suffix_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        contains_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        not_contains_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        min_len_{::uint64_t{0u}},
        max_len_{::uint64_t{0u}},
        min_bytes_{::uint64_t{0u}},
        max_bytes_{::uint64_t{0u}},
        len_{::uint64_t{0u}},
        len_bytes_{::uint64_t{0u}},
        ignore_empty_{false},
        strict_{true},
        well_known_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR StringRules::StringRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(StringRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct StringRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StringRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StringRulesDefaultTypeInternal() {}
  union {
    StringRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringRulesDefaultTypeInternal _StringRules_default_instance_;

inline constexpr SInt64Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{::int64_t{0}},
        lt_{::int64_t{0}},
        lte_{::int64_t{0}},
        gt_{::int64_t{0}},
        gte_{::int64_t{0}},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR SInt64Rules::SInt64Rules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SInt64Rules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SInt64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SInt64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SInt64RulesDefaultTypeInternal() {}
  union {
    SInt64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SInt64RulesDefaultTypeInternal _SInt64Rules_default_instance_;

inline constexpr SInt32Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{0},
        lt_{0},
        lte_{0},
        gt_{0},
        gte_{0},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR SInt32Rules::SInt32Rules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SInt32Rules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SInt32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SInt32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SInt32RulesDefaultTypeInternal() {}
  union {
    SInt32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SInt32RulesDefaultTypeInternal _SInt32Rules_default_instance_;

inline constexpr SFixed64Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{::int64_t{0}},
        lt_{::int64_t{0}},
        lte_{::int64_t{0}},
        gt_{::int64_t{0}},
        gte_{::int64_t{0}},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR SFixed64Rules::SFixed64Rules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SFixed64Rules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SFixed64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SFixed64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SFixed64RulesDefaultTypeInternal() {}
  union {
    SFixed64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SFixed64RulesDefaultTypeInternal _SFixed64Rules_default_instance_;

inline constexpr SFixed32Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{0},
        lt_{0},
        lte_{0},
        gt_{0},
        gte_{0},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR SFixed32Rules::SFixed32Rules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SFixed32Rules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SFixed32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SFixed32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SFixed32RulesDefaultTypeInternal() {}
  union {
    SFixed32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SFixed32RulesDefaultTypeInternal _SFixed32Rules_default_instance_;

inline constexpr MessageRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        skip_{false},
        required_{false} {}

template <typename>
PROTOBUF_CONSTEXPR MessageRules::MessageRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MessageRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MessageRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageRulesDefaultTypeInternal() {}
  union {
    MessageRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageRulesDefaultTypeInternal _MessageRules_default_instance_;

inline constexpr Int64Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{::int64_t{0}},
        lt_{::int64_t{0}},
        lte_{::int64_t{0}},
        gt_{::int64_t{0}},
        gte_{::int64_t{0}},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR Int64Rules::Int64Rules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Int64Rules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct Int64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Int64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Int64RulesDefaultTypeInternal() {}
  union {
    Int64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Int64RulesDefaultTypeInternal _Int64Rules_default_instance_;

inline constexpr Int32Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{0},
        lt_{0},
        lte_{0},
        gt_{0},
        gte_{0},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR Int32Rules::Int32Rules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Int32Rules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct Int32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Int32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Int32RulesDefaultTypeInternal() {}
  union {
    Int32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Int32RulesDefaultTypeInternal _Int32Rules_default_instance_;

inline constexpr FloatRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{0},
        lt_{0},
        lte_{0},
        gt_{0},
        gte_{0},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR FloatRules::FloatRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(FloatRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct FloatRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FloatRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FloatRulesDefaultTypeInternal() {}
  union {
    FloatRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FloatRulesDefaultTypeInternal _FloatRules_default_instance_;

inline constexpr Fixed64Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{::uint64_t{0u}},
        lt_{::uint64_t{0u}},
        lte_{::uint64_t{0u}},
        gt_{::uint64_t{0u}},
        gte_{::uint64_t{0u}},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR Fixed64Rules::Fixed64Rules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Fixed64Rules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct Fixed64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fixed64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fixed64RulesDefaultTypeInternal() {}
  union {
    Fixed64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fixed64RulesDefaultTypeInternal _Fixed64Rules_default_instance_;

inline constexpr Fixed32Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{0u},
        lt_{0u},
        lte_{0u},
        gt_{0u},
        gte_{0u},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR Fixed32Rules::Fixed32Rules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Fixed32Rules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct Fixed32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fixed32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fixed32RulesDefaultTypeInternal() {}
  union {
    Fixed32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fixed32RulesDefaultTypeInternal _Fixed32Rules_default_instance_;

inline constexpr EnumRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{0},
        defined_only_{false} {}

template <typename>
PROTOBUF_CONSTEXPR EnumRules::EnumRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(EnumRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EnumRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnumRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnumRulesDefaultTypeInternal() {}
  union {
    EnumRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnumRulesDefaultTypeInternal _EnumRules_default_instance_;

inline constexpr DoubleRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{0},
        lt_{0},
        lte_{0},
        gt_{0},
        gte_{0},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR DoubleRules::DoubleRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DoubleRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DoubleRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoubleRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoubleRulesDefaultTypeInternal() {}
  union {
    DoubleRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoubleRulesDefaultTypeInternal _DoubleRules_default_instance_;

inline constexpr BytesRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        pattern_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        prefix_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        suffix_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        contains_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        min_len_{::uint64_t{0u}},
        max_len_{::uint64_t{0u}},
        len_{::uint64_t{0u}},
        ignore_empty_{false},
        well_known_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR BytesRules::BytesRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(BytesRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BytesRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BytesRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BytesRulesDefaultTypeInternal() {}
  union {
    BytesRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BytesRulesDefaultTypeInternal _BytesRules_default_instance_;

inline constexpr BoolRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        const__{false} {}

template <typename>
PROTOBUF_CONSTEXPR BoolRules::BoolRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(BoolRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BoolRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoolRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoolRulesDefaultTypeInternal() {}
  union {
    BoolRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoolRulesDefaultTypeInternal _BoolRules_default_instance_;

inline constexpr AnyRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        required_{false} {}

template <typename>
PROTOBUF_CONSTEXPR AnyRules::AnyRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(AnyRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AnyRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnyRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnyRulesDefaultTypeInternal() {}
  union {
    AnyRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnyRulesDefaultTypeInternal _AnyRules_default_instance_;

inline constexpr TimestampRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        const__{nullptr},
        lt_{nullptr},
        lte_{nullptr},
        gt_{nullptr},
        gte_{nullptr},
        within_{nullptr},
        required_{false},
        lt_now_{false},
        gt_now_{false} {}

template <typename>
PROTOBUF_CONSTEXPR TimestampRules::TimestampRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(TimestampRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TimestampRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimestampRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimestampRulesDefaultTypeInternal() {}
  union {
    TimestampRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimestampRulesDefaultTypeInternal _TimestampRules_default_instance_;

inline constexpr DurationRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        const__{nullptr},
        lt_{nullptr},
        lte_{nullptr},
        gt_{nullptr},
        gte_{nullptr},
        required_{false} {}

template <typename>
PROTOBUF_CONSTEXPR DurationRules::DurationRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DurationRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DurationRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DurationRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DurationRulesDefaultTypeInternal() {}
  union {
    DurationRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DurationRulesDefaultTypeInternal _DurationRules_default_instance_;

inline constexpr FieldRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_{nullptr},
        type_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR FieldRules::FieldRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(FieldRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct FieldRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FieldRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FieldRulesDefaultTypeInternal() {}
  union {
    FieldRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FieldRulesDefaultTypeInternal _FieldRules_default_instance_;

inline constexpr MapRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        keys_{nullptr},
        values_{nullptr},
        min_pairs_{::uint64_t{0u}},
        max_pairs_{::uint64_t{0u}},
        no_sparse_{false},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR MapRules::MapRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MapRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MapRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapRulesDefaultTypeInternal() {}
  union {
    MapRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapRulesDefaultTypeInternal _MapRules_default_instance_;

inline constexpr RepeatedRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        items_{nullptr},
        min_items_{::uint64_t{0u}},
        max_items_{::uint64_t{0u}},
        unique_{false},
        ignore_empty_{false} {}

template <typename>
PROTOBUF_CONSTEXPR RepeatedRules::RepeatedRules(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RepeatedRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RepeatedRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepeatedRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepeatedRulesDefaultTypeInternal() {}
  union {
    RepeatedRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepeatedRulesDefaultTypeInternal _RepeatedRules_default_instance_;
}  // namespace validate
static const ::_pb::EnumDescriptor* PROTOBUF_NONNULL
    file_level_enum_descriptors_validate_2fvalidate_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor *PROTOBUF_NONNULL *PROTOBUF_NULLABLE
    file_level_service_descriptors_validate_2fvalidate_2eproto = nullptr;
const ::uint32_t
    TableStruct_validate_2fvalidate_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _impl_._oneof_case_[0]),
        27, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _impl_.message_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _impl_.type_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::validate::FloatRules, _impl_.ignore_empty_),
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::validate::DoubleRules, _impl_.ignore_empty_),
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::validate::Int32Rules, _impl_.ignore_empty_),
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::validate::Int64Rules, _impl_.ignore_empty_),
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::validate::UInt32Rules, _impl_.ignore_empty_),
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::validate::UInt64Rules, _impl_.ignore_empty_),
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::validate::SInt32Rules, _impl_.ignore_empty_),
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::validate::SInt64Rules, _impl_.ignore_empty_),
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed32Rules, _impl_.ignore_empty_),
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::validate::Fixed64Rules, _impl_.ignore_empty_),
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed32Rules, _impl_.ignore_empty_),
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::validate::SFixed64Rules, _impl_.ignore_empty_),
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::BoolRules, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::BoolRules, _impl_.const__),
        0,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_._oneof_case_[0]),
        31, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.len_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.min_len_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.max_len_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.len_bytes_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.min_bytes_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.max_bytes_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.pattern_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.prefix_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.suffix_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.contains_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.not_contains_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.not_in_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.strict_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.ignore_empty_),
        PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_.well_known_),
        0,
        10,
        6,
        7,
        11,
        8,
        9,
        1,
        2,
        3,
        4,
        5,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        13,
        12,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_._oneof_case_[0]),
        19, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.len_),
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.min_len_),
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.max_len_),
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.pattern_),
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.prefix_),
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.suffix_),
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.contains_),
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.not_in_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.ignore_empty_),
        PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_.well_known_),
        0,
        7,
        5,
        6,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        8,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _impl_.defined_only_),
        PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::EnumRules, _impl_.not_in_),
        0,
        1,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::MessageRules, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::MessageRules, _impl_.skip_),
        PROTOBUF_FIELD_OFFSET(::validate::MessageRules, _impl_.required_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _impl_.min_items_),
        PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _impl_.max_items_),
        PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _impl_.unique_),
        PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _impl_.items_),
        PROTOBUF_FIELD_OFFSET(::validate::RepeatedRules, _impl_.ignore_empty_),
        1,
        2,
        3,
        0,
        4,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_._has_bits_),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_.min_pairs_),
        PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_.max_pairs_),
        PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_.no_sparse_),
        PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_.keys_),
        PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_.values_),
        PROTOBUF_FIELD_OFFSET(::validate::MapRules, _impl_.ignore_empty_),
        2,
        3,
        4,
        0,
        1,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _impl_.required_),
        PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::AnyRules, _impl_.not_in_),
        0,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.required_),
        PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::validate::DurationRules, _impl_.not_in_),
        5,
        0,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_._has_bits_),
        12, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.required_),
        PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.lt_),
        PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.lte_),
        PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.gt_),
        PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.gte_),
        PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.lt_now_),
        PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.gt_now_),
        PROTOBUF_FIELD_OFFSET(::validate::TimestampRules, _impl_.within_),
        6,
        0,
        1,
        2,
        3,
        4,
        7,
        8,
        5,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, sizeof(::validate::FieldRules)},
        {49, sizeof(::validate::FloatRules)},
        {68, sizeof(::validate::DoubleRules)},
        {87, sizeof(::validate::Int32Rules)},
        {106, sizeof(::validate::Int64Rules)},
        {125, sizeof(::validate::UInt32Rules)},
        {144, sizeof(::validate::UInt64Rules)},
        {163, sizeof(::validate::SInt32Rules)},
        {182, sizeof(::validate::SInt64Rules)},
        {201, sizeof(::validate::Fixed32Rules)},
        {220, sizeof(::validate::Fixed64Rules)},
        {239, sizeof(::validate::SFixed32Rules)},
        {258, sizeof(::validate::SFixed64Rules)},
        {277, sizeof(::validate::BoolRules)},
        {282, sizeof(::validate::StringRules)},
        {339, sizeof(::validate::BytesRules)},
        {372, sizeof(::validate::EnumRules)},
        {383, sizeof(::validate::MessageRules)},
        {390, sizeof(::validate::RepeatedRules)},
        {403, sizeof(::validate::MapRules)},
        {418, sizeof(::validate::AnyRules)},
        {427, sizeof(::validate::DurationRules)},
        {446, sizeof(::validate::TimestampRules)},
};
static const ::_pb::Message* PROTOBUF_NONNULL const file_default_instances[] = {
    &::validate::_FieldRules_default_instance_._instance,
    &::validate::_FloatRules_default_instance_._instance,
    &::validate::_DoubleRules_default_instance_._instance,
    &::validate::_Int32Rules_default_instance_._instance,
    &::validate::_Int64Rules_default_instance_._instance,
    &::validate::_UInt32Rules_default_instance_._instance,
    &::validate::_UInt64Rules_default_instance_._instance,
    &::validate::_SInt32Rules_default_instance_._instance,
    &::validate::_SInt64Rules_default_instance_._instance,
    &::validate::_Fixed32Rules_default_instance_._instance,
    &::validate::_Fixed64Rules_default_instance_._instance,
    &::validate::_SFixed32Rules_default_instance_._instance,
    &::validate::_SFixed64Rules_default_instance_._instance,
    &::validate::_BoolRules_default_instance_._instance,
    &::validate::_StringRules_default_instance_._instance,
    &::validate::_BytesRules_default_instance_._instance,
    &::validate::_EnumRules_default_instance_._instance,
    &::validate::_MessageRules_default_instance_._instance,
    &::validate::_RepeatedRules_default_instance_._instance,
    &::validate::_MapRules_default_instance_._instance,
    &::validate::_AnyRules_default_instance_._instance,
    &::validate::_DurationRules_default_instance_._instance,
    &::validate::_TimestampRules_default_instance_._instance,
};
const char descriptor_table_protodef_validate_2fvalidate_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\027validate/validate.proto\022\010validate\032 goo"
    "gle/protobuf/descriptor.proto\032\036google/pr"
    "otobuf/duration.proto\032\037google/protobuf/t"
    "imestamp.proto\"\230\007\n\nFieldRules\022\'\n\007message"
    "\030\021 \001(\0132\026.validate.MessageRules\022%\n\005float\030"
    "\001 \001(\0132\024.validate.FloatRulesH\000\022\'\n\006double\030"
    "\002 \001(\0132\025.validate.DoubleRulesH\000\022%\n\005int32\030"
    "\003 \001(\0132\024.validate.Int32RulesH\000\022%\n\005int64\030\004"
    " \001(\0132\024.validate.Int64RulesH\000\022\'\n\006uint32\030\005"
    " \001(\0132\025.validate.UInt32RulesH\000\022\'\n\006uint64\030"
    "\006 \001(\0132\025.validate.UInt64RulesH\000\022\'\n\006sint32"
    "\030\007 \001(\0132\025.validate.SInt32RulesH\000\022\'\n\006sint6"
    "4\030\010 \001(\0132\025.validate.SInt64RulesH\000\022)\n\007fixe"
    "d32\030\t \001(\0132\026.validate.Fixed32RulesH\000\022)\n\007f"
    "ixed64\030\n \001(\0132\026.validate.Fixed64RulesH\000\022+"
    "\n\010sfixed32\030\013 \001(\0132\027.validate.SFixed32Rule"
    "sH\000\022+\n\010sfixed64\030\014 \001(\0132\027.validate.SFixed6"
    "4RulesH\000\022#\n\004bool\030\r \001(\0132\023.validate.BoolRu"
    "lesH\000\022\'\n\006string\030\016 \001(\0132\025.validate.StringR"
    "ulesH\000\022%\n\005bytes\030\017 \001(\0132\024.validate.BytesRu"
    "lesH\000\022#\n\004enum\030\020 \001(\0132\023.validate.EnumRules"
    "H\000\022+\n\010repeated\030\022 \001(\0132\027.validate.Repeated"
    "RulesH\000\022!\n\003map\030\023 \001(\0132\022.validate.MapRules"
    "H\000\022!\n\003any\030\024 \001(\0132\022.validate.AnyRulesH\000\022+\n"
    "\010duration\030\025 \001(\0132\027.validate.DurationRules"
    "H\000\022-\n\ttimestamp\030\026 \001(\0132\030.validate.Timesta"
    "mpRulesH\000B\006\n\004type\"\177\n\nFloatRules\022\r\n\005const"
    "\030\001 \001(\002\022\n\n\002lt\030\002 \001(\002\022\013\n\003lte\030\003 \001(\002\022\n\n\002gt\030\004 "
    "\001(\002\022\013\n\003gte\030\005 \001(\002\022\n\n\002in\030\006 \003(\002\022\016\n\006not_in\030\007"
    " \003(\002\022\024\n\014ignore_empty\030\010 \001(\010\"\200\001\n\013DoubleRul"
    "es\022\r\n\005const\030\001 \001(\001\022\n\n\002lt\030\002 \001(\001\022\013\n\003lte\030\003 \001"
    "(\001\022\n\n\002gt\030\004 \001(\001\022\013\n\003gte\030\005 \001(\001\022\n\n\002in\030\006 \003(\001\022"
    "\016\n\006not_in\030\007 \003(\001\022\024\n\014ignore_empty\030\010 \001(\010\"\177\n"
    "\nInt32Rules\022\r\n\005const\030\001 \001(\005\022\n\n\002lt\030\002 \001(\005\022\013"
    "\n\003lte\030\003 \001(\005\022\n\n\002gt\030\004 \001(\005\022\013\n\003gte\030\005 \001(\005\022\n\n\002"
    "in\030\006 \003(\005\022\016\n\006not_in\030\007 \003(\005\022\024\n\014ignore_empty"
    "\030\010 \001(\010\"\177\n\nInt64Rules\022\r\n\005const\030\001 \001(\003\022\n\n\002l"
    "t\030\002 \001(\003\022\013\n\003lte\030\003 \001(\003\022\n\n\002gt\030\004 \001(\003\022\013\n\003gte\030"
    "\005 \001(\003\022\n\n\002in\030\006 \003(\003\022\016\n\006not_in\030\007 \003(\003\022\024\n\014ign"
    "ore_empty\030\010 \001(\010\"\200\001\n\013UInt32Rules\022\r\n\005const"
    "\030\001 \001(\r\022\n\n\002lt\030\002 \001(\r\022\013\n\003lte\030\003 \001(\r\022\n\n\002gt\030\004 "
    "\001(\r\022\013\n\003gte\030\005 \001(\r\022\n\n\002in\030\006 \003(\r\022\016\n\006not_in\030\007"
    " \003(\r\022\024\n\014ignore_empty\030\010 \001(\010\"\200\001\n\013UInt64Rul"
    "es\022\r\n\005const\030\001 \001(\004\022\n\n\002lt\030\002 \001(\004\022\013\n\003lte\030\003 \001"
    "(\004\022\n\n\002gt\030\004 \001(\004\022\013\n\003gte\030\005 \001(\004\022\n\n\002in\030\006 \003(\004\022"
    "\016\n\006not_in\030\007 \003(\004\022\024\n\014ignore_empty\030\010 \001(\010\"\200\001"
    "\n\013SInt32Rules\022\r\n\005const\030\001 \001(\021\022\n\n\002lt\030\002 \001(\021"
    "\022\013\n\003lte\030\003 \001(\021\022\n\n\002gt\030\004 \001(\021\022\013\n\003gte\030\005 \001(\021\022\n"
    "\n\002in\030\006 \003(\021\022\016\n\006not_in\030\007 \003(\021\022\024\n\014ignore_emp"
    "ty\030\010 \001(\010\"\200\001\n\013SInt64Rules\022\r\n\005const\030\001 \001(\022\022"
    "\n\n\002lt\030\002 \001(\022\022\013\n\003lte\030\003 \001(\022\022\n\n\002gt\030\004 \001(\022\022\013\n\003"
    "gte\030\005 \001(\022\022\n\n\002in\030\006 \003(\022\022\016\n\006not_in\030\007 \003(\022\022\024\n"
    "\014ignore_empty\030\010 \001(\010\"\201\001\n\014Fixed32Rules\022\r\n\005"
    "const\030\001 \001(\007\022\n\n\002lt\030\002 \001(\007\022\013\n\003lte\030\003 \001(\007\022\n\n\002"
    "gt\030\004 \001(\007\022\013\n\003gte\030\005 \001(\007\022\n\n\002in\030\006 \003(\007\022\016\n\006not"
    "_in\030\007 \003(\007\022\024\n\014ignore_empty\030\010 \001(\010\"\201\001\n\014Fixe"
    "d64Rules\022\r\n\005const\030\001 \001(\006\022\n\n\002lt\030\002 \001(\006\022\013\n\003l"
    "te\030\003 \001(\006\022\n\n\002gt\030\004 \001(\006\022\013\n\003gte\030\005 \001(\006\022\n\n\002in\030"
    "\006 \003(\006\022\016\n\006not_in\030\007 \003(\006\022\024\n\014ignore_empty\030\010 "
    "\001(\010\"\202\001\n\rSFixed32Rules\022\r\n\005const\030\001 \001(\017\022\n\n\002"
    "lt\030\002 \001(\017\022\013\n\003lte\030\003 \001(\017\022\n\n\002gt\030\004 \001(\017\022\013\n\003gte"
    "\030\005 \001(\017\022\n\n\002in\030\006 \003(\017\022\016\n\006not_in\030\007 \003(\017\022\024\n\014ig"
    "nore_empty\030\010 \001(\010\"\202\001\n\rSFixed64Rules\022\r\n\005co"
    "nst\030\001 \001(\020\022\n\n\002lt\030\002 \001(\020\022\013\n\003lte\030\003 \001(\020\022\n\n\002gt"
    "\030\004 \001(\020\022\013\n\003gte\030\005 \001(\020\022\n\n\002in\030\006 \003(\020\022\016\n\006not_i"
    "n\030\007 \003(\020\022\024\n\014ignore_empty\030\010 \001(\010\"\032\n\tBoolRul"
    "es\022\r\n\005const\030\001 \001(\010\"\375\003\n\013StringRules\022\r\n\005con"
    "st\030\001 \001(\t\022\013\n\003len\030\023 \001(\004\022\017\n\007min_len\030\002 \001(\004\022\017"
    "\n\007max_len\030\003 \001(\004\022\021\n\tlen_bytes\030\024 \001(\004\022\021\n\tmi"
    "n_bytes\030\004 \001(\004\022\021\n\tmax_bytes\030\005 \001(\004\022\017\n\007patt"
    "ern\030\006 \001(\t\022\016\n\006prefix\030\007 \001(\t\022\016\n\006suffix\030\010 \001("
    "\t\022\020\n\010contains\030\t \001(\t\022\024\n\014not_contains\030\027 \001("
    "\t\022\n\n\002in\030\n \003(\t\022\016\n\006not_in\030\013 \003(\t\022\017\n\005email\030\014"
    " \001(\010H\000\022\022\n\010hostname\030\r \001(\010H\000\022\014\n\002ip\030\016 \001(\010H\000"
    "\022\016\n\004ipv4\030\017 \001(\010H\000\022\016\n\004ipv6\030\020 \001(\010H\000\022\r\n\003uri\030"
    "\021 \001(\010H\000\022\021\n\007uri_ref\030\022 \001(\010H\000\022\021\n\007address\030\025 "
    "\001(\010H\000\022\016\n\004uuid\030\026 \001(\010H\000\0220\n\020well_known_rege"
    "x\030\030 \001(\0162\024.validate.KnownRegexH\000\022\024\n\006stric"
    "t\030\031 \001(\010:\004true\022\024\n\014ignore_empty\030\032 \001(\010B\014\n\nw"
    "ell_known\"\373\001\n\nBytesRules\022\r\n\005const\030\001 \001(\014\022"
    "\013\n\003len\030\r \001(\004\022\017\n\007min_len\030\002 \001(\004\022\017\n\007max_len"
    "\030\003 \001(\004\022\017\n\007pattern\030\004 \001(\t\022\016\n\006prefix\030\005 \001(\014\022"
    "\016\n\006suffix\030\006 \001(\014\022\020\n\010contains\030\007 \001(\014\022\n\n\002in\030"
    "\010 \003(\014\022\016\n\006not_in\030\t \003(\014\022\014\n\002ip\030\n \001(\010H\000\022\016\n\004i"
    "pv4\030\013 \001(\010H\000\022\016\n\004ipv6\030\014 \001(\010H\000\022\024\n\014ignore_em"
    "pty\030\016 \001(\010B\014\n\nwell_known\"L\n\tEnumRules\022\r\n\005"
    "const\030\001 \001(\005\022\024\n\014defined_only\030\002 \001(\010\022\n\n\002in\030"
    "\003 \003(\005\022\016\n\006not_in\030\004 \003(\005\".\n\014MessageRules\022\014\n"
    "\004skip\030\001 \001(\010\022\020\n\010required\030\002 \001(\010\"\200\001\n\rRepeat"
    "edRules\022\021\n\tmin_items\030\001 \001(\004\022\021\n\tmax_items\030"
    "\002 \001(\004\022\016\n\006unique\030\003 \001(\010\022#\n\005items\030\004 \001(\0132\024.v"
    "alidate.FieldRules\022\024\n\014ignore_empty\030\005 \001(\010"
    "\"\243\001\n\010MapRules\022\021\n\tmin_pairs\030\001 \001(\004\022\021\n\tmax_"
    "pairs\030\002 \001(\004\022\021\n\tno_sparse\030\003 \001(\010\022\"\n\004keys\030\004"
    " \001(\0132\024.validate.FieldRules\022$\n\006values\030\005 \001"
    "(\0132\024.validate.FieldRules\022\024\n\014ignore_empty"
    "\030\006 \001(\010\"8\n\010AnyRules\022\020\n\010required\030\001 \001(\010\022\n\n\002"
    "in\030\002 \003(\t\022\016\n\006not_in\030\003 \003(\t\"\273\002\n\rDurationRul"
    "es\022\020\n\010required\030\001 \001(\010\022(\n\005const\030\002 \001(\0132\031.go"
    "ogle.protobuf.Duration\022%\n\002lt\030\003 \001(\0132\031.goo"
    "gle.protobuf.Duration\022&\n\003lte\030\004 \001(\0132\031.goo"
    "gle.protobuf.Duration\022%\n\002gt\030\005 \001(\0132\031.goog"
    "le.protobuf.Duration\022&\n\003gte\030\006 \001(\0132\031.goog"
    "le.protobuf.Duration\022%\n\002in\030\007 \003(\0132\031.googl"
    "e.protobuf.Duration\022)\n\006not_in\030\010 \003(\0132\031.go"
    "ogle.protobuf.Duration\"\272\002\n\016TimestampRule"
    "s\022\020\n\010required\030\001 \001(\010\022)\n\005const\030\002 \001(\0132\032.goo"
    "gle.protobuf.Timestamp\022&\n\002lt\030\003 \001(\0132\032.goo"
    "gle.protobuf.Timestamp\022\'\n\003lte\030\004 \001(\0132\032.go"
    "ogle.protobuf.Timestamp\022&\n\002gt\030\005 \001(\0132\032.go"
    "ogle.protobuf.Timestamp\022\'\n\003gte\030\006 \001(\0132\032.g"
    "oogle.protobuf.Timestamp\022\016\n\006lt_now\030\007 \001(\010"
    "\022\016\n\006gt_now\030\010 \001(\010\022)\n\006within\030\t \001(\0132\031.googl"
    "e.protobuf.Duration*F\n\nKnownRegex\022\013\n\007UNK"
    "NOWN\020\000\022\024\n\020HTTP_HEADER_NAME\020\001\022\025\n\021HTTP_HEA"
    "DER_VALUE\020\002:2\n\010disabled\022\037.google.protobu"
    "f.MessageOptions\030\257\010 \001(\010:1\n\007ignored\022\037.goo"
    "gle.protobuf.MessageOptions\030\260\010 \001(\010:0\n\010re"
    "quired\022\035.google.protobuf.OneofOptions\030\257\010"
    " \001(\010:C\n\005rules\022\035.google.protobuf.FieldOpt"
    "ions\030\257\010 \001(\0132\024.validate.FieldRulesBP\n\032io."
    "envoyproxy.pgv.validateZ2github.com/envo"
    "yproxy/protoc-gen-validate/validate"
};
static const ::_pbi::DescriptorTable* PROTOBUF_NONNULL const
    descriptor_table_validate_2fvalidate_2eproto_deps[3] = {
        &::descriptor_table_google_2fprotobuf_2fdescriptor_2eproto,
        &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
        &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
};
static ::absl::once_flag descriptor_table_validate_2fvalidate_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_validate_2fvalidate_2eproto = {
    false,
    false,
    4915,
    descriptor_table_protodef_validate_2fvalidate_2eproto,
    "validate/validate.proto",
    &descriptor_table_validate_2fvalidate_2eproto_once,
    descriptor_table_validate_2fvalidate_2eproto_deps,
    3,
    23,
    schemas,
    file_default_instances,
    TableStruct_validate_2fvalidate_2eproto::offsets,
    file_level_enum_descriptors_validate_2fvalidate_2eproto,
    file_level_service_descriptors_validate_2fvalidate_2eproto,
};
namespace validate {
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL KnownRegex_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_validate_2fvalidate_2eproto);
  return file_level_enum_descriptors_validate_2fvalidate_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t KnownRegex_internal_data_[] = {
    196608u, 0u, };
// ===================================================================

class FieldRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<FieldRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(FieldRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::validate::FieldRules, _impl_._oneof_case_);
};

void FieldRules::set_allocated_float_(::validate::FloatRules* PROTOBUF_NULLABLE float_) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (float_) {
    ::google::protobuf::Arena* submessage_arena = float_->GetArena();
    if (message_arena != submessage_arena) {
      float_ = ::google::protobuf::internal::GetOwnedMessage(message_arena, float_, submessage_arena);
    }
    set_has_float_();
    _impl_.type_.float__ = float_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.float)
}
void FieldRules::set_allocated_double_(::validate::DoubleRules* PROTOBUF_NULLABLE double_) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (double_) {
    ::google::protobuf::Arena* submessage_arena = double_->GetArena();
    if (message_arena != submessage_arena) {
      double_ = ::google::protobuf::internal::GetOwnedMessage(message_arena, double_, submessage_arena);
    }
    set_has_double_();
    _impl_.type_.double__ = double_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.double)
}
void FieldRules::set_allocated_int32(::validate::Int32Rules* PROTOBUF_NULLABLE int32) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (int32) {
    ::google::protobuf::Arena* submessage_arena = int32->GetArena();
    if (message_arena != submessage_arena) {
      int32 = ::google::protobuf::internal::GetOwnedMessage(message_arena, int32, submessage_arena);
    }
    set_has_int32();
    _impl_.type_.int32_ = int32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.int32)
}
void FieldRules::set_allocated_int64(::validate::Int64Rules* PROTOBUF_NULLABLE int64) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (int64) {
    ::google::protobuf::Arena* submessage_arena = int64->GetArena();
    if (message_arena != submessage_arena) {
      int64 = ::google::protobuf::internal::GetOwnedMessage(message_arena, int64, submessage_arena);
    }
    set_has_int64();
    _impl_.type_.int64_ = int64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.int64)
}
void FieldRules::set_allocated_uint32(::validate::UInt32Rules* PROTOBUF_NULLABLE uint32) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (uint32) {
    ::google::protobuf::Arena* submessage_arena = uint32->GetArena();
    if (message_arena != submessage_arena) {
      uint32 = ::google::protobuf::internal::GetOwnedMessage(message_arena, uint32, submessage_arena);
    }
    set_has_uint32();
    _impl_.type_.uint32_ = uint32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.uint32)
}
void FieldRules::set_allocated_uint64(::validate::UInt64Rules* PROTOBUF_NULLABLE uint64) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (uint64) {
    ::google::protobuf::Arena* submessage_arena = uint64->GetArena();
    if (message_arena != submessage_arena) {
      uint64 = ::google::protobuf::internal::GetOwnedMessage(message_arena, uint64, submessage_arena);
    }
    set_has_uint64();
    _impl_.type_.uint64_ = uint64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.uint64)
}
void FieldRules::set_allocated_sint32(::validate::SInt32Rules* PROTOBUF_NULLABLE sint32) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (sint32) {
    ::google::protobuf::Arena* submessage_arena = sint32->GetArena();
    if (message_arena != submessage_arena) {
      sint32 = ::google::protobuf::internal::GetOwnedMessage(message_arena, sint32, submessage_arena);
    }
    set_has_sint32();
    _impl_.type_.sint32_ = sint32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sint32)
}
void FieldRules::set_allocated_sint64(::validate::SInt64Rules* PROTOBUF_NULLABLE sint64) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (sint64) {
    ::google::protobuf::Arena* submessage_arena = sint64->GetArena();
    if (message_arena != submessage_arena) {
      sint64 = ::google::protobuf::internal::GetOwnedMessage(message_arena, sint64, submessage_arena);
    }
    set_has_sint64();
    _impl_.type_.sint64_ = sint64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sint64)
}
void FieldRules::set_allocated_fixed32(::validate::Fixed32Rules* PROTOBUF_NULLABLE fixed32) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (fixed32) {
    ::google::protobuf::Arena* submessage_arena = fixed32->GetArena();
    if (message_arena != submessage_arena) {
      fixed32 = ::google::protobuf::internal::GetOwnedMessage(message_arena, fixed32, submessage_arena);
    }
    set_has_fixed32();
    _impl_.type_.fixed32_ = fixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.fixed32)
}
void FieldRules::set_allocated_fixed64(::validate::Fixed64Rules* PROTOBUF_NULLABLE fixed64) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (fixed64) {
    ::google::protobuf::Arena* submessage_arena = fixed64->GetArena();
    if (message_arena != submessage_arena) {
      fixed64 = ::google::protobuf::internal::GetOwnedMessage(message_arena, fixed64, submessage_arena);
    }
    set_has_fixed64();
    _impl_.type_.fixed64_ = fixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.fixed64)
}
void FieldRules::set_allocated_sfixed32(::validate::SFixed32Rules* PROTOBUF_NULLABLE sfixed32) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (sfixed32) {
    ::google::protobuf::Arena* submessage_arena = sfixed32->GetArena();
    if (message_arena != submessage_arena) {
      sfixed32 = ::google::protobuf::internal::GetOwnedMessage(message_arena, sfixed32, submessage_arena);
    }
    set_has_sfixed32();
    _impl_.type_.sfixed32_ = sfixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sfixed32)
}
void FieldRules::set_allocated_sfixed64(::validate::SFixed64Rules* PROTOBUF_NULLABLE sfixed64) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (sfixed64) {
    ::google::protobuf::Arena* submessage_arena = sfixed64->GetArena();
    if (message_arena != submessage_arena) {
      sfixed64 = ::google::protobuf::internal::GetOwnedMessage(message_arena, sfixed64, submessage_arena);
    }
    set_has_sfixed64();
    _impl_.type_.sfixed64_ = sfixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.sfixed64)
}
void FieldRules::set_allocated_bool_(::validate::BoolRules* PROTOBUF_NULLABLE bool_) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (bool_) {
    ::google::protobuf::Arena* submessage_arena = bool_->GetArena();
    if (message_arena != submessage_arena) {
      bool_ = ::google::protobuf::internal::GetOwnedMessage(message_arena, bool_, submessage_arena);
    }
    set_has_bool_();
    _impl_.type_.bool__ = bool_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.bool)
}
void FieldRules::set_allocated_string(::validate::StringRules* PROTOBUF_NULLABLE string) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (string) {
    ::google::protobuf::Arena* submessage_arena = string->GetArena();
    if (message_arena != submessage_arena) {
      string = ::google::protobuf::internal::GetOwnedMessage(message_arena, string, submessage_arena);
    }
    set_has_string();
    _impl_.type_.string_ = string;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.string)
}
void FieldRules::set_allocated_bytes(::validate::BytesRules* PROTOBUF_NULLABLE bytes) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (bytes) {
    ::google::protobuf::Arena* submessage_arena = bytes->GetArena();
    if (message_arena != submessage_arena) {
      bytes = ::google::protobuf::internal::GetOwnedMessage(message_arena, bytes, submessage_arena);
    }
    set_has_bytes();
    _impl_.type_.bytes_ = bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.bytes)
}
void FieldRules::set_allocated_enum_(::validate::EnumRules* PROTOBUF_NULLABLE enum_) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (enum_) {
    ::google::protobuf::Arena* submessage_arena = enum_->GetArena();
    if (message_arena != submessage_arena) {
      enum_ = ::google::protobuf::internal::GetOwnedMessage(message_arena, enum_, submessage_arena);
    }
    set_has_enum_();
    _impl_.type_.enum__ = enum_;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.enum)
}
void FieldRules::set_allocated_repeated(::validate::RepeatedRules* PROTOBUF_NULLABLE repeated) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (repeated) {
    ::google::protobuf::Arena* submessage_arena = repeated->GetArena();
    if (message_arena != submessage_arena) {
      repeated = ::google::protobuf::internal::GetOwnedMessage(message_arena, repeated, submessage_arena);
    }
    set_has_repeated();
    _impl_.type_.repeated_ = repeated;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.repeated)
}
void FieldRules::set_allocated_map(::validate::MapRules* PROTOBUF_NULLABLE map) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (map) {
    ::google::protobuf::Arena* submessage_arena = map->GetArena();
    if (message_arena != submessage_arena) {
      map = ::google::protobuf::internal::GetOwnedMessage(message_arena, map, submessage_arena);
    }
    set_has_map();
    _impl_.type_.map_ = map;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.map)
}
void FieldRules::set_allocated_any(::validate::AnyRules* PROTOBUF_NULLABLE any) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (any) {
    ::google::protobuf::Arena* submessage_arena = any->GetArena();
    if (message_arena != submessage_arena) {
      any = ::google::protobuf::internal::GetOwnedMessage(message_arena, any, submessage_arena);
    }
    set_has_any();
    _impl_.type_.any_ = any;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.any)
}
void FieldRules::set_allocated_duration(::validate::DurationRules* PROTOBUF_NULLABLE duration) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (duration) {
    ::google::protobuf::Arena* submessage_arena = duration->GetArena();
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(message_arena, duration, submessage_arena);
    }
    set_has_duration();
    _impl_.type_.duration_ = duration;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.duration)
}
void FieldRules::set_allocated_timestamp(::validate::TimestampRules* PROTOBUF_NULLABLE timestamp) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = timestamp->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(message_arena, timestamp, submessage_arena);
    }
    set_has_timestamp();
    _impl_.type_.timestamp_ = timestamp;
  }
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.timestamp)
}
FieldRules::FieldRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FieldRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.FieldRules)
}
PROTOBUF_NDEBUG_INLINE FieldRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::FieldRules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        type_{},
        _oneof_case_{from._oneof_case_[0]} {}

FieldRules::FieldRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const FieldRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FieldRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  FieldRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.message_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.message_)
                : nullptr;
  switch (type_case()) {
    case TYPE_NOT_SET:
      break;
      case kFloat:
        _impl_.type_.float__ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.float__);
        break;
      case kDouble:
        _impl_.type_.double__ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.double__);
        break;
      case kInt32:
        _impl_.type_.int32_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.int32_);
        break;
      case kInt64:
        _impl_.type_.int64_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.int64_);
        break;
      case kUint32:
        _impl_.type_.uint32_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.uint32_);
        break;
      case kUint64:
        _impl_.type_.uint64_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.uint64_);
        break;
      case kSint32:
        _impl_.type_.sint32_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.sint32_);
        break;
      case kSint64:
        _impl_.type_.sint64_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.sint64_);
        break;
      case kFixed32:
        _impl_.type_.fixed32_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.fixed32_);
        break;
      case kFixed64:
        _impl_.type_.fixed64_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.fixed64_);
        break;
      case kSfixed32:
        _impl_.type_.sfixed32_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.sfixed32_);
        break;
      case kSfixed64:
        _impl_.type_.sfixed64_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.sfixed64_);
        break;
      case kBool:
        _impl_.type_.bool__ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.bool__);
        break;
      case kString:
        _impl_.type_.string_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.string_);
        break;
      case kBytes:
        _impl_.type_.bytes_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.bytes_);
        break;
      case kEnum:
        _impl_.type_.enum__ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.enum__);
        break;
      case kRepeated:
        _impl_.type_.repeated_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.repeated_);
        break;
      case kMap:
        _impl_.type_.map_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.map_);
        break;
      case kAny:
        _impl_.type_.any_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.any_);
        break;
      case kDuration:
        _impl_.type_.duration_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.duration_);
        break;
      case kTimestamp:
        _impl_.type_.timestamp_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.timestamp_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:validate.FieldRules)
}
PROTOBUF_NDEBUG_INLINE FieldRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        type_{},
        _oneof_case_{} {}

inline void FieldRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.message_ = {};
}
FieldRules::~FieldRules() {
  // @@protoc_insertion_point(destructor:validate.FieldRules)
  SharedDtor(*this);
}
inline void FieldRules::SharedDtor(MessageLite& self) {
  FieldRules& this_ = static_cast<FieldRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.message_;
  if (this_.has_type()) {
    this_.clear_type();
  }
  this_._impl_.~Impl_();
}

void FieldRules::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:validate.FieldRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (type_case()) {
    case kFloat: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.float__;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.float__);
      }
      break;
    }
    case kDouble: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.double__;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.double__);
      }
      break;
    }
    case kInt32: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.int32_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.int32_);
      }
      break;
    }
    case kInt64: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.int64_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.int64_);
      }
      break;
    }
    case kUint32: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.uint32_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.uint32_);
      }
      break;
    }
    case kUint64: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.uint64_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.uint64_);
      }
      break;
    }
    case kSint32: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.sint32_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sint32_);
      }
      break;
    }
    case kSint64: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.sint64_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sint64_);
      }
      break;
    }
    case kFixed32: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.fixed32_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.fixed32_);
      }
      break;
    }
    case kFixed64: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.fixed64_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.fixed64_);
      }
      break;
    }
    case kSfixed32: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.sfixed32_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sfixed32_);
      }
      break;
    }
    case kSfixed64: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.sfixed64_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sfixed64_);
      }
      break;
    }
    case kBool: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.bool__;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.bool__);
      }
      break;
    }
    case kString: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.string_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.string_);
      }
      break;
    }
    case kBytes: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.bytes_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.bytes_);
      }
      break;
    }
    case kEnum: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.enum__;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.enum__);
      }
      break;
    }
    case kRepeated: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.repeated_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.repeated_);
      }
      break;
    }
    case kMap: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.map_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.map_);
      }
      break;
    }
    case kAny: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.any_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.any_);
      }
      break;
    }
    case kDuration: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.duration_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.duration_);
      }
      break;
    }
    case kTimestamp: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.timestamp_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.timestamp_);
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}


inline void* PROTOBUF_NONNULL FieldRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) FieldRules(arena);
}
constexpr auto FieldRules::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(FieldRules),
                                            alignof(FieldRules));
}
constexpr auto FieldRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_FieldRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &FieldRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<FieldRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &FieldRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<FieldRules>(), &FieldRules::ByteSizeLong,
              &FieldRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(FieldRules, _impl_._cached_size_),
          false,
      },
      &FieldRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull FieldRules_class_data_ =
        FieldRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
FieldRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&FieldRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(FieldRules_class_data_.tc_table);
  return FieldRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 22, 22, 0, 2>
FieldRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FieldRules, _impl_._has_bits_),
    0, // no _extensions_
    22, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4290772992,  // skipmap
    offsetof(decltype(_table_), field_entries),
    22,  // num_field_entries
    22,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    FieldRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::FieldRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .validate.MessageRules message = 17;
    {::_pbi::TcParser::FastMtS2,
     {394, 0, 16, PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.message_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .validate.FloatRules float = 1;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.float__), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.DoubleRules double = 2;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.double__), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.Int32Rules int32 = 3;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.int32_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.Int64Rules int64 = 4;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.int64_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.UInt32Rules uint32 = 5;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.uint32_), _Internal::kOneofCaseOffset + 0, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.UInt64Rules uint64 = 6;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.uint64_), _Internal::kOneofCaseOffset + 0, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.SInt32Rules sint32 = 7;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.sint32_), _Internal::kOneofCaseOffset + 0, 6,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.SInt64Rules sint64 = 8;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.sint64_), _Internal::kOneofCaseOffset + 0, 7,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.Fixed32Rules fixed32 = 9;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.fixed32_), _Internal::kOneofCaseOffset + 0, 8,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.Fixed64Rules fixed64 = 10;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.fixed64_), _Internal::kOneofCaseOffset + 0, 9,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.SFixed32Rules sfixed32 = 11;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.sfixed32_), _Internal::kOneofCaseOffset + 0, 10,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.SFixed64Rules sfixed64 = 12;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.sfixed64_), _Internal::kOneofCaseOffset + 0, 11,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.BoolRules bool = 13;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.bool__), _Internal::kOneofCaseOffset + 0, 12,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.StringRules string = 14;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.string_), _Internal::kOneofCaseOffset + 0, 13,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.BytesRules bytes = 15;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.bytes_), _Internal::kOneofCaseOffset + 0, 14,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.EnumRules enum = 16;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.enum__), _Internal::kOneofCaseOffset + 0, 15,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .validate.MessageRules message = 17;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.message_), _Internal::kHasBitsOffset + 0, 16,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.RepeatedRules repeated = 18;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.repeated_), _Internal::kOneofCaseOffset + 0, 17,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.MapRules map = 19;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.map_), _Internal::kOneofCaseOffset + 0, 18,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.AnyRules any = 20;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.any_), _Internal::kOneofCaseOffset + 0, 19,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.DurationRules duration = 21;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.duration_), _Internal::kOneofCaseOffset + 0, 20,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .validate.TimestampRules timestamp = 22;
    {PROTOBUF_FIELD_OFFSET(FieldRules, _impl_.type_.timestamp_), _Internal::kOneofCaseOffset + 0, 21,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::validate::FloatRules>()},
      {::_pbi::TcParser::GetTable<::validate::DoubleRules>()},
      {::_pbi::TcParser::GetTable<::validate::Int32Rules>()},
      {::_pbi::TcParser::GetTable<::validate::Int64Rules>()},
      {::_pbi::TcParser::GetTable<::validate::UInt32Rules>()},
      {::_pbi::TcParser::GetTable<::validate::UInt64Rules>()},
      {::_pbi::TcParser::GetTable<::validate::SInt32Rules>()},
      {::_pbi::TcParser::GetTable<::validate::SInt64Rules>()},
      {::_pbi::TcParser::GetTable<::validate::Fixed32Rules>()},
      {::_pbi::TcParser::GetTable<::validate::Fixed64Rules>()},
      {::_pbi::TcParser::GetTable<::validate::SFixed32Rules>()},
      {::_pbi::TcParser::GetTable<::validate::SFixed64Rules>()},
      {::_pbi::TcParser::GetTable<::validate::BoolRules>()},
      {::_pbi::TcParser::GetTable<::validate::StringRules>()},
      {::_pbi::TcParser::GetTable<::validate::BytesRules>()},
      {::_pbi::TcParser::GetTable<::validate::EnumRules>()},
      {::_pbi::TcParser::GetTable<::validate::MessageRules>()},
      {::_pbi::TcParser::GetTable<::validate::RepeatedRules>()},
      {::_pbi::TcParser::GetTable<::validate::MapRules>()},
      {::_pbi::TcParser::GetTable<::validate::AnyRules>()},
      {::_pbi::TcParser::GetTable<::validate::DurationRules>()},
      {::_pbi::TcParser::GetTable<::validate::TimestampRules>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void FieldRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.FieldRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    ABSL_DCHECK(_impl_.message_ != nullptr);
    _impl_.message_->Clear();
  }
  clear_type();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL FieldRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const FieldRules& this_ = static_cast<const FieldRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL FieldRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const FieldRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.FieldRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (this_.type_case()) {
    case kFloat: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          1, *this_._impl_.type_.float__, this_._impl_.type_.float__->GetCachedSize(), target,
          stream);
      break;
    }
    case kDouble: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          2, *this_._impl_.type_.double__, this_._impl_.type_.double__->GetCachedSize(), target,
          stream);
      break;
    }
    case kInt32: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, *this_._impl_.type_.int32_, this_._impl_.type_.int32_->GetCachedSize(), target,
          stream);
      break;
    }
    case kInt64: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *this_._impl_.type_.int64_, this_._impl_.type_.int64_->GetCachedSize(), target,
          stream);
      break;
    }
    case kUint32: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *this_._impl_.type_.uint32_, this_._impl_.type_.uint32_->GetCachedSize(), target,
          stream);
      break;
    }
    case kUint64: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *this_._impl_.type_.uint64_, this_._impl_.type_.uint64_->GetCachedSize(), target,
          stream);
      break;
    }
    case kSint32: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          7, *this_._impl_.type_.sint32_, this_._impl_.type_.sint32_->GetCachedSize(), target,
          stream);
      break;
    }
    case kSint64: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          8, *this_._impl_.type_.sint64_, this_._impl_.type_.sint64_->GetCachedSize(), target,
          stream);
      break;
    }
    case kFixed32: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          9, *this_._impl_.type_.fixed32_, this_._impl_.type_.fixed32_->GetCachedSize(), target,
          stream);
      break;
    }
    case kFixed64: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          10, *this_._impl_.type_.fixed64_, this_._impl_.type_.fixed64_->GetCachedSize(), target,
          stream);
      break;
    }
    case kSfixed32: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          11, *this_._impl_.type_.sfixed32_, this_._impl_.type_.sfixed32_->GetCachedSize(), target,
          stream);
      break;
    }
    case kSfixed64: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          12, *this_._impl_.type_.sfixed64_, this_._impl_.type_.sfixed64_->GetCachedSize(), target,
          stream);
      break;
    }
    case kBool: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          13, *this_._impl_.type_.bool__, this_._impl_.type_.bool__->GetCachedSize(), target,
          stream);
      break;
    }
    case kString: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          14, *this_._impl_.type_.string_, this_._impl_.type_.string_->GetCachedSize(), target,
          stream);
      break;
    }
    case kBytes: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          15, *this_._impl_.type_.bytes_, this_._impl_.type_.bytes_->GetCachedSize(), target,
          stream);
      break;
    }
    case kEnum: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          16, *this_._impl_.type_.enum__, this_._impl_.type_.enum__->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .validate.MessageRules message = 17;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        17, *this_._impl_.message_, this_._impl_.message_->GetCachedSize(), target,
        stream);
  }

  switch (this_.type_case()) {
    case kRepeated: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          18, *this_._impl_.type_.repeated_, this_._impl_.type_.repeated_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMap: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          19, *this_._impl_.type_.map_, this_._impl_.type_.map_->GetCachedSize(), target,
          stream);
      break;
    }
    case kAny: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          20, *this_._impl_.type_.any_, this_._impl_.type_.any_->GetCachedSize(), target,
          stream);
      break;
    }
    case kDuration: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          21, *this_._impl_.type_.duration_, this_._impl_.type_.duration_->GetCachedSize(), target,
          stream);
      break;
    }
    case kTimestamp: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          22, *this_._impl_.type_.timestamp_, this_._impl_.type_.timestamp_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.FieldRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t FieldRules::ByteSizeLong(const MessageLite& base) {
  const FieldRules& this_ = static_cast<const FieldRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t FieldRules::ByteSizeLong() const {
  const FieldRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.FieldRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // optional .validate.MessageRules message = 17;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.message_);
    }
  }
  switch (this_.type_case()) {
    // .validate.FloatRules float = 1;
    case kFloat: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.float__);
      break;
    }
    // .validate.DoubleRules double = 2;
    case kDouble: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.double__);
      break;
    }
    // .validate.Int32Rules int32 = 3;
    case kInt32: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.int32_);
      break;
    }
    // .validate.Int64Rules int64 = 4;
    case kInt64: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.int64_);
      break;
    }
    // .validate.UInt32Rules uint32 = 5;
    case kUint32: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.uint32_);
      break;
    }
    // .validate.UInt64Rules uint64 = 6;
    case kUint64: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.uint64_);
      break;
    }
    // .validate.SInt32Rules sint32 = 7;
    case kSint32: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.sint32_);
      break;
    }
    // .validate.SInt64Rules sint64 = 8;
    case kSint64: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.sint64_);
      break;
    }
    // .validate.Fixed32Rules fixed32 = 9;
    case kFixed32: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.fixed32_);
      break;
    }
    // .validate.Fixed64Rules fixed64 = 10;
    case kFixed64: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.fixed64_);
      break;
    }
    // .validate.SFixed32Rules sfixed32 = 11;
    case kSfixed32: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.sfixed32_);
      break;
    }
    // .validate.SFixed64Rules sfixed64 = 12;
    case kSfixed64: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.sfixed64_);
      break;
    }
    // .validate.BoolRules bool = 13;
    case kBool: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.bool__);
      break;
    }
    // .validate.StringRules string = 14;
    case kString: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.string_);
      break;
    }
    // .validate.BytesRules bytes = 15;
    case kBytes: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.bytes_);
      break;
    }
    // .validate.EnumRules enum = 16;
    case kEnum: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.enum__);
      break;
    }
    // .validate.RepeatedRules repeated = 18;
    case kRepeated: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.repeated_);
      break;
    }
    // .validate.MapRules map = 19;
    case kMap: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.map_);
      break;
    }
    // .validate.AnyRules any = 20;
    case kAny: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.any_);
      break;
    }
    // .validate.DurationRules duration = 21;
    case kDuration: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.duration_);
      break;
    }
    // .validate.TimestampRules timestamp = 22;
    case kTimestamp: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.timestamp_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void FieldRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<FieldRules*>(&to_msg);
  auto& from = static_cast<const FieldRules&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.FieldRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    ABSL_DCHECK(from._impl_.message_ != nullptr);
    if (_this->_impl_.message_ == nullptr) {
      _this->_impl_.message_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.message_);
    } else {
      _this->_impl_.message_->MergeFrom(*from._impl_.message_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_type();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kFloat: {
        if (oneof_needs_init) {
          _this->_impl_.type_.float__ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.float__);
        } else {
          _this->_impl_.type_.float__->MergeFrom(*from._impl_.type_.float__);
        }
        break;
      }
      case kDouble: {
        if (oneof_needs_init) {
          _this->_impl_.type_.double__ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.double__);
        } else {
          _this->_impl_.type_.double__->MergeFrom(*from._impl_.type_.double__);
        }
        break;
      }
      case kInt32: {
        if (oneof_needs_init) {
          _this->_impl_.type_.int32_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.int32_);
        } else {
          _this->_impl_.type_.int32_->MergeFrom(*from._impl_.type_.int32_);
        }
        break;
      }
      case kInt64: {
        if (oneof_needs_init) {
          _this->_impl_.type_.int64_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.int64_);
        } else {
          _this->_impl_.type_.int64_->MergeFrom(*from._impl_.type_.int64_);
        }
        break;
      }
      case kUint32: {
        if (oneof_needs_init) {
          _this->_impl_.type_.uint32_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.uint32_);
        } else {
          _this->_impl_.type_.uint32_->MergeFrom(*from._impl_.type_.uint32_);
        }
        break;
      }
      case kUint64: {
        if (oneof_needs_init) {
          _this->_impl_.type_.uint64_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.uint64_);
        } else {
          _this->_impl_.type_.uint64_->MergeFrom(*from._impl_.type_.uint64_);
        }
        break;
      }
      case kSint32: {
        if (oneof_needs_init) {
          _this->_impl_.type_.sint32_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.sint32_);
        } else {
          _this->_impl_.type_.sint32_->MergeFrom(*from._impl_.type_.sint32_);
        }
        break;
      }
      case kSint64: {
        if (oneof_needs_init) {
          _this->_impl_.type_.sint64_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.sint64_);
        } else {
          _this->_impl_.type_.sint64_->MergeFrom(*from._impl_.type_.sint64_);
        }
        break;
      }
      case kFixed32: {
        if (oneof_needs_init) {
          _this->_impl_.type_.fixed32_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.fixed32_);
        } else {
          _this->_impl_.type_.fixed32_->MergeFrom(*from._impl_.type_.fixed32_);
        }
        break;
      }
      case kFixed64: {
        if (oneof_needs_init) {
          _this->_impl_.type_.fixed64_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.fixed64_);
        } else {
          _this->_impl_.type_.fixed64_->MergeFrom(*from._impl_.type_.fixed64_);
        }
        break;
      }
      case kSfixed32: {
        if (oneof_needs_init) {
          _this->_impl_.type_.sfixed32_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.sfixed32_);
        } else {
          _this->_impl_.type_.sfixed32_->MergeFrom(*from._impl_.type_.sfixed32_);
        }
        break;
      }
      case kSfixed64: {
        if (oneof_needs_init) {
          _this->_impl_.type_.sfixed64_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.sfixed64_);
        } else {
          _this->_impl_.type_.sfixed64_->MergeFrom(*from._impl_.type_.sfixed64_);
        }
        break;
      }
      case kBool: {
        if (oneof_needs_init) {
          _this->_impl_.type_.bool__ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.bool__);
        } else {
          _this->_impl_.type_.bool__->MergeFrom(*from._impl_.type_.bool__);
        }
        break;
      }
      case kString: {
        if (oneof_needs_init) {
          _this->_impl_.type_.string_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.string_);
        } else {
          _this->_impl_.type_.string_->MergeFrom(*from._impl_.type_.string_);
        }
        break;
      }
      case kBytes: {
        if (oneof_needs_init) {
          _this->_impl_.type_.bytes_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.bytes_);
        } else {
          _this->_impl_.type_.bytes_->MergeFrom(*from._impl_.type_.bytes_);
        }
        break;
      }
      case kEnum: {
        if (oneof_needs_init) {
          _this->_impl_.type_.enum__ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.enum__);
        } else {
          _this->_impl_.type_.enum__->MergeFrom(*from._impl_.type_.enum__);
        }
        break;
      }
      case kRepeated: {
        if (oneof_needs_init) {
          _this->_impl_.type_.repeated_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.repeated_);
        } else {
          _this->_impl_.type_.repeated_->MergeFrom(*from._impl_.type_.repeated_);
        }
        break;
      }
      case kMap: {
        if (oneof_needs_init) {
          _this->_impl_.type_.map_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.map_);
        } else {
          _this->_impl_.type_.map_->MergeFrom(*from._impl_.type_.map_);
        }
        break;
      }
      case kAny: {
        if (oneof_needs_init) {
          _this->_impl_.type_.any_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.any_);
        } else {
          _this->_impl_.type_.any_->MergeFrom(*from._impl_.type_.any_);
        }
        break;
      }
      case kDuration: {
        if (oneof_needs_init) {
          _this->_impl_.type_.duration_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.duration_);
        } else {
          _this->_impl_.type_.duration_->MergeFrom(*from._impl_.type_.duration_);
        }
        break;
      }
      case kTimestamp: {
        if (oneof_needs_init) {
          _this->_impl_.type_.timestamp_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.type_.timestamp_);
        } else {
          _this->_impl_.type_.timestamp_->MergeFrom(*from._impl_.type_.timestamp_);
        }
        break;
      }
      case TYPE_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FieldRules::CopyFrom(const FieldRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.FieldRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void FieldRules::InternalSwap(FieldRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.message_, other->_impl_.message_);
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata FieldRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class FloatRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<FloatRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(FloatRules, _impl_._has_bits_);
};

FloatRules::FloatRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FloatRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.FloatRules)
}
PROTOBUF_NDEBUG_INLINE FloatRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::FloatRules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

FloatRules::FloatRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const FloatRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FloatRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  FloatRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.FloatRules)
}
PROTOBUF_NDEBUG_INLINE FloatRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void FloatRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));
}
FloatRules::~FloatRules() {
  // @@protoc_insertion_point(destructor:validate.FloatRules)
  SharedDtor(*this);
}
inline void FloatRules::SharedDtor(MessageLite& self) {
  FloatRules& this_ = static_cast<FloatRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL FloatRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) FloatRules(arena);
}
constexpr auto FloatRules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.in_) +
          decltype(FloatRules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.not_in_) +
          decltype(FloatRules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(FloatRules), alignof(FloatRules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&FloatRules::PlacementNew_,
                                 sizeof(FloatRules),
                                 alignof(FloatRules));
  }
}
constexpr auto FloatRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_FloatRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &FloatRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<FloatRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &FloatRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<FloatRules>(), &FloatRules::ByteSizeLong,
              &FloatRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(FloatRules, _impl_._cached_size_),
          false,
      },
      &FloatRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull FloatRules_class_data_ =
        FloatRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
FloatRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&FloatRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(FloatRules_class_data_.tc_table);
  return FloatRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
FloatRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FloatRules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    FloatRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::FloatRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ignore_empty = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(FloatRules, _impl_.ignore_empty_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.ignore_empty_)}},
    // optional float const = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.const__)}},
    // optional float lt = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.lt_)}},
    // optional float lte = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.lte_)}},
    // optional float gt = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.gt_)}},
    // optional float gte = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.gte_)}},
    // repeated float in = 6;
    {::_pbi::TcParser::FastF32R1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.in_)}},
    // repeated float not_in = 7;
    {::_pbi::TcParser::FastF32R1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional float const = 1;
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float lt = 2;
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float lte = 3;
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float gt = 4;
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float gte = 5;
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // repeated float in = 6;
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFloat)},
    // repeated float not_in = 7;
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFloat)},
    // optional bool ignore_empty = 8;
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void FloatRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.FloatRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL FloatRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const FloatRules& this_ = static_cast<const FloatRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL FloatRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const FloatRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.FloatRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional float const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this_._internal_const_(), target);
  }

  // optional float lt = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this_._internal_lt(), target);
  }

  // optional float lte = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this_._internal_lte(), target);
  }

  // optional float gt = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this_._internal_gt(), target);
  }

  // optional float gte = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this_._internal_gte(), target);
  }

  // repeated float in = 6;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this_._internal_in().Get(i), target);
  }

  // repeated float not_in = 7;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this_._internal_not_in().Get(i), target);
  }

  // optional bool ignore_empty = 8;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.FloatRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t FloatRules::ByteSizeLong(const MessageLite& base) {
  const FloatRules& this_ = static_cast<const FloatRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t FloatRules::ByteSizeLong() const {
  const FloatRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.FloatRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated float in = 6;
    {
      ::size_t data_size = ::size_t{4} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated float not_in = 7;
    {
      ::size_t data_size = ::size_t{4} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x0000001fu & cached_has_bits) * 5;
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void FloatRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<FloatRules*>(&to_msg);
  auto& from = static_cast<const FloatRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.FloatRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FloatRules::CopyFrom(const FloatRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.FloatRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void FloatRules::InternalSwap(FloatRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.ignore_empty_)
      + sizeof(FloatRules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata FloatRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DoubleRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DoubleRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_._has_bits_);
};

DoubleRules::DoubleRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DoubleRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.DoubleRules)
}
PROTOBUF_NDEBUG_INLINE DoubleRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::DoubleRules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

DoubleRules::DoubleRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DoubleRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DoubleRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DoubleRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.DoubleRules)
}
PROTOBUF_NDEBUG_INLINE DoubleRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void DoubleRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));
}
DoubleRules::~DoubleRules() {
  // @@protoc_insertion_point(destructor:validate.DoubleRules)
  SharedDtor(*this);
}
inline void DoubleRules::SharedDtor(MessageLite& self) {
  DoubleRules& this_ = static_cast<DoubleRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DoubleRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DoubleRules(arena);
}
constexpr auto DoubleRules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.in_) +
          decltype(DoubleRules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.not_in_) +
          decltype(DoubleRules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(DoubleRules), alignof(DoubleRules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&DoubleRules::PlacementNew_,
                                 sizeof(DoubleRules),
                                 alignof(DoubleRules));
  }
}
constexpr auto DoubleRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DoubleRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DoubleRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DoubleRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DoubleRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DoubleRules>(), &DoubleRules::ByteSizeLong,
              &DoubleRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_._cached_size_),
          false,
      },
      &DoubleRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DoubleRules_class_data_ =
        DoubleRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DoubleRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DoubleRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DoubleRules_class_data_.tc_table);
  return DoubleRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
DoubleRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    DoubleRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::DoubleRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ignore_empty = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DoubleRules, _impl_.ignore_empty_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.ignore_empty_)}},
    // optional double const = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.const__)}},
    // optional double lt = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 1, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.lt_)}},
    // optional double lte = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 2, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.lte_)}},
    // optional double gt = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 3, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.gt_)}},
    // optional double gte = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 4, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.gte_)}},
    // repeated double in = 6;
    {::_pbi::TcParser::FastF64R1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.in_)}},
    // repeated double not_in = 7;
    {::_pbi::TcParser::FastF64R1,
     {57, 63, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double const = 1;
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double lt = 2;
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double lte = 3;
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double gt = 4;
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double gte = 5;
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // repeated double in = 6;
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
    // repeated double not_in = 7;
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
    // optional bool ignore_empty = 8;
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void DoubleRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.DoubleRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DoubleRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DoubleRules& this_ = static_cast<const DoubleRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DoubleRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DoubleRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.DoubleRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional double const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this_._internal_const_(), target);
  }

  // optional double lt = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this_._internal_lt(), target);
  }

  // optional double lte = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this_._internal_lte(), target);
  }

  // optional double gt = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this_._internal_gt(), target);
  }

  // optional double gte = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this_._internal_gte(), target);
  }

  // repeated double in = 6;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this_._internal_in().Get(i), target);
  }

  // repeated double not_in = 7;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this_._internal_not_in().Get(i), target);
  }

  // optional bool ignore_empty = 8;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.DoubleRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DoubleRules::ByteSizeLong(const MessageLite& base) {
  const DoubleRules& this_ = static_cast<const DoubleRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DoubleRules::ByteSizeLong() const {
  const DoubleRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.DoubleRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated double in = 6;
    {
      ::size_t data_size = ::size_t{8} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated double not_in = 7;
    {
      ::size_t data_size = ::size_t{8} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x0000001fu & cached_has_bits) * 9;
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DoubleRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<DoubleRules*>(&to_msg);
  auto& from = static_cast<const DoubleRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.DoubleRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DoubleRules::CopyFrom(const DoubleRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.DoubleRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DoubleRules::InternalSwap(DoubleRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.ignore_empty_)
      + sizeof(DoubleRules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata DoubleRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Int32Rules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Int32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_._has_bits_);
};

Int32Rules::Int32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Int32Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.Int32Rules)
}
PROTOBUF_NDEBUG_INLINE Int32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::Int32Rules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

Int32Rules::Int32Rules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Int32Rules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Int32Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Int32Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.Int32Rules)
}
PROTOBUF_NDEBUG_INLINE Int32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void Int32Rules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));
}
Int32Rules::~Int32Rules() {
  // @@protoc_insertion_point(destructor:validate.Int32Rules)
  SharedDtor(*this);
}
inline void Int32Rules::SharedDtor(MessageLite& self) {
  Int32Rules& this_ = static_cast<Int32Rules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Int32Rules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Int32Rules(arena);
}
constexpr auto Int32Rules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.in_) +
          decltype(Int32Rules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.not_in_) +
          decltype(Int32Rules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(Int32Rules), alignof(Int32Rules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Int32Rules::PlacementNew_,
                                 sizeof(Int32Rules),
                                 alignof(Int32Rules));
  }
}
constexpr auto Int32Rules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Int32Rules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Int32Rules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Int32Rules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Int32Rules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Int32Rules>(), &Int32Rules::ByteSizeLong,
              &Int32Rules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_._cached_size_),
          false,
      },
      &Int32Rules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Int32Rules_class_data_ =
        Int32Rules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Int32Rules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Int32Rules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Int32Rules_class_data_.tc_table);
  return Int32Rules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
Int32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Int32Rules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::Int32Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ignore_empty = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Int32Rules, _impl_.ignore_empty_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.ignore_empty_)}},
    // optional int32 const = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Int32Rules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.const__)}},
    // optional int32 lt = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Int32Rules, _impl_.lt_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.lt_)}},
    // optional int32 lte = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Int32Rules, _impl_.lte_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.lte_)}},
    // optional int32 gt = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Int32Rules, _impl_.gt_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.gt_)}},
    // optional int32 gte = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Int32Rules, _impl_.gte_), 4>(),
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.gte_)}},
    // repeated int32 in = 6;
    {::_pbi::TcParser::FastV32R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.in_)}},
    // repeated int32 not_in = 7;
    {::_pbi::TcParser::FastV32R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 const = 1;
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 lt = 2;
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 lte = 3;
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 gt = 4;
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 gte = 5;
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // repeated int32 in = 6;
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
    // repeated int32 not_in = 7;
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
    // optional bool ignore_empty = 8;
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Int32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Int32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Int32Rules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Int32Rules& this_ = static_cast<const Int32Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Int32Rules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Int32Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.Int32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional int32 const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
            stream, this_._internal_const_(), target);
  }

  // optional int32 lt = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
            stream, this_._internal_lt(), target);
  }

  // optional int32 lte = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
            stream, this_._internal_lte(), target);
  }

  // optional int32 gt = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<4>(
            stream, this_._internal_gt(), target);
  }

  // optional int32 gte = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<5>(
            stream, this_._internal_gte(), target);
  }

  // repeated int32 in = 6;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this_._internal_in().Get(i), target);
  }

  // repeated int32 not_in = 7;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this_._internal_not_in().Get(i), target);
  }

  // optional bool ignore_empty = 8;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Int32Rules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Int32Rules::ByteSizeLong(const MessageLite& base) {
  const Int32Rules& this_ = static_cast<const Int32Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Int32Rules::ByteSizeLong() const {
  const Int32Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.Int32Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated int32 in = 6;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
          this_._internal_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated int32 not_in = 7;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
          this_._internal_not_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000001fu) != 0) {
    // optional int32 const = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_const_());
    }
    // optional int32 lt = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_lt());
    }
    // optional int32 lte = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_lte());
    }
    // optional int32 gt = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_gt());
    }
    // optional int32 gte = 5;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_gte());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Int32Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Int32Rules*>(&to_msg);
  auto& from = static_cast<const Int32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.Int32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Int32Rules::CopyFrom(const Int32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Int32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Int32Rules::InternalSwap(Int32Rules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.ignore_empty_)
      + sizeof(Int32Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata Int32Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Int64Rules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Int64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_._has_bits_);
};

Int64Rules::Int64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Int64Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.Int64Rules)
}
PROTOBUF_NDEBUG_INLINE Int64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::Int64Rules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

Int64Rules::Int64Rules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Int64Rules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Int64Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Int64Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.Int64Rules)
}
PROTOBUF_NDEBUG_INLINE Int64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void Int64Rules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));
}
Int64Rules::~Int64Rules() {
  // @@protoc_insertion_point(destructor:validate.Int64Rules)
  SharedDtor(*this);
}
inline void Int64Rules::SharedDtor(MessageLite& self) {
  Int64Rules& this_ = static_cast<Int64Rules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Int64Rules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Int64Rules(arena);
}
constexpr auto Int64Rules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.in_) +
          decltype(Int64Rules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.not_in_) +
          decltype(Int64Rules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(Int64Rules), alignof(Int64Rules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Int64Rules::PlacementNew_,
                                 sizeof(Int64Rules),
                                 alignof(Int64Rules));
  }
}
constexpr auto Int64Rules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Int64Rules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Int64Rules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Int64Rules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Int64Rules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Int64Rules>(), &Int64Rules::ByteSizeLong,
              &Int64Rules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_._cached_size_),
          false,
      },
      &Int64Rules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Int64Rules_class_data_ =
        Int64Rules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Int64Rules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Int64Rules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Int64Rules_class_data_.tc_table);
  return Int64Rules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
Int64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Int64Rules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::Int64Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ignore_empty = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Int64Rules, _impl_.ignore_empty_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.ignore_empty_)}},
    // optional int64 const = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Int64Rules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.const__)}},
    // optional int64 lt = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Int64Rules, _impl_.lt_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.lt_)}},
    // optional int64 lte = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Int64Rules, _impl_.lte_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.lte_)}},
    // optional int64 gt = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Int64Rules, _impl_.gt_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.gt_)}},
    // optional int64 gte = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Int64Rules, _impl_.gte_), 4>(),
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.gte_)}},
    // repeated int64 in = 6;
    {::_pbi::TcParser::FastV64R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.in_)}},
    // repeated int64 not_in = 7;
    {::_pbi::TcParser::FastV64R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 const = 1;
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int64 lt = 2;
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int64 lte = 3;
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int64 gt = 4;
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int64 gte = 5;
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // repeated int64 in = 6;
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt64)},
    // repeated int64 not_in = 7;
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt64)},
    // optional bool ignore_empty = 8;
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Int64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Int64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Int64Rules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Int64Rules& this_ = static_cast<const Int64Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Int64Rules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Int64Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.Int64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional int64 const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<1>(
            stream, this_._internal_const_(), target);
  }

  // optional int64 lt = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<2>(
            stream, this_._internal_lt(), target);
  }

  // optional int64 lte = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<3>(
            stream, this_._internal_lte(), target);
  }

  // optional int64 gt = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<4>(
            stream, this_._internal_gt(), target);
  }

  // optional int64 gte = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<5>(
            stream, this_._internal_gte(), target);
  }

  // repeated int64 in = 6;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this_._internal_in().Get(i), target);
  }

  // repeated int64 not_in = 7;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        7, this_._internal_not_in().Get(i), target);
  }

  // optional bool ignore_empty = 8;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Int64Rules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Int64Rules::ByteSizeLong(const MessageLite& base) {
  const Int64Rules& this_ = static_cast<const Int64Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Int64Rules::ByteSizeLong() const {
  const Int64Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.Int64Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated int64 in = 6;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
          this_._internal_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated int64 not_in = 7;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
          this_._internal_not_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000001fu) != 0) {
    // optional int64 const = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_const_());
    }
    // optional int64 lt = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_lt());
    }
    // optional int64 lte = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_lte());
    }
    // optional int64 gt = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_gt());
    }
    // optional int64 gte = 5;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this_._internal_gte());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Int64Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Int64Rules*>(&to_msg);
  auto& from = static_cast<const Int64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.Int64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Int64Rules::CopyFrom(const Int64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Int64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Int64Rules::InternalSwap(Int64Rules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.ignore_empty_)
      + sizeof(Int64Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata Int64Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UInt32Rules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UInt32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_._has_bits_);
};

UInt32Rules::UInt32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UInt32Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.UInt32Rules)
}
PROTOBUF_NDEBUG_INLINE UInt32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::UInt32Rules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

UInt32Rules::UInt32Rules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UInt32Rules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UInt32Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UInt32Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.UInt32Rules)
}
PROTOBUF_NDEBUG_INLINE UInt32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void UInt32Rules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));
}
UInt32Rules::~UInt32Rules() {
  // @@protoc_insertion_point(destructor:validate.UInt32Rules)
  SharedDtor(*this);
}
inline void UInt32Rules::SharedDtor(MessageLite& self) {
  UInt32Rules& this_ = static_cast<UInt32Rules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UInt32Rules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UInt32Rules(arena);
}
constexpr auto UInt32Rules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.in_) +
          decltype(UInt32Rules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.not_in_) +
          decltype(UInt32Rules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(UInt32Rules), alignof(UInt32Rules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&UInt32Rules::PlacementNew_,
                                 sizeof(UInt32Rules),
                                 alignof(UInt32Rules));
  }
}
constexpr auto UInt32Rules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UInt32Rules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &UInt32Rules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UInt32Rules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UInt32Rules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UInt32Rules>(), &UInt32Rules::ByteSizeLong,
              &UInt32Rules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_._cached_size_),
          false,
      },
      &UInt32Rules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UInt32Rules_class_data_ =
        UInt32Rules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UInt32Rules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UInt32Rules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UInt32Rules_class_data_.tc_table);
  return UInt32Rules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
UInt32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    UInt32Rules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::UInt32Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ignore_empty = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UInt32Rules, _impl_.ignore_empty_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.ignore_empty_)}},
    // optional uint32 const = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UInt32Rules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.const__)}},
    // optional uint32 lt = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UInt32Rules, _impl_.lt_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.lt_)}},
    // optional uint32 lte = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UInt32Rules, _impl_.lte_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.lte_)}},
    // optional uint32 gt = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UInt32Rules, _impl_.gt_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.gt_)}},
    // optional uint32 gte = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UInt32Rules, _impl_.gte_), 4>(),
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.gte_)}},
    // repeated uint32 in = 6;
    {::_pbi::TcParser::FastV32R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.in_)}},
    // repeated uint32 not_in = 7;
    {::_pbi::TcParser::FastV32R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 const = 1;
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 lt = 2;
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 lte = 3;
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 gt = 4;
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 gte = 5;
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // repeated uint32 in = 6;
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 not_in = 7;
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // optional bool ignore_empty = 8;
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void UInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.UInt32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UInt32Rules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UInt32Rules& this_ = static_cast<const UInt32Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UInt32Rules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UInt32Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.UInt32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_const_(), target);
  }

  // optional uint32 lt = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_lt(), target);
  }

  // optional uint32 lte = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this_._internal_lte(), target);
  }

  // optional uint32 gt = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_gt(), target);
  }

  // optional uint32 gte = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this_._internal_gte(), target);
  }

  // repeated uint32 in = 6;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this_._internal_in().Get(i), target);
  }

  // repeated uint32 not_in = 7;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this_._internal_not_in().Get(i), target);
  }

  // optional bool ignore_empty = 8;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.UInt32Rules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UInt32Rules::ByteSizeLong(const MessageLite& base) {
  const UInt32Rules& this_ = static_cast<const UInt32Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UInt32Rules::ByteSizeLong() const {
  const UInt32Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.UInt32Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated uint32 in = 6;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 not_in = 7;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_not_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000001fu) != 0) {
    // optional uint32 const = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_const_());
    }
    // optional uint32 lt = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_lt());
    }
    // optional uint32 lte = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_lte());
    }
    // optional uint32 gt = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_gt());
    }
    // optional uint32 gte = 5;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_gte());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UInt32Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UInt32Rules*>(&to_msg);
  auto& from = static_cast<const UInt32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.UInt32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UInt32Rules::CopyFrom(const UInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.UInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UInt32Rules::InternalSwap(UInt32Rules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.ignore_empty_)
      + sizeof(UInt32Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata UInt32Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UInt64Rules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UInt64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_._has_bits_);
};

UInt64Rules::UInt64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UInt64Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.UInt64Rules)
}
PROTOBUF_NDEBUG_INLINE UInt64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::UInt64Rules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

UInt64Rules::UInt64Rules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UInt64Rules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UInt64Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UInt64Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.UInt64Rules)
}
PROTOBUF_NDEBUG_INLINE UInt64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void UInt64Rules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));
}
UInt64Rules::~UInt64Rules() {
  // @@protoc_insertion_point(destructor:validate.UInt64Rules)
  SharedDtor(*this);
}
inline void UInt64Rules::SharedDtor(MessageLite& self) {
  UInt64Rules& this_ = static_cast<UInt64Rules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UInt64Rules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UInt64Rules(arena);
}
constexpr auto UInt64Rules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.in_) +
          decltype(UInt64Rules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.not_in_) +
          decltype(UInt64Rules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(UInt64Rules), alignof(UInt64Rules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&UInt64Rules::PlacementNew_,
                                 sizeof(UInt64Rules),
                                 alignof(UInt64Rules));
  }
}
constexpr auto UInt64Rules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UInt64Rules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &UInt64Rules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UInt64Rules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UInt64Rules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UInt64Rules>(), &UInt64Rules::ByteSizeLong,
              &UInt64Rules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_._cached_size_),
          false,
      },
      &UInt64Rules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UInt64Rules_class_data_ =
        UInt64Rules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UInt64Rules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UInt64Rules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UInt64Rules_class_data_.tc_table);
  return UInt64Rules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
UInt64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    UInt64Rules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::UInt64Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ignore_empty = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UInt64Rules, _impl_.ignore_empty_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.ignore_empty_)}},
    // optional uint64 const = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(UInt64Rules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.const__)}},
    // optional uint64 lt = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(UInt64Rules, _impl_.lt_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.lt_)}},
    // optional uint64 lte = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(UInt64Rules, _impl_.lte_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.lte_)}},
    // optional uint64 gt = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(UInt64Rules, _impl_.gt_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.gt_)}},
    // optional uint64 gte = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(UInt64Rules, _impl_.gte_), 4>(),
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.gte_)}},
    // repeated uint64 in = 6;
    {::_pbi::TcParser::FastV64R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.in_)}},
    // repeated uint64 not_in = 7;
    {::_pbi::TcParser::FastV64R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint64 const = 1;
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 lt = 2;
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 lte = 3;
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 gt = 4;
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 gte = 5;
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // repeated uint64 in = 6;
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt64)},
    // repeated uint64 not_in = 7;
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt64)},
    // optional bool ignore_empty = 8;
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void UInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.UInt64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UInt64Rules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UInt64Rules& this_ = static_cast<const UInt64Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UInt64Rules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UInt64Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.UInt64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint64 const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this_._internal_const_(), target);
  }

  // optional uint64 lt = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this_._internal_lt(), target);
  }

  // optional uint64 lte = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this_._internal_lte(), target);
  }

  // optional uint64 gt = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this_._internal_gt(), target);
  }

  // optional uint64 gte = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this_._internal_gte(), target);
  }

  // repeated uint64 in = 6;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this_._internal_in().Get(i), target);
  }

  // repeated uint64 not_in = 7;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this_._internal_not_in().Get(i), target);
  }

  // optional bool ignore_empty = 8;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.UInt64Rules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UInt64Rules::ByteSizeLong(const MessageLite& base) {
  const UInt64Rules& this_ = static_cast<const UInt64Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UInt64Rules::ByteSizeLong() const {
  const UInt64Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.UInt64Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated uint64 in = 6;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt64Size(
          this_._internal_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated uint64 not_in = 7;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt64Size(
          this_._internal_not_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000001fu) != 0) {
    // optional uint64 const = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_const_());
    }
    // optional uint64 lt = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_lt());
    }
    // optional uint64 lte = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_lte());
    }
    // optional uint64 gt = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_gt());
    }
    // optional uint64 gte = 5;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_gte());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UInt64Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UInt64Rules*>(&to_msg);
  auto& from = static_cast<const UInt64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.UInt64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UInt64Rules::CopyFrom(const UInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.UInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UInt64Rules::InternalSwap(UInt64Rules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.ignore_empty_)
      + sizeof(UInt64Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata UInt64Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SInt32Rules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<SInt32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_._has_bits_);
};

SInt32Rules::SInt32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SInt32Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.SInt32Rules)
}
PROTOBUF_NDEBUG_INLINE SInt32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::SInt32Rules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

SInt32Rules::SInt32Rules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const SInt32Rules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SInt32Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SInt32Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.SInt32Rules)
}
PROTOBUF_NDEBUG_INLINE SInt32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void SInt32Rules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));
}
SInt32Rules::~SInt32Rules() {
  // @@protoc_insertion_point(destructor:validate.SInt32Rules)
  SharedDtor(*this);
}
inline void SInt32Rules::SharedDtor(MessageLite& self) {
  SInt32Rules& this_ = static_cast<SInt32Rules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SInt32Rules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SInt32Rules(arena);
}
constexpr auto SInt32Rules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.in_) +
          decltype(SInt32Rules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.not_in_) +
          decltype(SInt32Rules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(SInt32Rules), alignof(SInt32Rules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SInt32Rules::PlacementNew_,
                                 sizeof(SInt32Rules),
                                 alignof(SInt32Rules));
  }
}
constexpr auto SInt32Rules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SInt32Rules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SInt32Rules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SInt32Rules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SInt32Rules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SInt32Rules>(), &SInt32Rules::ByteSizeLong,
              &SInt32Rules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_._cached_size_),
          false,
      },
      &SInt32Rules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SInt32Rules_class_data_ =
        SInt32Rules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SInt32Rules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SInt32Rules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SInt32Rules_class_data_.tc_table);
  return SInt32Rules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
SInt32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SInt32Rules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::SInt32Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ignore_empty = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SInt32Rules, _impl_.ignore_empty_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.ignore_empty_)}},
    // optional sint32 const = 1;
    {::_pbi::TcParser::FastZ32S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.const__)}},
    // optional sint32 lt = 2;
    {::_pbi::TcParser::FastZ32S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.lt_)}},
    // optional sint32 lte = 3;
    {::_pbi::TcParser::FastZ32S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.lte_)}},
    // optional sint32 gt = 4;
    {::_pbi::TcParser::FastZ32S1,
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.gt_)}},
    // optional sint32 gte = 5;
    {::_pbi::TcParser::FastZ32S1,
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.gte_)}},
    // repeated sint32 in = 6;
    {::_pbi::TcParser::FastZ32R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.in_)}},
    // repeated sint32 not_in = 7;
    {::_pbi::TcParser::FastZ32R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sint32 const = 1;
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt32)},
    // optional sint32 lt = 2;
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt32)},
    // optional sint32 lte = 3;
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt32)},
    // optional sint32 gt = 4;
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt32)},
    // optional sint32 gte = 5;
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt32)},
    // repeated sint32 in = 6;
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSInt32)},
    // repeated sint32 not_in = 7;
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSInt32)},
    // optional bool ignore_empty = 8;
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void SInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SInt32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SInt32Rules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SInt32Rules& this_ = static_cast<const SInt32Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SInt32Rules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SInt32Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.SInt32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional sint32 const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        1, this_._internal_const_(), target);
  }

  // optional sint32 lt = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        2, this_._internal_lt(), target);
  }

  // optional sint32 lte = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        3, this_._internal_lte(), target);
  }

  // optional sint32 gt = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        4, this_._internal_gt(), target);
  }

  // optional sint32 gte = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        5, this_._internal_gte(), target);
  }

  // repeated sint32 in = 6;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        6, this_._internal_in().Get(i), target);
  }

  // repeated sint32 not_in = 7;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        7, this_._internal_not_in().Get(i), target);
  }

  // optional bool ignore_empty = 8;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SInt32Rules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SInt32Rules::ByteSizeLong(const MessageLite& base) {
  const SInt32Rules& this_ = static_cast<const SInt32Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SInt32Rules::ByteSizeLong() const {
  const SInt32Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.SInt32Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated sint32 in = 6;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::SInt32Size(
          this_._internal_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated sint32 not_in = 7;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::SInt32Size(
          this_._internal_not_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000001fu) != 0) {
    // optional sint32 const = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this_._internal_const_());
    }
    // optional sint32 lt = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this_._internal_lt());
    }
    // optional sint32 lte = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this_._internal_lte());
    }
    // optional sint32 gt = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this_._internal_gt());
    }
    // optional sint32 gte = 5;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this_._internal_gte());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SInt32Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SInt32Rules*>(&to_msg);
  auto& from = static_cast<const SInt32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.SInt32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SInt32Rules::CopyFrom(const SInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SInt32Rules::InternalSwap(SInt32Rules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.ignore_empty_)
      + sizeof(SInt32Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata SInt32Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SInt64Rules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<SInt64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_._has_bits_);
};

SInt64Rules::SInt64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SInt64Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.SInt64Rules)
}
PROTOBUF_NDEBUG_INLINE SInt64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::SInt64Rules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

SInt64Rules::SInt64Rules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const SInt64Rules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SInt64Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SInt64Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.SInt64Rules)
}
PROTOBUF_NDEBUG_INLINE SInt64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void SInt64Rules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));
}
SInt64Rules::~SInt64Rules() {
  // @@protoc_insertion_point(destructor:validate.SInt64Rules)
  SharedDtor(*this);
}
inline void SInt64Rules::SharedDtor(MessageLite& self) {
  SInt64Rules& this_ = static_cast<SInt64Rules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SInt64Rules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SInt64Rules(arena);
}
constexpr auto SInt64Rules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.in_) +
          decltype(SInt64Rules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.not_in_) +
          decltype(SInt64Rules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(SInt64Rules), alignof(SInt64Rules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SInt64Rules::PlacementNew_,
                                 sizeof(SInt64Rules),
                                 alignof(SInt64Rules));
  }
}
constexpr auto SInt64Rules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SInt64Rules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SInt64Rules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SInt64Rules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SInt64Rules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SInt64Rules>(), &SInt64Rules::ByteSizeLong,
              &SInt64Rules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_._cached_size_),
          false,
      },
      &SInt64Rules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SInt64Rules_class_data_ =
        SInt64Rules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SInt64Rules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SInt64Rules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SInt64Rules_class_data_.tc_table);
  return SInt64Rules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
SInt64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SInt64Rules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::SInt64Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ignore_empty = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SInt64Rules, _impl_.ignore_empty_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.ignore_empty_)}},
    // optional sint64 const = 1;
    {::_pbi::TcParser::FastZ64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.const__)}},
    // optional sint64 lt = 2;
    {::_pbi::TcParser::FastZ64S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.lt_)}},
    // optional sint64 lte = 3;
    {::_pbi::TcParser::FastZ64S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.lte_)}},
    // optional sint64 gt = 4;
    {::_pbi::TcParser::FastZ64S1,
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.gt_)}},
    // optional sint64 gte = 5;
    {::_pbi::TcParser::FastZ64S1,
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.gte_)}},
    // repeated sint64 in = 6;
    {::_pbi::TcParser::FastZ64R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.in_)}},
    // repeated sint64 not_in = 7;
    {::_pbi::TcParser::FastZ64R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sint64 const = 1;
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt64)},
    // optional sint64 lt = 2;
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt64)},
    // optional sint64 lte = 3;
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt64)},
    // optional sint64 gt = 4;
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt64)},
    // optional sint64 gte = 5;
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt64)},
    // repeated sint64 in = 6;
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSInt64)},
    // repeated sint64 not_in = 7;
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSInt64)},
    // optional bool ignore_empty = 8;
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void SInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SInt64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SInt64Rules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SInt64Rules& this_ = static_cast<const SInt64Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SInt64Rules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SInt64Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.SInt64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional sint64 const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        1, this_._internal_const_(), target);
  }

  // optional sint64 lt = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        2, this_._internal_lt(), target);
  }

  // optional sint64 lte = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        3, this_._internal_lte(), target);
  }

  // optional sint64 gt = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        4, this_._internal_gt(), target);
  }

  // optional sint64 gte = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        5, this_._internal_gte(), target);
  }

  // repeated sint64 in = 6;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        6, this_._internal_in().Get(i), target);
  }

  // repeated sint64 not_in = 7;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        7, this_._internal_not_in().Get(i), target);
  }

  // optional bool ignore_empty = 8;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SInt64Rules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SInt64Rules::ByteSizeLong(const MessageLite& base) {
  const SInt64Rules& this_ = static_cast<const SInt64Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SInt64Rules::ByteSizeLong() const {
  const SInt64Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.SInt64Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated sint64 in = 6;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::SInt64Size(
          this_._internal_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated sint64 not_in = 7;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::SInt64Size(
          this_._internal_not_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000001fu) != 0) {
    // optional sint64 const = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this_._internal_const_());
    }
    // optional sint64 lt = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this_._internal_lt());
    }
    // optional sint64 lte = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this_._internal_lte());
    }
    // optional sint64 gt = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this_._internal_gt());
    }
    // optional sint64 gte = 5;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this_._internal_gte());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SInt64Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SInt64Rules*>(&to_msg);
  auto& from = static_cast<const SInt64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.SInt64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SInt64Rules::CopyFrom(const SInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SInt64Rules::InternalSwap(SInt64Rules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.ignore_empty_)
      + sizeof(SInt64Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata SInt64Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Fixed32Rules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Fixed32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_._has_bits_);
};

Fixed32Rules::Fixed32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Fixed32Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.Fixed32Rules)
}
PROTOBUF_NDEBUG_INLINE Fixed32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::Fixed32Rules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

Fixed32Rules::Fixed32Rules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Fixed32Rules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Fixed32Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Fixed32Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.Fixed32Rules)
}
PROTOBUF_NDEBUG_INLINE Fixed32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void Fixed32Rules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));
}
Fixed32Rules::~Fixed32Rules() {
  // @@protoc_insertion_point(destructor:validate.Fixed32Rules)
  SharedDtor(*this);
}
inline void Fixed32Rules::SharedDtor(MessageLite& self) {
  Fixed32Rules& this_ = static_cast<Fixed32Rules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Fixed32Rules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Fixed32Rules(arena);
}
constexpr auto Fixed32Rules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.in_) +
          decltype(Fixed32Rules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.not_in_) +
          decltype(Fixed32Rules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(Fixed32Rules), alignof(Fixed32Rules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Fixed32Rules::PlacementNew_,
                                 sizeof(Fixed32Rules),
                                 alignof(Fixed32Rules));
  }
}
constexpr auto Fixed32Rules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Fixed32Rules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Fixed32Rules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Fixed32Rules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Fixed32Rules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Fixed32Rules>(), &Fixed32Rules::ByteSizeLong,
              &Fixed32Rules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_._cached_size_),
          false,
      },
      &Fixed32Rules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Fixed32Rules_class_data_ =
        Fixed32Rules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Fixed32Rules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Fixed32Rules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Fixed32Rules_class_data_.tc_table);
  return Fixed32Rules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
Fixed32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Fixed32Rules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::Fixed32Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ignore_empty = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Fixed32Rules, _impl_.ignore_empty_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.ignore_empty_)}},
    // optional fixed32 const = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.const__)}},
    // optional fixed32 lt = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.lt_)}},
    // optional fixed32 lte = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.lte_)}},
    // optional fixed32 gt = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.gt_)}},
    // optional fixed32 gte = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.gte_)}},
    // repeated fixed32 in = 6;
    {::_pbi::TcParser::FastF32R1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.in_)}},
    // repeated fixed32 not_in = 7;
    {::_pbi::TcParser::FastF32R1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional fixed32 const = 1;
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional fixed32 lt = 2;
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional fixed32 lte = 3;
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional fixed32 gt = 4;
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional fixed32 gte = 5;
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // repeated fixed32 in = 6;
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFixed32)},
    // repeated fixed32 not_in = 7;
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFixed32)},
    // optional bool ignore_empty = 8;
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Fixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Fixed32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Fixed32Rules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Fixed32Rules& this_ = static_cast<const Fixed32Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Fixed32Rules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Fixed32Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.Fixed32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional fixed32 const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        1, this_._internal_const_(), target);
  }

  // optional fixed32 lt = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        2, this_._internal_lt(), target);
  }

  // optional fixed32 lte = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        3, this_._internal_lte(), target);
  }

  // optional fixed32 gt = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        4, this_._internal_gt(), target);
  }

  // optional fixed32 gte = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        5, this_._internal_gte(), target);
  }

  // repeated fixed32 in = 6;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        6, this_._internal_in().Get(i), target);
  }

  // repeated fixed32 not_in = 7;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        7, this_._internal_not_in().Get(i), target);
  }

  // optional bool ignore_empty = 8;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Fixed32Rules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Fixed32Rules::ByteSizeLong(const MessageLite& base) {
  const Fixed32Rules& this_ = static_cast<const Fixed32Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Fixed32Rules::ByteSizeLong() const {
  const Fixed32Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.Fixed32Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated fixed32 in = 6;
    {
      ::size_t data_size = ::size_t{4} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated fixed32 not_in = 7;
    {
      ::size_t data_size = ::size_t{4} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x0000001fu & cached_has_bits) * 5;
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Fixed32Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Fixed32Rules*>(&to_msg);
  auto& from = static_cast<const Fixed32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.Fixed32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Fixed32Rules::CopyFrom(const Fixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Fixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Fixed32Rules::InternalSwap(Fixed32Rules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.ignore_empty_)
      + sizeof(Fixed32Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata Fixed32Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Fixed64Rules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Fixed64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_._has_bits_);
};

Fixed64Rules::Fixed64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Fixed64Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.Fixed64Rules)
}
PROTOBUF_NDEBUG_INLINE Fixed64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::Fixed64Rules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

Fixed64Rules::Fixed64Rules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Fixed64Rules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Fixed64Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Fixed64Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.Fixed64Rules)
}
PROTOBUF_NDEBUG_INLINE Fixed64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void Fixed64Rules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));
}
Fixed64Rules::~Fixed64Rules() {
  // @@protoc_insertion_point(destructor:validate.Fixed64Rules)
  SharedDtor(*this);
}
inline void Fixed64Rules::SharedDtor(MessageLite& self) {
  Fixed64Rules& this_ = static_cast<Fixed64Rules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Fixed64Rules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Fixed64Rules(arena);
}
constexpr auto Fixed64Rules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.in_) +
          decltype(Fixed64Rules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.not_in_) +
          decltype(Fixed64Rules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(Fixed64Rules), alignof(Fixed64Rules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Fixed64Rules::PlacementNew_,
                                 sizeof(Fixed64Rules),
                                 alignof(Fixed64Rules));
  }
}
constexpr auto Fixed64Rules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Fixed64Rules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Fixed64Rules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Fixed64Rules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Fixed64Rules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Fixed64Rules>(), &Fixed64Rules::ByteSizeLong,
              &Fixed64Rules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_._cached_size_),
          false,
      },
      &Fixed64Rules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Fixed64Rules_class_data_ =
        Fixed64Rules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Fixed64Rules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Fixed64Rules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Fixed64Rules_class_data_.tc_table);
  return Fixed64Rules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
Fixed64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Fixed64Rules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::Fixed64Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ignore_empty = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Fixed64Rules, _impl_.ignore_empty_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.ignore_empty_)}},
    // optional fixed64 const = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.const__)}},
    // optional fixed64 lt = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 1, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.lt_)}},
    // optional fixed64 lte = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 2, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.lte_)}},
    // optional fixed64 gt = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 3, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.gt_)}},
    // optional fixed64 gte = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 4, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.gte_)}},
    // repeated fixed64 in = 6;
    {::_pbi::TcParser::FastF64R1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.in_)}},
    // repeated fixed64 not_in = 7;
    {::_pbi::TcParser::FastF64R1,
     {57, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional fixed64 const = 1;
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // optional fixed64 lt = 2;
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // optional fixed64 lte = 3;
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // optional fixed64 gt = 4;
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // optional fixed64 gte = 5;
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // repeated fixed64 in = 6;
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFixed64)},
    // repeated fixed64 not_in = 7;
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFixed64)},
    // optional bool ignore_empty = 8;
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Fixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.Fixed64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Fixed64Rules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Fixed64Rules& this_ = static_cast<const Fixed64Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Fixed64Rules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Fixed64Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.Fixed64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional fixed64 const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        1, this_._internal_const_(), target);
  }

  // optional fixed64 lt = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        2, this_._internal_lt(), target);
  }

  // optional fixed64 lte = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        3, this_._internal_lte(), target);
  }

  // optional fixed64 gt = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        4, this_._internal_gt(), target);
  }

  // optional fixed64 gte = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        5, this_._internal_gte(), target);
  }

  // repeated fixed64 in = 6;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        6, this_._internal_in().Get(i), target);
  }

  // repeated fixed64 not_in = 7;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        7, this_._internal_not_in().Get(i), target);
  }

  // optional bool ignore_empty = 8;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.Fixed64Rules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Fixed64Rules::ByteSizeLong(const MessageLite& base) {
  const Fixed64Rules& this_ = static_cast<const Fixed64Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Fixed64Rules::ByteSizeLong() const {
  const Fixed64Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.Fixed64Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated fixed64 in = 6;
    {
      ::size_t data_size = ::size_t{8} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated fixed64 not_in = 7;
    {
      ::size_t data_size = ::size_t{8} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x0000001fu & cached_has_bits) * 9;
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Fixed64Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Fixed64Rules*>(&to_msg);
  auto& from = static_cast<const Fixed64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.Fixed64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Fixed64Rules::CopyFrom(const Fixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.Fixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Fixed64Rules::InternalSwap(Fixed64Rules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.ignore_empty_)
      + sizeof(Fixed64Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata Fixed64Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SFixed32Rules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<SFixed32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_._has_bits_);
};

SFixed32Rules::SFixed32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SFixed32Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.SFixed32Rules)
}
PROTOBUF_NDEBUG_INLINE SFixed32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::SFixed32Rules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

SFixed32Rules::SFixed32Rules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const SFixed32Rules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SFixed32Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SFixed32Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.SFixed32Rules)
}
PROTOBUF_NDEBUG_INLINE SFixed32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void SFixed32Rules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));
}
SFixed32Rules::~SFixed32Rules() {
  // @@protoc_insertion_point(destructor:validate.SFixed32Rules)
  SharedDtor(*this);
}
inline void SFixed32Rules::SharedDtor(MessageLite& self) {
  SFixed32Rules& this_ = static_cast<SFixed32Rules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SFixed32Rules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SFixed32Rules(arena);
}
constexpr auto SFixed32Rules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.in_) +
          decltype(SFixed32Rules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.not_in_) +
          decltype(SFixed32Rules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(SFixed32Rules), alignof(SFixed32Rules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SFixed32Rules::PlacementNew_,
                                 sizeof(SFixed32Rules),
                                 alignof(SFixed32Rules));
  }
}
constexpr auto SFixed32Rules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SFixed32Rules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SFixed32Rules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SFixed32Rules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SFixed32Rules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SFixed32Rules>(), &SFixed32Rules::ByteSizeLong,
              &SFixed32Rules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_._cached_size_),
          false,
      },
      &SFixed32Rules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SFixed32Rules_class_data_ =
        SFixed32Rules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SFixed32Rules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SFixed32Rules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SFixed32Rules_class_data_.tc_table);
  return SFixed32Rules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
SFixed32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SFixed32Rules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::SFixed32Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ignore_empty = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SFixed32Rules, _impl_.ignore_empty_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.ignore_empty_)}},
    // optional sfixed32 const = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.const__)}},
    // optional sfixed32 lt = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.lt_)}},
    // optional sfixed32 lte = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.lte_)}},
    // optional sfixed32 gt = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.gt_)}},
    // optional sfixed32 gte = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.gte_)}},
    // repeated sfixed32 in = 6;
    {::_pbi::TcParser::FastF32R1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.in_)}},
    // repeated sfixed32 not_in = 7;
    {::_pbi::TcParser::FastF32R1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sfixed32 const = 1;
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed32)},
    // optional sfixed32 lt = 2;
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed32)},
    // optional sfixed32 lte = 3;
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed32)},
    // optional sfixed32 gt = 4;
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed32)},
    // optional sfixed32 gte = 5;
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed32)},
    // repeated sfixed32 in = 6;
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSFixed32)},
    // repeated sfixed32 not_in = 7;
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSFixed32)},
    // optional bool ignore_empty = 8;
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void SFixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SFixed32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SFixed32Rules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SFixed32Rules& this_ = static_cast<const SFixed32Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SFixed32Rules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SFixed32Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.SFixed32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional sfixed32 const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        1, this_._internal_const_(), target);
  }

  // optional sfixed32 lt = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        2, this_._internal_lt(), target);
  }

  // optional sfixed32 lte = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        3, this_._internal_lte(), target);
  }

  // optional sfixed32 gt = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        4, this_._internal_gt(), target);
  }

  // optional sfixed32 gte = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        5, this_._internal_gte(), target);
  }

  // repeated sfixed32 in = 6;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        6, this_._internal_in().Get(i), target);
  }

  // repeated sfixed32 not_in = 7;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        7, this_._internal_not_in().Get(i), target);
  }

  // optional bool ignore_empty = 8;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SFixed32Rules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SFixed32Rules::ByteSizeLong(const MessageLite& base) {
  const SFixed32Rules& this_ = static_cast<const SFixed32Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SFixed32Rules::ByteSizeLong() const {
  const SFixed32Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.SFixed32Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated sfixed32 in = 6;
    {
      ::size_t data_size = ::size_t{4} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated sfixed32 not_in = 7;
    {
      ::size_t data_size = ::size_t{4} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x0000001fu & cached_has_bits) * 5;
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SFixed32Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SFixed32Rules*>(&to_msg);
  auto& from = static_cast<const SFixed32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.SFixed32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SFixed32Rules::CopyFrom(const SFixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SFixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SFixed32Rules::InternalSwap(SFixed32Rules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.ignore_empty_)
      + sizeof(SFixed32Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata SFixed32Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SFixed64Rules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<SFixed64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_._has_bits_);
};

SFixed64Rules::SFixed64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SFixed64Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.SFixed64Rules)
}
PROTOBUF_NDEBUG_INLINE SFixed64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::SFixed64Rules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

SFixed64Rules::SFixed64Rules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const SFixed64Rules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SFixed64Rules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SFixed64Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.SFixed64Rules)
}
PROTOBUF_NDEBUG_INLINE SFixed64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void SFixed64Rules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::ignore_empty_));
}
SFixed64Rules::~SFixed64Rules() {
  // @@protoc_insertion_point(destructor:validate.SFixed64Rules)
  SharedDtor(*this);
}
inline void SFixed64Rules::SharedDtor(MessageLite& self) {
  SFixed64Rules& this_ = static_cast<SFixed64Rules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SFixed64Rules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SFixed64Rules(arena);
}
constexpr auto SFixed64Rules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.in_) +
          decltype(SFixed64Rules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.not_in_) +
          decltype(SFixed64Rules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(SFixed64Rules), alignof(SFixed64Rules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SFixed64Rules::PlacementNew_,
                                 sizeof(SFixed64Rules),
                                 alignof(SFixed64Rules));
  }
}
constexpr auto SFixed64Rules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SFixed64Rules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SFixed64Rules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SFixed64Rules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SFixed64Rules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SFixed64Rules>(), &SFixed64Rules::ByteSizeLong,
              &SFixed64Rules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_._cached_size_),
          false,
      },
      &SFixed64Rules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SFixed64Rules_class_data_ =
        SFixed64Rules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SFixed64Rules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SFixed64Rules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SFixed64Rules_class_data_.tc_table);
  return SFixed64Rules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 0, 2>
SFixed64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SFixed64Rules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::SFixed64Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ignore_empty = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SFixed64Rules, _impl_.ignore_empty_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.ignore_empty_)}},
    // optional sfixed64 const = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.const__)}},
    // optional sfixed64 lt = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 1, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.lt_)}},
    // optional sfixed64 lte = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 2, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.lte_)}},
    // optional sfixed64 gt = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 3, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.gt_)}},
    // optional sfixed64 gte = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 4, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.gte_)}},
    // repeated sfixed64 in = 6;
    {::_pbi::TcParser::FastF64R1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.in_)}},
    // repeated sfixed64 not_in = 7;
    {::_pbi::TcParser::FastF64R1,
     {57, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sfixed64 const = 1;
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed64)},
    // optional sfixed64 lt = 2;
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed64)},
    // optional sfixed64 lte = 3;
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed64)},
    // optional sfixed64 gt = 4;
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed64)},
    // optional sfixed64 gte = 5;
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed64)},
    // repeated sfixed64 in = 6;
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSFixed64)},
    // repeated sfixed64 not_in = 7;
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSFixed64)},
    // optional bool ignore_empty = 8;
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void SFixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.SFixed64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SFixed64Rules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SFixed64Rules& this_ = static_cast<const SFixed64Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SFixed64Rules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SFixed64Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.SFixed64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional sfixed64 const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
        1, this_._internal_const_(), target);
  }

  // optional sfixed64 lt = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
        2, this_._internal_lt(), target);
  }

  // optional sfixed64 lte = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
        3, this_._internal_lte(), target);
  }

  // optional sfixed64 gt = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
        4, this_._internal_gt(), target);
  }

  // optional sfixed64 gte = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
        5, this_._internal_gte(), target);
  }

  // repeated sfixed64 in = 6;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
        6, this_._internal_in().Get(i), target);
  }

  // repeated sfixed64 not_in = 7;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
        7, this_._internal_not_in().Get(i), target);
  }

  // optional bool ignore_empty = 8;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.SFixed64Rules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SFixed64Rules::ByteSizeLong(const MessageLite& base) {
  const SFixed64Rules& this_ = static_cast<const SFixed64Rules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SFixed64Rules::ByteSizeLong() const {
  const SFixed64Rules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.SFixed64Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated sfixed64 in = 6;
    {
      ::size_t data_size = ::size_t{8} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated sfixed64 not_in = 7;
    {
      ::size_t data_size = ::size_t{8} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x0000001fu & cached_has_bits) * 9;
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SFixed64Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SFixed64Rules*>(&to_msg);
  auto& from = static_cast<const SFixed64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.SFixed64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.lt_ = from._impl_.lt_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.lte_ = from._impl_.lte_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.gt_ = from._impl_.gt_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.gte_ = from._impl_.gte_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SFixed64Rules::CopyFrom(const SFixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.SFixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SFixed64Rules::InternalSwap(SFixed64Rules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.ignore_empty_)
      + sizeof(SFixed64Rules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata SFixed64Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class BoolRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BoolRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BoolRules, _impl_._has_bits_);
};

BoolRules::BoolRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BoolRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.BoolRules)
}
BoolRules::BoolRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BoolRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BoolRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE BoolRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void BoolRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
BoolRules::~BoolRules() {
  // @@protoc_insertion_point(destructor:validate.BoolRules)
  SharedDtor(*this);
}
inline void BoolRules::SharedDtor(MessageLite& self) {
  BoolRules& this_ = static_cast<BoolRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BoolRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BoolRules(arena);
}
constexpr auto BoolRules::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(BoolRules),
                                            alignof(BoolRules));
}
constexpr auto BoolRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_BoolRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BoolRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<BoolRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BoolRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<BoolRules>(), &BoolRules::ByteSizeLong,
              &BoolRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BoolRules, _impl_._cached_size_),
          false,
      },
      &BoolRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull BoolRules_class_data_ =
        BoolRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BoolRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&BoolRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(BoolRules_class_data_.tc_table);
  return BoolRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
BoolRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BoolRules, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    BoolRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::BoolRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool const = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(BoolRules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(BoolRules, _impl_.const__)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool const = 1;
    {PROTOBUF_FIELD_OFFSET(BoolRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void BoolRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.BoolRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.const__ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BoolRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BoolRules& this_ = static_cast<const BoolRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BoolRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BoolRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.BoolRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_const_(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.BoolRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BoolRules::ByteSizeLong(const MessageLite& base) {
  const BoolRules& this_ = static_cast<const BoolRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BoolRules::ByteSizeLong() const {
  const BoolRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.BoolRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000001u & cached_has_bits) * 2;
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void BoolRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<BoolRules*>(&to_msg);
  auto& from = static_cast<const BoolRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.BoolRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _this->_impl_.const__ = from._impl_.const__;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BoolRules::CopyFrom(const BoolRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.BoolRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BoolRules::InternalSwap(BoolRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.const__, other->_impl_.const__);
}

::google::protobuf::Metadata BoolRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class StringRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<StringRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(StringRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::validate::StringRules, _impl_._oneof_case_);
};

StringRules::StringRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, StringRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.StringRules)
}
PROTOBUF_NDEBUG_INLINE StringRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::StringRules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        const__(arena, from.const__),
        pattern_(arena, from.pattern_),
        prefix_(arena, from.prefix_),
        suffix_(arena, from.suffix_),
        contains_(arena, from.contains_),
        not_contains_(arena, from.not_contains_),
        well_known_{},
        _oneof_case_{from._oneof_case_[0]} {}

StringRules::StringRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const StringRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, StringRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  StringRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_len_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, min_len_),
           offsetof(Impl_, strict_) -
               offsetof(Impl_, min_len_) +
               sizeof(Impl_::strict_));
  switch (well_known_case()) {
    case WELL_KNOWN_NOT_SET:
      break;
      case kEmail:
        _impl_.well_known_.email_ = from._impl_.well_known_.email_;
        break;
      case kHostname:
        _impl_.well_known_.hostname_ = from._impl_.well_known_.hostname_;
        break;
      case kIp:
        _impl_.well_known_.ip_ = from._impl_.well_known_.ip_;
        break;
      case kIpv4:
        _impl_.well_known_.ipv4_ = from._impl_.well_known_.ipv4_;
        break;
      case kIpv6:
        _impl_.well_known_.ipv6_ = from._impl_.well_known_.ipv6_;
        break;
      case kUri:
        _impl_.well_known_.uri_ = from._impl_.well_known_.uri_;
        break;
      case kUriRef:
        _impl_.well_known_.uri_ref_ = from._impl_.well_known_.uri_ref_;
        break;
      case kAddress:
        _impl_.well_known_.address_ = from._impl_.well_known_.address_;
        break;
      case kUuid:
        _impl_.well_known_.uuid_ = from._impl_.well_known_.uuid_;
        break;
      case kWellKnownRegex:
        _impl_.well_known_.well_known_regex_ = from._impl_.well_known_.well_known_regex_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:validate.StringRules)
}
PROTOBUF_NDEBUG_INLINE StringRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        const__(arena),
        pattern_(arena),
        prefix_(arena),
        suffix_(arena),
        contains_(arena),
        not_contains_(arena),
        strict_{true},
        well_known_{},
        _oneof_case_{} {}

inline void StringRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_len_),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, min_len_) +
               sizeof(Impl_::ignore_empty_));
}
StringRules::~StringRules() {
  // @@protoc_insertion_point(destructor:validate.StringRules)
  SharedDtor(*this);
}
inline void StringRules::SharedDtor(MessageLite& self) {
  StringRules& this_ = static_cast<StringRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.const__.Destroy();
  this_._impl_.pattern_.Destroy();
  this_._impl_.prefix_.Destroy();
  this_._impl_.suffix_.Destroy();
  this_._impl_.contains_.Destroy();
  this_._impl_.not_contains_.Destroy();
  if (this_.has_well_known()) {
    this_.clear_well_known();
  }
  this_._impl_.~Impl_();
}

void StringRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:validate.StringRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (well_known_case()) {
    case kEmail: {
      // No need to clear
      break;
    }
    case kHostname: {
      // No need to clear
      break;
    }
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case kUri: {
      // No need to clear
      break;
    }
    case kUriRef: {
      // No need to clear
      break;
    }
    case kAddress: {
      // No need to clear
      break;
    }
    case kUuid: {
      // No need to clear
      break;
    }
    case kWellKnownRegex: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


inline void* PROTOBUF_NONNULL StringRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) StringRules(arena);
}
constexpr auto StringRules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(StringRules, _impl_.in_) +
          decltype(StringRules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_in_) +
          decltype(StringRules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(StringRules), alignof(StringRules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&StringRules::PlacementNew_,
                                 sizeof(StringRules),
                                 alignof(StringRules));
  }
}
constexpr auto StringRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_StringRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &StringRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<StringRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &StringRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<StringRules>(), &StringRules::ByteSizeLong,
              &StringRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(StringRules, _impl_._cached_size_),
          false,
      },
      &StringRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull StringRules_class_data_ =
        StringRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
StringRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&StringRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(StringRules_class_data_.tc_table);
  return StringRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 26, 1, 105, 2>
StringRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(StringRules, _impl_._has_bits_),
    0, // no _extensions_
    26, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4227858432,  // skipmap
    offsetof(decltype(_table_), field_entries),
    26,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    StringRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::StringRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string const = 1;
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.const__)}},
    // optional uint64 min_len = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StringRules, _impl_.min_len_), 6>(),
     {16, 6, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_len_)}},
    // optional uint64 max_len = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StringRules, _impl_.max_len_), 7>(),
     {24, 7, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.max_len_)}},
    // optional uint64 min_bytes = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StringRules, _impl_.min_bytes_), 8>(),
     {32, 8, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_bytes_)}},
    // optional uint64 max_bytes = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StringRules, _impl_.max_bytes_), 9>(),
     {40, 9, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.max_bytes_)}},
    // optional string pattern = 6;
    {::_pbi::TcParser::FastSS1,
     {50, 1, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.pattern_)}},
    // optional string prefix = 7;
    {::_pbi::TcParser::FastSS1,
     {58, 2, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.prefix_)}},
    // optional string suffix = 8;
    {::_pbi::TcParser::FastSS1,
     {66, 3, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.suffix_)}},
    // optional string contains = 9;
    {::_pbi::TcParser::FastSS1,
     {74, 4, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.contains_)}},
    // repeated string in = 10;
    {::_pbi::TcParser::FastSR1,
     {82, 63, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.in_)}},
    // repeated string not_in = 11;
    {::_pbi::TcParser::FastSR1,
     {90, 63, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_in_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 len = 19;
    {::_pbi::TcParser::FastV64S2,
     {408, 10, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.len_)}},
    // optional uint64 len_bytes = 20;
    {::_pbi::TcParser::FastV64S2,
     {416, 11, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.len_bytes_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional string not_contains = 23;
    {::_pbi::TcParser::FastSS2,
     {442, 5, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_contains_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool strict = 25 [default = true];
    {::_pbi::TcParser::FastV8S2,
     {456, 13, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.strict_)}},
    // optional bool ignore_empty = 26;
    {::_pbi::TcParser::FastV8S2,
     {464, 12, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.ignore_empty_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string const = 1;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional uint64 min_len = 2;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_len_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_len = 3;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.max_len_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 min_bytes = 4;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_bytes_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_bytes = 5;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.max_bytes_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional string pattern = 6;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.pattern_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string prefix = 7;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.prefix_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string suffix = 8;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.suffix_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string contains = 9;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.contains_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated string in = 10;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // repeated string not_in = 11;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // bool email = 12;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.email_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool hostname = 13;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.hostname_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ip = 14;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ip_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv4 = 15;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ipv4_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv6 = 16;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ipv6_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool uri = 17;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.uri_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool uri_ref = 18;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.uri_ref_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // optional uint64 len = 19;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.len_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 len_bytes = 20;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.len_bytes_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // bool address = 21;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.address_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool uuid = 22;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.uuid_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // optional string not_contains = 23;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_contains_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // .validate.KnownRegex well_known_regex = 24;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.well_known_regex_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kEnumRange)},
    // optional bool strict = 25 [default = true];
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.strict_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool ignore_empty = 26;
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {0, 2},
  }},
  {{
    "\24\5\0\0\0\0\7\6\6\10\2\6\0\0\0\0\0\0\0\0\0\0\0\14\0\0\0\0\0\0\0\0"
    "validate.StringRules"
    "const"
    "pattern"
    "prefix"
    "suffix"
    "contains"
    "in"
    "not_in"
    "not_contains"
  }},
};
PROTOBUF_NOINLINE void StringRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.StringRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.const__.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.pattern_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.prefix_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _impl_.suffix_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _impl_.contains_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _impl_.not_contains_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x000000c0u) != 0) {
    ::memset(&_impl_.min_len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_len_) -
        reinterpret_cast<char*>(&_impl_.min_len_)) + sizeof(_impl_.max_len_));
  }
  if ((cached_has_bits & 0x00003f00u) != 0) {
    ::memset(&_impl_.min_bytes_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.min_bytes_)) + sizeof(_impl_.ignore_empty_));
    _impl_.strict_ = true;
  }
  clear_well_known();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL StringRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const StringRules& this_ = static_cast<const StringRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL StringRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const StringRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.StringRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_const_();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "validate.StringRules.const");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional uint64 min_len = 2;
  if ((cached_has_bits & 0x00000040u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this_._internal_min_len(), target);
  }

  // optional uint64 max_len = 3;
  if ((cached_has_bits & 0x00000080u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this_._internal_max_len(), target);
  }

  // optional uint64 min_bytes = 4;
  if ((cached_has_bits & 0x00000100u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this_._internal_min_bytes(), target);
  }

  // optional uint64 max_bytes = 5;
  if ((cached_has_bits & 0x00000200u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this_._internal_max_bytes(), target);
  }

  // optional string pattern = 6;
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_pattern();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "validate.StringRules.pattern");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // optional string prefix = 7;
  if ((cached_has_bits & 0x00000004u) != 0) {
    const ::std::string& _s = this_._internal_prefix();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "validate.StringRules.prefix");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional string suffix = 8;
  if ((cached_has_bits & 0x00000008u) != 0) {
    const ::std::string& _s = this_._internal_suffix();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "validate.StringRules.suffix");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // optional string contains = 9;
  if ((cached_has_bits & 0x00000010u) != 0) {
    const ::std::string& _s = this_._internal_contains();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "validate.StringRules.contains");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // repeated string in = 10;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    const auto& s = this_._internal_in().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "validate.StringRules.in");
    target = stream->WriteString(10, s, target);
  }

  // repeated string not_in = 11;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    const auto& s = this_._internal_not_in().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "validate.StringRules.not_in");
    target = stream->WriteString(11, s, target);
  }

  switch (this_.well_known_case()) {
    case kEmail: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          12, this_._internal_email(), target);
      break;
    }
    case kHostname: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          13, this_._internal_hostname(), target);
      break;
    }
    case kIp: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          14, this_._internal_ip(), target);
      break;
    }
    case kIpv4: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          15, this_._internal_ipv4(), target);
      break;
    }
    case kIpv6: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          16, this_._internal_ipv6(), target);
      break;
    }
    case kUri: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          17, this_._internal_uri(), target);
      break;
    }
    case kUriRef: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          18, this_._internal_uri_ref(), target);
      break;
    }
    default:
      break;
  }
  // optional uint64 len = 19;
  if ((cached_has_bits & 0x00000400u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        19, this_._internal_len(), target);
  }

  // optional uint64 len_bytes = 20;
  if ((cached_has_bits & 0x00000800u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        20, this_._internal_len_bytes(), target);
  }

  switch (this_.well_known_case()) {
    case kAddress: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          21, this_._internal_address(), target);
      break;
    }
    case kUuid: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          22, this_._internal_uuid(), target);
      break;
    }
    default:
      break;
  }
  // optional string not_contains = 23;
  if ((cached_has_bits & 0x00000020u) != 0) {
    const ::std::string& _s = this_._internal_not_contains();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "validate.StringRules.not_contains");
    target = stream->WriteStringMaybeAliased(23, _s, target);
  }

  // .validate.KnownRegex well_known_regex = 24;
  if (this_.well_known_case() == kWellKnownRegex) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        24, this_._internal_well_known_regex(), target);
  }

  // optional bool strict = 25 [default = true];
  if ((cached_has_bits & 0x00002000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        25, this_._internal_strict(), target);
  }

  // optional bool ignore_empty = 26;
  if ((cached_has_bits & 0x00001000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        26, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.StringRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t StringRules::ByteSizeLong(const MessageLite& base) {
  const StringRules& this_ = static_cast<const StringRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t StringRules::ByteSizeLong() const {
  const StringRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.StringRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated string in = 10;
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_in().size());
      for (int i = 0, n = this_._internal_in().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_in().Get(i));
      }
    }
    // repeated string not_in = 11;
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_not_in().size());
      for (int i = 0, n = this_._internal_not_in().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_not_in().Get(i));
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00003000u & cached_has_bits) * 3;
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // optional string const = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_const_());
    }
    // optional string pattern = 6;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_pattern());
    }
    // optional string prefix = 7;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_prefix());
    }
    // optional string suffix = 8;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_suffix());
    }
    // optional string contains = 9;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_contains());
    }
    // optional string not_contains = 23;
    if ((cached_has_bits & 0x00000020u) != 0) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_not_contains());
    }
    // optional uint64 min_len = 2;
    if ((cached_has_bits & 0x00000040u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_min_len());
    }
    // optional uint64 max_len = 3;
    if ((cached_has_bits & 0x00000080u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_max_len());
    }
  }
  if ((cached_has_bits & 0x00000f00u) != 0) {
    // optional uint64 min_bytes = 4;
    if ((cached_has_bits & 0x00000100u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_min_bytes());
    }
    // optional uint64 max_bytes = 5;
    if ((cached_has_bits & 0x00000200u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_max_bytes());
    }
    // optional uint64 len = 19;
    if ((cached_has_bits & 0x00000400u) != 0) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this_._internal_len());
    }
    // optional uint64 len_bytes = 20;
    if ((cached_has_bits & 0x00000800u) != 0) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this_._internal_len_bytes());
    }
  }
  switch (this_.well_known_case()) {
    // bool email = 12;
    case kEmail: {
      total_size += 2;
      break;
    }
    // bool hostname = 13;
    case kHostname: {
      total_size += 2;
      break;
    }
    // bool ip = 14;
    case kIp: {
      total_size += 2;
      break;
    }
    // bool ipv4 = 15;
    case kIpv4: {
      total_size += 2;
      break;
    }
    // bool ipv6 = 16;
    case kIpv6: {
      total_size += 3;
      break;
    }
    // bool uri = 17;
    case kUri: {
      total_size += 3;
      break;
    }
    // bool uri_ref = 18;
    case kUriRef: {
      total_size += 3;
      break;
    }
    // bool address = 21;
    case kAddress: {
      total_size += 3;
      break;
    }
    // bool uuid = 22;
    case kUuid: {
      total_size += 3;
      break;
    }
    // .validate.KnownRegex well_known_regex = 24;
    case kWellKnownRegex: {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void StringRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<StringRules*>(&to_msg);
  auto& from = static_cast<const StringRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.StringRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_const_(from._internal_const_());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_pattern(from._internal_pattern());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_internal_set_prefix(from._internal_prefix());
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_internal_set_suffix(from._internal_suffix());
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_internal_set_contains(from._internal_contains());
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_internal_set_not_contains(from._internal_not_contains());
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _this->_impl_.min_len_ = from._impl_.min_len_;
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      _this->_impl_.max_len_ = from._impl_.max_len_;
    }
  }
  if ((cached_has_bits & 0x00003f00u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      _this->_impl_.min_bytes_ = from._impl_.min_bytes_;
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      _this->_impl_.max_bytes_ = from._impl_.max_bytes_;
    }
    if ((cached_has_bits & 0x00000400u) != 0) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if ((cached_has_bits & 0x00000800u) != 0) {
      _this->_impl_.len_bytes_ = from._impl_.len_bytes_;
    }
    if ((cached_has_bits & 0x00001000u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    if ((cached_has_bits & 0x00002000u) != 0) {
      _this->_impl_.strict_ = from._impl_.strict_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_well_known();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kEmail: {
        _this->_impl_.well_known_.email_ = from._impl_.well_known_.email_;
        break;
      }
      case kHostname: {
        _this->_impl_.well_known_.hostname_ = from._impl_.well_known_.hostname_;
        break;
      }
      case kIp: {
        _this->_impl_.well_known_.ip_ = from._impl_.well_known_.ip_;
        break;
      }
      case kIpv4: {
        _this->_impl_.well_known_.ipv4_ = from._impl_.well_known_.ipv4_;
        break;
      }
      case kIpv6: {
        _this->_impl_.well_known_.ipv6_ = from._impl_.well_known_.ipv6_;
        break;
      }
      case kUri: {
        _this->_impl_.well_known_.uri_ = from._impl_.well_known_.uri_;
        break;
      }
      case kUriRef: {
        _this->_impl_.well_known_.uri_ref_ = from._impl_.well_known_.uri_ref_;
        break;
      }
      case kAddress: {
        _this->_impl_.well_known_.address_ = from._impl_.well_known_.address_;
        break;
      }
      case kUuid: {
        _this->_impl_.well_known_.uuid_ = from._impl_.well_known_.uuid_;
        break;
      }
      case kWellKnownRegex: {
        _this->_impl_.well_known_.well_known_regex_ = from._impl_.well_known_.well_known_regex_;
        break;
      }
      case WELL_KNOWN_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void StringRules::CopyFrom(const StringRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.StringRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void StringRules::InternalSwap(StringRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.const__, &other->_impl_.const__, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.pattern_, &other->_impl_.pattern_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.prefix_, &other->_impl_.prefix_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.suffix_, &other->_impl_.suffix_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.contains_, &other->_impl_.contains_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.not_contains_, &other->_impl_.not_contains_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StringRules, _impl_.strict_)
      + sizeof(StringRules::_impl_.strict_)
      - PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_len_)>(
          reinterpret_cast<char*>(&_impl_.min_len_),
          reinterpret_cast<char*>(&other->_impl_.min_len_));
  swap(_impl_.well_known_, other->_impl_.well_known_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata StringRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class BytesRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BytesRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BytesRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::validate::BytesRules, _impl_._oneof_case_);
};

BytesRules::BytesRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BytesRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.BytesRules)
}
PROTOBUF_NDEBUG_INLINE BytesRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::BytesRules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        const__(arena, from.const__),
        pattern_(arena, from.pattern_),
        prefix_(arena, from.prefix_),
        suffix_(arena, from.suffix_),
        contains_(arena, from.contains_),
        well_known_{},
        _oneof_case_{from._oneof_case_[0]} {}

BytesRules::BytesRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BytesRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BytesRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BytesRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_len_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, min_len_),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, min_len_) +
               sizeof(Impl_::ignore_empty_));
  switch (well_known_case()) {
    case WELL_KNOWN_NOT_SET:
      break;
      case kIp:
        _impl_.well_known_.ip_ = from._impl_.well_known_.ip_;
        break;
      case kIpv4:
        _impl_.well_known_.ipv4_ = from._impl_.well_known_.ipv4_;
        break;
      case kIpv6:
        _impl_.well_known_.ipv6_ = from._impl_.well_known_.ipv6_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:validate.BytesRules)
}
PROTOBUF_NDEBUG_INLINE BytesRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        const__(arena),
        pattern_(arena),
        prefix_(arena),
        suffix_(arena),
        contains_(arena),
        well_known_{},
        _oneof_case_{} {}

inline void BytesRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_len_),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, min_len_) +
               sizeof(Impl_::ignore_empty_));
}
BytesRules::~BytesRules() {
  // @@protoc_insertion_point(destructor:validate.BytesRules)
  SharedDtor(*this);
}
inline void BytesRules::SharedDtor(MessageLite& self) {
  BytesRules& this_ = static_cast<BytesRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.const__.Destroy();
  this_._impl_.pattern_.Destroy();
  this_._impl_.prefix_.Destroy();
  this_._impl_.suffix_.Destroy();
  this_._impl_.contains_.Destroy();
  if (this_.has_well_known()) {
    this_.clear_well_known();
  }
  this_._impl_.~Impl_();
}

void BytesRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:validate.BytesRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (well_known_case()) {
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


inline void* PROTOBUF_NONNULL BytesRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BytesRules(arena);
}
constexpr auto BytesRules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.in_) +
          decltype(BytesRules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.not_in_) +
          decltype(BytesRules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(BytesRules), alignof(BytesRules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&BytesRules::PlacementNew_,
                                 sizeof(BytesRules),
                                 alignof(BytesRules));
  }
}
constexpr auto BytesRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_BytesRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BytesRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<BytesRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BytesRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<BytesRules>(), &BytesRules::ByteSizeLong,
              &BytesRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BytesRules, _impl_._cached_size_),
          false,
      },
      &BytesRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull BytesRules_class_data_ =
        BytesRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BytesRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&BytesRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(BytesRules_class_data_.tc_table);
  return BytesRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 14, 0, 43, 2>
BytesRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BytesRules, _impl_._has_bits_),
    0, // no _extensions_
    14, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950912,  // skipmap
    offsetof(decltype(_table_), field_entries),
    14,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    BytesRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::BytesRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bytes const = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.const__)}},
    // optional uint64 min_len = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(BytesRules, _impl_.min_len_), 5>(),
     {16, 5, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.min_len_)}},
    // optional uint64 max_len = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(BytesRules, _impl_.max_len_), 6>(),
     {24, 6, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.max_len_)}},
    // optional string pattern = 4;
    {::_pbi::TcParser::FastSS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.pattern_)}},
    // optional bytes prefix = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 2, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.prefix_)}},
    // optional bytes suffix = 6;
    {::_pbi::TcParser::FastBS1,
     {50, 3, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.suffix_)}},
    // optional bytes contains = 7;
    {::_pbi::TcParser::FastBS1,
     {58, 4, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.contains_)}},
    // repeated bytes in = 8;
    {::_pbi::TcParser::FastBR1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.in_)}},
    // repeated bytes not_in = 9;
    {::_pbi::TcParser::FastBR1,
     {74, 63, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.not_in_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 len = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(BytesRules, _impl_.len_), 7>(),
     {104, 7, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.len_)}},
    // optional bool ignore_empty = 14;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(BytesRules, _impl_.ignore_empty_), 8>(),
     {112, 8, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.ignore_empty_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bytes const = 1;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint64 min_len = 2;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.min_len_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_len = 3;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.max_len_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional string pattern = 4;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.pattern_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional bytes prefix = 5;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.prefix_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes suffix = 6;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.suffix_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes contains = 7;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.contains_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // repeated bytes in = 8;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // repeated bytes not_in = 9;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // bool ip = 10;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.well_known_.ip_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv4 = 11;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.well_known_.ipv4_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv6 = 12;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.well_known_.ipv6_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // optional uint64 len = 13;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.len_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool ignore_empty = 14;
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\23\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0"
    "validate.BytesRules"
    "pattern"
  }},
};
PROTOBUF_NOINLINE void BytesRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.BytesRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000001fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.const__.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.pattern_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.prefix_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _impl_.suffix_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _impl_.contains_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x000000e0u) != 0) {
    ::memset(&_impl_.min_len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.min_len_)) + sizeof(_impl_.len_));
  }
  _impl_.ignore_empty_ = false;
  clear_well_known();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BytesRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BytesRules& this_ = static_cast<const BytesRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BytesRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BytesRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.BytesRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bytes const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_const_();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // optional uint64 min_len = 2;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this_._internal_min_len(), target);
  }

  // optional uint64 max_len = 3;
  if ((cached_has_bits & 0x00000040u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this_._internal_max_len(), target);
  }

  // optional string pattern = 4;
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_pattern();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "validate.BytesRules.pattern");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional bytes prefix = 5;
  if ((cached_has_bits & 0x00000004u) != 0) {
    const ::std::string& _s = this_._internal_prefix();
    target = stream->WriteBytesMaybeAliased(5, _s, target);
  }

  // optional bytes suffix = 6;
  if ((cached_has_bits & 0x00000008u) != 0) {
    const ::std::string& _s = this_._internal_suffix();
    target = stream->WriteBytesMaybeAliased(6, _s, target);
  }

  // optional bytes contains = 7;
  if ((cached_has_bits & 0x00000010u) != 0) {
    const ::std::string& _s = this_._internal_contains();
    target = stream->WriteBytesMaybeAliased(7, _s, target);
  }

  // repeated bytes in = 8;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    const auto& s = this_._internal_in().Get(i);
    target = stream->WriteBytes(8, s, target);
  }

  // repeated bytes not_in = 9;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    const auto& s = this_._internal_not_in().Get(i);
    target = stream->WriteBytes(9, s, target);
  }

  switch (this_.well_known_case()) {
    case kIp: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          10, this_._internal_ip(), target);
      break;
    }
    case kIpv4: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          11, this_._internal_ipv4(), target);
      break;
    }
    case kIpv6: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          12, this_._internal_ipv6(), target);
      break;
    }
    default:
      break;
  }
  // optional uint64 len = 13;
  if ((cached_has_bits & 0x00000080u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        13, this_._internal_len(), target);
  }

  // optional bool ignore_empty = 14;
  if ((cached_has_bits & 0x00000100u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        14, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.BytesRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BytesRules::ByteSizeLong(const MessageLite& base) {
  const BytesRules& this_ = static_cast<const BytesRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BytesRules::ByteSizeLong() const {
  const BytesRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.BytesRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated bytes in = 8;
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_in().size());
      for (int i = 0, n = this_._internal_in().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
            this_._internal_in().Get(i));
      }
    }
    // repeated bytes not_in = 9;
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_not_in().size());
      for (int i = 0, n = this_._internal_not_in().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
            this_._internal_not_in().Get(i));
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000100u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // optional bytes const = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_const_());
    }
    // optional string pattern = 4;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_pattern());
    }
    // optional bytes prefix = 5;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_prefix());
    }
    // optional bytes suffix = 6;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_suffix());
    }
    // optional bytes contains = 7;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_contains());
    }
    // optional uint64 min_len = 2;
    if ((cached_has_bits & 0x00000020u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_min_len());
    }
    // optional uint64 max_len = 3;
    if ((cached_has_bits & 0x00000040u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_max_len());
    }
    // optional uint64 len = 13;
    if ((cached_has_bits & 0x00000080u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_len());
    }
  }
  switch (this_.well_known_case()) {
    // bool ip = 10;
    case kIp: {
      total_size += 2;
      break;
    }
    // bool ipv4 = 11;
    case kIpv4: {
      total_size += 2;
      break;
    }
    // bool ipv6 = 12;
    case kIpv6: {
      total_size += 2;
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void BytesRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<BytesRules*>(&to_msg);
  auto& from = static_cast<const BytesRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.BytesRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_const_(from._internal_const_());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_pattern(from._internal_pattern());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_internal_set_prefix(from._internal_prefix());
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_internal_set_suffix(from._internal_suffix());
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_internal_set_contains(from._internal_contains());
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.min_len_ = from._impl_.min_len_;
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _this->_impl_.max_len_ = from._impl_.max_len_;
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      _this->_impl_.len_ = from._impl_.len_;
    }
  }
  if ((cached_has_bits & 0x00000100u) != 0) {
    _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_well_known();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kIp: {
        _this->_impl_.well_known_.ip_ = from._impl_.well_known_.ip_;
        break;
      }
      case kIpv4: {
        _this->_impl_.well_known_.ipv4_ = from._impl_.well_known_.ipv4_;
        break;
      }
      case kIpv6: {
        _this->_impl_.well_known_.ipv6_ = from._impl_.well_known_.ipv6_;
        break;
      }
      case WELL_KNOWN_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BytesRules::CopyFrom(const BytesRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.BytesRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BytesRules::InternalSwap(BytesRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.const__, &other->_impl_.const__, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.pattern_, &other->_impl_.pattern_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.prefix_, &other->_impl_.prefix_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.suffix_, &other->_impl_.suffix_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.contains_, &other->_impl_.contains_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.ignore_empty_)
      + sizeof(BytesRules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.min_len_)>(
          reinterpret_cast<char*>(&_impl_.min_len_),
          reinterpret_cast<char*>(&other->_impl_.min_len_));
  swap(_impl_.well_known_, other->_impl_.well_known_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata BytesRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class EnumRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<EnumRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(EnumRules, _impl_._has_bits_);
};

EnumRules::EnumRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EnumRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.EnumRules)
}
PROTOBUF_NDEBUG_INLINE EnumRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::EnumRules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

EnumRules::EnumRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const EnumRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, EnumRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  EnumRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, defined_only_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::defined_only_));

  // @@protoc_insertion_point(copy_constructor:validate.EnumRules)
}
PROTOBUF_NDEBUG_INLINE EnumRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void EnumRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, defined_only_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::defined_only_));
}
EnumRules::~EnumRules() {
  // @@protoc_insertion_point(destructor:validate.EnumRules)
  SharedDtor(*this);
}
inline void EnumRules::SharedDtor(MessageLite& self) {
  EnumRules& this_ = static_cast<EnumRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL EnumRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) EnumRules(arena);
}
constexpr auto EnumRules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.in_) +
          decltype(EnumRules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.not_in_) +
          decltype(EnumRules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(EnumRules), alignof(EnumRules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&EnumRules::PlacementNew_,
                                 sizeof(EnumRules),
                                 alignof(EnumRules));
  }
}
constexpr auto EnumRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_EnumRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &EnumRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<EnumRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &EnumRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<EnumRules>(), &EnumRules::ByteSizeLong,
              &EnumRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(EnumRules, _impl_._cached_size_),
          false,
      },
      &EnumRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull EnumRules_class_data_ =
        EnumRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
EnumRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&EnumRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(EnumRules_class_data_.tc_table);
  return EnumRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
EnumRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EnumRules, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    EnumRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::EnumRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 not_in = 4;
    {::_pbi::TcParser::FastV32R1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.not_in_)}},
    // optional int32 const = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(EnumRules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.const__)}},
    // optional bool defined_only = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(EnumRules, _impl_.defined_only_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.defined_only_)}},
    // repeated int32 in = 3;
    {::_pbi::TcParser::FastV32R1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 const = 1;
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bool defined_only = 2;
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.defined_only_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated int32 in = 3;
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
    // repeated int32 not_in = 4;
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void EnumRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.EnumRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.defined_only_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.defined_only_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL EnumRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const EnumRules& this_ = static_cast<const EnumRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL EnumRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const EnumRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.EnumRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional int32 const = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
            stream, this_._internal_const_(), target);
  }

  // optional bool defined_only = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_defined_only(), target);
  }

  // repeated int32 in = 3;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this_._internal_in().Get(i), target);
  }

  // repeated int32 not_in = 4;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this_._internal_not_in().Get(i), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.EnumRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t EnumRules::ByteSizeLong(const MessageLite& base) {
  const EnumRules& this_ = static_cast<const EnumRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t EnumRules::ByteSizeLong() const {
  const EnumRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.EnumRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated int32 in = 3;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
          this_._internal_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_in_size());
      total_size += tag_size + data_size;
    }
    // repeated int32 not_in = 4;
    {
      ::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
          this_._internal_not_in());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_not_in_size());
      total_size += tag_size + data_size;
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000002u & cached_has_bits) * 2;
   {
    // optional int32 const = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_const_());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void EnumRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<EnumRules*>(&to_msg);
  auto& from = static_cast<const EnumRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.EnumRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.defined_only_ = from._impl_.defined_only_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EnumRules::CopyFrom(const EnumRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.EnumRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EnumRules::InternalSwap(EnumRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.defined_only_)
      + sizeof(EnumRules::_impl_.defined_only_)
      - PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata EnumRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MessageRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MessageRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MessageRules, _impl_._has_bits_);
};

MessageRules::MessageRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MessageRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.MessageRules)
}
MessageRules::MessageRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MessageRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MessageRules_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE MessageRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void MessageRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, skip_),
           0,
           offsetof(Impl_, required_) -
               offsetof(Impl_, skip_) +
               sizeof(Impl_::required_));
}
MessageRules::~MessageRules() {
  // @@protoc_insertion_point(destructor:validate.MessageRules)
  SharedDtor(*this);
}
inline void MessageRules::SharedDtor(MessageLite& self) {
  MessageRules& this_ = static_cast<MessageRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MessageRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MessageRules(arena);
}
constexpr auto MessageRules::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(MessageRules),
                                            alignof(MessageRules));
}
constexpr auto MessageRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MessageRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MessageRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MessageRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MessageRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MessageRules>(), &MessageRules::ByteSizeLong,
              &MessageRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MessageRules, _impl_._cached_size_),
          false,
      },
      &MessageRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MessageRules_class_data_ =
        MessageRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MessageRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MessageRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MessageRules_class_data_.tc_table);
  return MessageRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
MessageRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MessageRules, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    MessageRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::MessageRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool required = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MessageRules, _impl_.required_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(MessageRules, _impl_.required_)}},
    // optional bool skip = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MessageRules, _impl_.skip_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(MessageRules, _impl_.skip_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool skip = 1;
    {PROTOBUF_FIELD_OFFSET(MessageRules, _impl_.skip_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool required = 2;
    {PROTOBUF_FIELD_OFFSET(MessageRules, _impl_.required_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void MessageRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.MessageRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.skip_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.required_) -
      reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.required_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MessageRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MessageRules& this_ = static_cast<const MessageRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MessageRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MessageRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.MessageRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool skip = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_skip(), target);
  }

  // optional bool required = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_required(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.MessageRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MessageRules::ByteSizeLong(const MessageLite& base) {
  const MessageRules& this_ = static_cast<const MessageRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MessageRules::ByteSizeLong() const {
  const MessageRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.MessageRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000003u & cached_has_bits) * 2;
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MessageRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<MessageRules*>(&to_msg);
  auto& from = static_cast<const MessageRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.MessageRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.skip_ = from._impl_.skip_;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.required_ = from._impl_.required_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MessageRules::CopyFrom(const MessageRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.MessageRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MessageRules::InternalSwap(MessageRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessageRules, _impl_.required_)
      + sizeof(MessageRules::_impl_.required_)
      - PROTOBUF_FIELD_OFFSET(MessageRules, _impl_.skip_)>(
          reinterpret_cast<char*>(&_impl_.skip_),
          reinterpret_cast<char*>(&other->_impl_.skip_));
}

::google::protobuf::Metadata MessageRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RepeatedRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RepeatedRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_._has_bits_);
};

RepeatedRules::RepeatedRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RepeatedRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.RepeatedRules)
}
PROTOBUF_NDEBUG_INLINE RepeatedRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::RepeatedRules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RepeatedRules::RepeatedRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RepeatedRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RepeatedRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RepeatedRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.items_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.items_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_items_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, min_items_),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, min_items_) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.RepeatedRules)
}
PROTOBUF_NDEBUG_INLINE RepeatedRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void RepeatedRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, items_),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, items_) +
               sizeof(Impl_::ignore_empty_));
}
RepeatedRules::~RepeatedRules() {
  // @@protoc_insertion_point(destructor:validate.RepeatedRules)
  SharedDtor(*this);
}
inline void RepeatedRules::SharedDtor(MessageLite& self) {
  RepeatedRules& this_ = static_cast<RepeatedRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.items_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RepeatedRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RepeatedRules(arena);
}
constexpr auto RepeatedRules::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(RepeatedRules),
                                            alignof(RepeatedRules));
}
constexpr auto RepeatedRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RepeatedRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RepeatedRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RepeatedRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RepeatedRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RepeatedRules>(), &RepeatedRules::ByteSizeLong,
              &RepeatedRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_._cached_size_),
          false,
      },
      &RepeatedRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RepeatedRules_class_data_ =
        RepeatedRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RepeatedRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RepeatedRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RepeatedRules_class_data_.tc_table);
  return RepeatedRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 0, 2>
RepeatedRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RepeatedRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::RepeatedRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 min_items = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(RepeatedRules, _impl_.min_items_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.min_items_)}},
    // optional uint64 max_items = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(RepeatedRules, _impl_.max_items_), 2>(),
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.max_items_)}},
    // optional bool unique = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(RepeatedRules, _impl_.unique_), 3>(),
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.unique_)}},
    // optional .validate.FieldRules items = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.items_)}},
    // optional bool ignore_empty = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(RepeatedRules, _impl_.ignore_empty_), 4>(),
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.ignore_empty_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint64 min_items = 1;
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.min_items_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_items = 2;
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.max_items_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool unique = 3;
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.unique_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .validate.FieldRules items = 4;
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.items_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool ignore_empty = 5;
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::validate::FieldRules>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RepeatedRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.RepeatedRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    ABSL_DCHECK(_impl_.items_ != nullptr);
    _impl_.items_->Clear();
  }
  if ((cached_has_bits & 0x0000001eu) != 0) {
    ::memset(&_impl_.min_items_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.min_items_)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RepeatedRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RepeatedRules& this_ = static_cast<const RepeatedRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RepeatedRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RepeatedRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.RepeatedRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint64 min_items = 1;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this_._internal_min_items(), target);
  }

  // optional uint64 max_items = 2;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this_._internal_max_items(), target);
  }

  // optional bool unique = 3;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_unique(), target);
  }

  // optional .validate.FieldRules items = 4;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.items_, this_._impl_.items_->GetCachedSize(), target,
        stream);
  }

  // optional bool ignore_empty = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.RepeatedRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RepeatedRules::ByteSizeLong(const MessageLite& base) {
  const RepeatedRules& this_ = static_cast<const RepeatedRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RepeatedRules::ByteSizeLong() const {
  const RepeatedRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.RepeatedRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000018u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x00000007u) != 0) {
    // optional .validate.FieldRules items = 4;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.items_);
    }
    // optional uint64 min_items = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_min_items());
    }
    // optional uint64 max_items = 2;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_max_items());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RepeatedRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RepeatedRules*>(&to_msg);
  auto& from = static_cast<const RepeatedRules&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.RepeatedRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000001fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.items_ != nullptr);
      if (_this->_impl_.items_ == nullptr) {
        _this->_impl_.items_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.items_);
      } else {
        _this->_impl_.items_->MergeFrom(*from._impl_.items_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.min_items_ = from._impl_.min_items_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.max_items_ = from._impl_.max_items_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.unique_ = from._impl_.unique_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RepeatedRules::CopyFrom(const RepeatedRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.RepeatedRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RepeatedRules::InternalSwap(RepeatedRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.ignore_empty_)
      + sizeof(RepeatedRules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.items_)>(
          reinterpret_cast<char*>(&_impl_.items_),
          reinterpret_cast<char*>(&other->_impl_.items_));
}

::google::protobuf::Metadata RepeatedRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MapRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MapRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MapRules, _impl_._has_bits_);
};

MapRules::MapRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MapRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.MapRules)
}
PROTOBUF_NDEBUG_INLINE MapRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::MapRules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

MapRules::MapRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MapRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MapRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MapRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.keys_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.keys_)
                : nullptr;
  _impl_.values_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.values_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_pairs_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, min_pairs_),
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, min_pairs_) +
               sizeof(Impl_::ignore_empty_));

  // @@protoc_insertion_point(copy_constructor:validate.MapRules)
}
PROTOBUF_NDEBUG_INLINE MapRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void MapRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, keys_),
           0,
           offsetof(Impl_, ignore_empty_) -
               offsetof(Impl_, keys_) +
               sizeof(Impl_::ignore_empty_));
}
MapRules::~MapRules() {
  // @@protoc_insertion_point(destructor:validate.MapRules)
  SharedDtor(*this);
}
inline void MapRules::SharedDtor(MessageLite& self) {
  MapRules& this_ = static_cast<MapRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.keys_;
  delete this_._impl_.values_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MapRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MapRules(arena);
}
constexpr auto MapRules::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(MapRules),
                                            alignof(MapRules));
}
constexpr auto MapRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MapRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MapRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MapRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MapRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MapRules>(), &MapRules::ByteSizeLong,
              &MapRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MapRules, _impl_._cached_size_),
          false,
      },
      &MapRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MapRules_class_data_ =
        MapRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MapRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MapRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MapRules_class_data_.tc_table);
  return MapRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 2, 0, 2>
MapRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MapRules, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MapRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::MapRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 min_pairs = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(MapRules, _impl_.min_pairs_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.min_pairs_)}},
    // optional uint64 max_pairs = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(MapRules, _impl_.max_pairs_), 3>(),
     {16, 3, 0, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.max_pairs_)}},
    // optional bool no_sparse = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MapRules, _impl_.no_sparse_), 4>(),
     {24, 4, 0, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.no_sparse_)}},
    // optional .validate.FieldRules keys = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.keys_)}},
    // optional .validate.FieldRules values = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 1, 1, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.values_)}},
    // optional bool ignore_empty = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MapRules, _impl_.ignore_empty_), 5>(),
     {48, 5, 0, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.ignore_empty_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint64 min_pairs = 1;
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.min_pairs_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_pairs = 2;
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.max_pairs_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool no_sparse = 3;
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.no_sparse_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .validate.FieldRules keys = 4;
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.keys_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .validate.FieldRules values = 5;
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.values_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool ignore_empty = 6;
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::validate::FieldRules>()},
      {::_pbi::TcParser::GetTable<::validate::FieldRules>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void MapRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.MapRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.keys_ != nullptr);
      _impl_.keys_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.values_ != nullptr);
      _impl_.values_->Clear();
    }
  }
  if ((cached_has_bits & 0x0000003cu) != 0) {
    ::memset(&_impl_.min_pairs_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_empty_) -
        reinterpret_cast<char*>(&_impl_.min_pairs_)) + sizeof(_impl_.ignore_empty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MapRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MapRules& this_ = static_cast<const MapRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MapRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MapRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.MapRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint64 min_pairs = 1;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this_._internal_min_pairs(), target);
  }

  // optional uint64 max_pairs = 2;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this_._internal_max_pairs(), target);
  }

  // optional bool no_sparse = 3;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_no_sparse(), target);
  }

  // optional .validate.FieldRules keys = 4;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.keys_, this_._impl_.keys_->GetCachedSize(), target,
        stream);
  }

  // optional .validate.FieldRules values = 5;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.values_, this_._impl_.values_->GetCachedSize(), target,
        stream);
  }

  // optional bool ignore_empty = 6;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this_._internal_ignore_empty(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.MapRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MapRules::ByteSizeLong(const MessageLite& base) {
  const MapRules& this_ = static_cast<const MapRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MapRules::ByteSizeLong() const {
  const MapRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.MapRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000030u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // optional .validate.FieldRules keys = 4;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.keys_);
    }
    // optional .validate.FieldRules values = 5;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.values_);
    }
    // optional uint64 min_pairs = 1;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_min_pairs());
    }
    // optional uint64 max_pairs = 2;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_max_pairs());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MapRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<MapRules*>(&to_msg);
  auto& from = static_cast<const MapRules&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.MapRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.keys_ != nullptr);
      if (_this->_impl_.keys_ == nullptr) {
        _this->_impl_.keys_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.keys_);
      } else {
        _this->_impl_.keys_->MergeFrom(*from._impl_.keys_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.values_ != nullptr);
      if (_this->_impl_.values_ == nullptr) {
        _this->_impl_.values_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.values_);
      } else {
        _this->_impl_.values_->MergeFrom(*from._impl_.values_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.min_pairs_ = from._impl_.min_pairs_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.max_pairs_ = from._impl_.max_pairs_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.no_sparse_ = from._impl_.no_sparse_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MapRules::CopyFrom(const MapRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.MapRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MapRules::InternalSwap(MapRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapRules, _impl_.ignore_empty_)
      + sizeof(MapRules::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(MapRules, _impl_.keys_)>(
          reinterpret_cast<char*>(&_impl_.keys_),
          reinterpret_cast<char*>(&other->_impl_.keys_));
}

::google::protobuf::Metadata MapRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AnyRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AnyRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AnyRules, _impl_._has_bits_);
};

AnyRules::AnyRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AnyRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.AnyRules)
}
PROTOBUF_NDEBUG_INLINE AnyRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::AnyRules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

AnyRules::AnyRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const AnyRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AnyRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AnyRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.required_ = from._impl_.required_;

  // @@protoc_insertion_point(copy_constructor:validate.AnyRules)
}
PROTOBUF_NDEBUG_INLINE AnyRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void AnyRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.required_ = {};
}
AnyRules::~AnyRules() {
  // @@protoc_insertion_point(destructor:validate.AnyRules)
  SharedDtor(*this);
}
inline void AnyRules::SharedDtor(MessageLite& self) {
  AnyRules& this_ = static_cast<AnyRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AnyRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AnyRules(arena);
}
constexpr auto AnyRules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.in_) +
          decltype(AnyRules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.not_in_) +
          decltype(AnyRules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(AnyRules), alignof(AnyRules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&AnyRules::PlacementNew_,
                                 sizeof(AnyRules),
                                 alignof(AnyRules));
  }
}
constexpr auto AnyRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_AnyRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AnyRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<AnyRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AnyRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<AnyRules>(), &AnyRules::ByteSizeLong,
              &AnyRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AnyRules, _impl_._cached_size_),
          false,
      },
      &AnyRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull AnyRules_class_data_ =
        AnyRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AnyRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&AnyRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(AnyRules_class_data_.tc_table);
  return AnyRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 34, 2>
AnyRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AnyRules, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    AnyRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::AnyRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool required = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AnyRules, _impl_.required_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.required_)}},
    // repeated string in = 2;
    {::_pbi::TcParser::FastSR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.in_)}},
    // repeated string not_in = 3;
    {::_pbi::TcParser::FastSR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool required = 1;
    {PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.required_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated string in = 2;
    {PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // repeated string not_in = 3;
    {PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
  }},
  // no aux_entries
  {{
    "\21\0\2\6\0\0\0\0"
    "validate.AnyRules"
    "in"
    "not_in"
  }},
};
PROTOBUF_NOINLINE void AnyRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.AnyRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.required_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AnyRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AnyRules& this_ = static_cast<const AnyRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AnyRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AnyRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.AnyRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool required = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_required(), target);
  }

  // repeated string in = 2;
  for (int i = 0, n = this_._internal_in_size(); i < n; ++i) {
    const auto& s = this_._internal_in().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "validate.AnyRules.in");
    target = stream->WriteString(2, s, target);
  }

  // repeated string not_in = 3;
  for (int i = 0, n = this_._internal_not_in_size(); i < n; ++i) {
    const auto& s = this_._internal_not_in().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "validate.AnyRules.not_in");
    target = stream->WriteString(3, s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.AnyRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AnyRules::ByteSizeLong(const MessageLite& base) {
  const AnyRules& this_ = static_cast<const AnyRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AnyRules::ByteSizeLong() const {
  const AnyRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.AnyRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated string in = 2;
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_in().size());
      for (int i = 0, n = this_._internal_in().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_in().Get(i));
      }
    }
    // repeated string not_in = 3;
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_not_in().size());
      for (int i = 0, n = this_._internal_not_in().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_not_in().Get(i));
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000001u & cached_has_bits) * 2;
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void AnyRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AnyRules*>(&to_msg);
  auto& from = static_cast<const AnyRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.AnyRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _this->_impl_.required_ = from._impl_.required_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AnyRules::CopyFrom(const AnyRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.AnyRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AnyRules::InternalSwap(AnyRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  swap(_impl_.required_, other->_impl_.required_);
}

::google::protobuf::Metadata AnyRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DurationRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DurationRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DurationRules, _impl_._has_bits_);
};

void DurationRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.const__ != nullptr) _impl_.const__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void DurationRules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lt_ != nullptr) _impl_.lt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void DurationRules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lte_ != nullptr) _impl_.lte_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void DurationRules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gt_ != nullptr) _impl_.gt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void DurationRules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gte_ != nullptr) _impl_.gte_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void DurationRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
void DurationRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
DurationRules::DurationRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DurationRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.DurationRules)
}
PROTOBUF_NDEBUG_INLINE DurationRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::DurationRules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_} {}

DurationRules::DurationRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DurationRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DurationRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DurationRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.const__ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.const__)
                : nullptr;
  _impl_.lt_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.lt_)
                : nullptr;
  _impl_.lte_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.lte_)
                : nullptr;
  _impl_.gt_ = ((cached_has_bits & 0x00000008u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.gt_)
                : nullptr;
  _impl_.gte_ = ((cached_has_bits & 0x00000010u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.gte_)
                : nullptr;
  _impl_.required_ = from._impl_.required_;

  // @@protoc_insertion_point(copy_constructor:validate.DurationRules)
}
PROTOBUF_NDEBUG_INLINE DurationRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena} {}

inline void DurationRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, required_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::required_));
}
DurationRules::~DurationRules() {
  // @@protoc_insertion_point(destructor:validate.DurationRules)
  SharedDtor(*this);
}
inline void DurationRules::SharedDtor(MessageLite& self) {
  DurationRules& this_ = static_cast<DurationRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.const__;
  delete this_._impl_.lt_;
  delete this_._impl_.lte_;
  delete this_._impl_.gt_;
  delete this_._impl_.gte_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DurationRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DurationRules(arena);
}
constexpr auto DurationRules::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.in_) +
          decltype(DurationRules::_impl_.in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.not_in_) +
          decltype(DurationRules::_impl_.not_in_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(DurationRules), alignof(DurationRules), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&DurationRules::PlacementNew_,
                                 sizeof(DurationRules),
                                 alignof(DurationRules));
  }
}
constexpr auto DurationRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DurationRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DurationRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DurationRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DurationRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DurationRules>(), &DurationRules::ByteSizeLong,
              &DurationRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DurationRules, _impl_._cached_size_),
          false,
      },
      &DurationRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DurationRules_class_data_ =
        DurationRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DurationRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DurationRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DurationRules_class_data_.tc_table);
  return DurationRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 7, 0, 2>
DurationRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DurationRules, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    DurationRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::DurationRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .google.protobuf.Duration not_in = 8;
    {::_pbi::TcParser::FastMtR1,
     {66, 63, 6, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.not_in_)}},
    // optional bool required = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DurationRules, _impl_.required_), 5>(),
     {8, 5, 0, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.required_)}},
    // optional .google.protobuf.Duration const = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.const__)}},
    // optional .google.protobuf.Duration lt = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.lt_)}},
    // optional .google.protobuf.Duration lte = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 2, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.lte_)}},
    // optional .google.protobuf.Duration gt = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 3, 3, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.gt_)}},
    // optional .google.protobuf.Duration gte = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 4, 4, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.gte_)}},
    // repeated .google.protobuf.Duration in = 7;
    {::_pbi::TcParser::FastMtR1,
     {58, 63, 5, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool required = 1;
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.required_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .google.protobuf.Duration const = 2;
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .google.protobuf.Duration lt = 3;
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .google.protobuf.Duration lte = 4;
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .google.protobuf.Duration gt = 5;
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .google.protobuf.Duration gte = 6;
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Duration in = 7;
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.in_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Duration not_in = 8;
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.not_in_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void DurationRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.DurationRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000001fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.const__ != nullptr);
      _impl_.const__->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.lt_ != nullptr);
      _impl_.lt_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.lte_ != nullptr);
      _impl_.lte_->Clear();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(_impl_.gt_ != nullptr);
      _impl_.gt_->Clear();
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      ABSL_DCHECK(_impl_.gte_ != nullptr);
      _impl_.gte_->Clear();
    }
  }
  _impl_.required_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DurationRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DurationRules& this_ = static_cast<const DurationRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DurationRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DurationRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.DurationRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool required = 1;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_required(), target);
  }

  // optional .google.protobuf.Duration const = 2;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.const__, this_._impl_.const__->GetCachedSize(), target,
        stream);
  }

  // optional .google.protobuf.Duration lt = 3;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.lt_, this_._impl_.lt_->GetCachedSize(), target,
        stream);
  }

  // optional .google.protobuf.Duration lte = 4;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.lte_, this_._impl_.lte_->GetCachedSize(), target,
        stream);
  }

  // optional .google.protobuf.Duration gt = 5;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.gt_, this_._impl_.gt_->GetCachedSize(), target,
        stream);
  }

  // optional .google.protobuf.Duration gte = 6;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, *this_._impl_.gte_, this_._impl_.gte_->GetCachedSize(), target,
        stream);
  }

  // repeated .google.protobuf.Duration in = 7;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_in_size());
       i < n; i++) {
    const auto& repfield = this_._internal_in().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            7, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  // repeated .google.protobuf.Duration not_in = 8;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_not_in_size());
       i < n; i++) {
    const auto& repfield = this_._internal_not_in().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            8, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.DurationRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DurationRules::ByteSizeLong(const MessageLite& base) {
  const DurationRules& this_ = static_cast<const DurationRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DurationRules::ByteSizeLong() const {
  const DurationRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.DurationRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Duration in = 7;
    {
      total_size += 1UL * this_._internal_in_size();
      for (const auto& msg : this_._internal_in()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .google.protobuf.Duration not_in = 8;
    {
      total_size += 1UL * this_._internal_not_in_size();
      for (const auto& msg : this_._internal_not_in()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000020u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000001fu) != 0) {
    // optional .google.protobuf.Duration const = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.const__);
    }
    // optional .google.protobuf.Duration lt = 3;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.lt_);
    }
    // optional .google.protobuf.Duration lte = 4;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.lte_);
    }
    // optional .google.protobuf.Duration gt = 5;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.gt_);
    }
    // optional .google.protobuf.Duration gte = 6;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.gte_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DurationRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<DurationRules*>(&to_msg);
  auto& from = static_cast<const DurationRules&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.DurationRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(
      from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(
      from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.const__ != nullptr);
      if (_this->_impl_.const__ == nullptr) {
        _this->_impl_.const__ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.const__);
      } else {
        _this->_impl_.const__->MergeFrom(*from._impl_.const__);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.lt_ != nullptr);
      if (_this->_impl_.lt_ == nullptr) {
        _this->_impl_.lt_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.lt_);
      } else {
        _this->_impl_.lt_->MergeFrom(*from._impl_.lt_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.lte_ != nullptr);
      if (_this->_impl_.lte_ == nullptr) {
        _this->_impl_.lte_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.lte_);
      } else {
        _this->_impl_.lte_->MergeFrom(*from._impl_.lte_);
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(from._impl_.gt_ != nullptr);
      if (_this->_impl_.gt_ == nullptr) {
        _this->_impl_.gt_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.gt_);
      } else {
        _this->_impl_.gt_->MergeFrom(*from._impl_.gt_);
      }
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      ABSL_DCHECK(from._impl_.gte_ != nullptr);
      if (_this->_impl_.gte_ == nullptr) {
        _this->_impl_.gte_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.gte_);
      } else {
        _this->_impl_.gte_->MergeFrom(*from._impl_.gte_);
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.required_ = from._impl_.required_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DurationRules::CopyFrom(const DurationRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.DurationRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DurationRules::InternalSwap(DurationRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.required_)
      + sizeof(DurationRules::_impl_.required_)
      - PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata DurationRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class TimestampRules::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<TimestampRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_._has_bits_);
};

void TimestampRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.const__ != nullptr) _impl_.const__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TimestampRules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lt_ != nullptr) _impl_.lt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TimestampRules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lte_ != nullptr) _impl_.lte_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void TimestampRules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gt_ != nullptr) _impl_.gt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void TimestampRules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gte_ != nullptr) _impl_.gte_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void TimestampRules::clear_within() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.within_ != nullptr) _impl_.within_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
TimestampRules::TimestampRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TimestampRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:validate.TimestampRules)
}
PROTOBUF_NDEBUG_INLINE TimestampRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::validate::TimestampRules& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

TimestampRules::TimestampRules(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const TimestampRules& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TimestampRules_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TimestampRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.const__ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.const__)
                : nullptr;
  _impl_.lt_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.lt_)
                : nullptr;
  _impl_.lte_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.lte_)
                : nullptr;
  _impl_.gt_ = ((cached_has_bits & 0x00000008u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.gt_)
                : nullptr;
  _impl_.gte_ = ((cached_has_bits & 0x00000010u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.gte_)
                : nullptr;
  _impl_.within_ = ((cached_has_bits & 0x00000020u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.within_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, required_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, required_),
           offsetof(Impl_, gt_now_) -
               offsetof(Impl_, required_) +
               sizeof(Impl_::gt_now_));

  // @@protoc_insertion_point(copy_constructor:validate.TimestampRules)
}
PROTOBUF_NDEBUG_INLINE TimestampRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void TimestampRules::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, gt_now_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::gt_now_));
}
TimestampRules::~TimestampRules() {
  // @@protoc_insertion_point(destructor:validate.TimestampRules)
  SharedDtor(*this);
}
inline void TimestampRules::SharedDtor(MessageLite& self) {
  TimestampRules& this_ = static_cast<TimestampRules&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.const__;
  delete this_._impl_.lt_;
  delete this_._impl_.lte_;
  delete this_._impl_.gt_;
  delete this_._impl_.gte_;
  delete this_._impl_.within_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL TimestampRules::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) TimestampRules(arena);
}
constexpr auto TimestampRules::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(TimestampRules),
                                            alignof(TimestampRules));
}
constexpr auto TimestampRules::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_TimestampRules_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &TimestampRules::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<TimestampRules>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &TimestampRules::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<TimestampRules>(), &TimestampRules::ByteSizeLong,
              &TimestampRules::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_._cached_size_),
          false,
      },
      &TimestampRules::kDescriptorMethods,
      &descriptor_table_validate_2fvalidate_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull TimestampRules_class_data_ =
        TimestampRules::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
TimestampRules::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&TimestampRules_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(TimestampRules_class_data_.tc_table);
  return TimestampRules_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 6, 0, 2>
TimestampRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    TimestampRules_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::validate::TimestampRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool required = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(TimestampRules, _impl_.required_), 6>(),
     {8, 6, 0, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.required_)}},
    // optional .google.protobuf.Timestamp const = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.const__)}},
    // optional .google.protobuf.Timestamp lt = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.lt_)}},
    // optional .google.protobuf.Timestamp lte = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 2, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.lte_)}},
    // optional .google.protobuf.Timestamp gt = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 3, 3, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.gt_)}},
    // optional .google.protobuf.Timestamp gte = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 4, 4, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.gte_)}},
    // optional bool lt_now = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(TimestampRules, _impl_.lt_now_), 7>(),
     {56, 7, 0, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.lt_now_)}},
    // optional bool gt_now = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(TimestampRules, _impl_.gt_now_), 8>(),
     {64, 8, 0, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.gt_now_)}},
    // optional .google.protobuf.Duration within = 9;
    {::_pbi::TcParser::FastMtS1,
     {74, 5, 5, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.within_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool required = 1;
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.required_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .google.protobuf.Timestamp const = 2;
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .google.protobuf.Timestamp lt = 3;
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.lt_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .google.protobuf.Timestamp lte = 4;
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.lte_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .google.protobuf.Timestamp gt = 5;
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.gt_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .google.protobuf.Timestamp gte = 6;
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.gte_), _Internal::kHasBitsOffset + 4, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool lt_now = 7;
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.lt_now_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool gt_now = 8;
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.gt_now_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .google.protobuf.Duration within = 9;
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.within_), _Internal::kHasBitsOffset + 5, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void TimestampRules::Clear() {
// @@protoc_insertion_point(message_clear_start:validate.TimestampRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.const__ != nullptr);
      _impl_.const__->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.lt_ != nullptr);
      _impl_.lt_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.lte_ != nullptr);
      _impl_.lte_->Clear();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(_impl_.gt_ != nullptr);
      _impl_.gt_->Clear();
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      ABSL_DCHECK(_impl_.gte_ != nullptr);
      _impl_.gte_->Clear();
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      ABSL_DCHECK(_impl_.within_ != nullptr);
      _impl_.within_->Clear();
    }
  }
  ::memset(&_impl_.required_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.lt_now_) -
      reinterpret_cast<char*>(&_impl_.required_)) + sizeof(_impl_.lt_now_));
  _impl_.gt_now_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL TimestampRules::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const TimestampRules& this_ = static_cast<const TimestampRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL TimestampRules::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const TimestampRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:validate.TimestampRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool required = 1;
  if ((cached_has_bits & 0x00000040u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_required(), target);
  }

  // optional .google.protobuf.Timestamp const = 2;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.const__, this_._impl_.const__->GetCachedSize(), target,
        stream);
  }

  // optional .google.protobuf.Timestamp lt = 3;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.lt_, this_._impl_.lt_->GetCachedSize(), target,
        stream);
  }

  // optional .google.protobuf.Timestamp lte = 4;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.lte_, this_._impl_.lte_->GetCachedSize(), target,
        stream);
  }

  // optional .google.protobuf.Timestamp gt = 5;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.gt_, this_._impl_.gt_->GetCachedSize(), target,
        stream);
  }

  // optional .google.protobuf.Timestamp gte = 6;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, *this_._impl_.gte_, this_._impl_.gte_->GetCachedSize(), target,
        stream);
  }

  // optional bool lt_now = 7;
  if ((cached_has_bits & 0x00000080u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this_._internal_lt_now(), target);
  }

  // optional bool gt_now = 8;
  if ((cached_has_bits & 0x00000100u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_gt_now(), target);
  }

  // optional .google.protobuf.Duration within = 9;
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        9, *this_._impl_.within_, this_._impl_.within_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:validate.TimestampRules)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t TimestampRules::ByteSizeLong(const MessageLite& base) {
  const TimestampRules& this_ = static_cast<const TimestampRules&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t TimestampRules::ByteSizeLong() const {
  const TimestampRules& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:validate.TimestampRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x000001c0u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x0000003fu) != 0) {
    // optional .google.protobuf.Timestamp const = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.const__);
    }
    // optional .google.protobuf.Timestamp lt = 3;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.lt_);
    }
    // optional .google.protobuf.Timestamp lte = 4;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.lte_);
    }
    // optional .google.protobuf.Timestamp gt = 5;
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.gt_);
    }
    // optional .google.protobuf.Timestamp gte = 6;
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.gte_);
    }
    // optional .google.protobuf.Duration within = 9;
    if ((cached_has_bits & 0x00000020u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.within_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void TimestampRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TimestampRules*>(&to_msg);
  auto& from = static_cast<const TimestampRules&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:validate.TimestampRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.const__ != nullptr);
      if (_this->_impl_.const__ == nullptr) {
        _this->_impl_.const__ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.const__);
      } else {
        _this->_impl_.const__->MergeFrom(*from._impl_.const__);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.lt_ != nullptr);
      if (_this->_impl_.lt_ == nullptr) {
        _this->_impl_.lt_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.lt_);
      } else {
        _this->_impl_.lt_->MergeFrom(*from._impl_.lt_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.lte_ != nullptr);
      if (_this->_impl_.lte_ == nullptr) {
        _this->_impl_.lte_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.lte_);
      } else {
        _this->_impl_.lte_->MergeFrom(*from._impl_.lte_);
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(from._impl_.gt_ != nullptr);
      if (_this->_impl_.gt_ == nullptr) {
        _this->_impl_.gt_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.gt_);
      } else {
        _this->_impl_.gt_->MergeFrom(*from._impl_.gt_);
      }
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      ABSL_DCHECK(from._impl_.gte_ != nullptr);
      if (_this->_impl_.gte_ == nullptr) {
        _this->_impl_.gte_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.gte_);
      } else {
        _this->_impl_.gte_->MergeFrom(*from._impl_.gte_);
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      ABSL_DCHECK(from._impl_.within_ != nullptr);
      if (_this->_impl_.within_ == nullptr) {
        _this->_impl_.within_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.within_);
      } else {
        _this->_impl_.within_->MergeFrom(*from._impl_.within_);
      }
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _this->_impl_.required_ = from._impl_.required_;
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      _this->_impl_.lt_now_ = from._impl_.lt_now_;
    }
  }
  if ((cached_has_bits & 0x00000100u) != 0) {
    _this->_impl_.gt_now_ = from._impl_.gt_now_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TimestampRules::CopyFrom(const TimestampRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:validate.TimestampRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TimestampRules::InternalSwap(TimestampRules* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.gt_now_)
      + sizeof(TimestampRules::_impl_.gt_now_)
      - PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata TimestampRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::_pbi::ExtensionIdentifier<
        ::google::protobuf::MessageOptions, ::_pbi::PrimitiveTypeTraits< bool >, 8, false>
        disabled(kDisabledFieldNumber, false);
PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::_pbi::ExtensionIdentifier<
        ::google::protobuf::MessageOptions, ::_pbi::PrimitiveTypeTraits< bool >, 8, false>
        ignored(kIgnoredFieldNumber, false);
PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::_pbi::ExtensionIdentifier<
        ::google::protobuf::OneofOptions, ::_pbi::PrimitiveTypeTraits< bool >, 8, false>
        required(kRequiredFieldNumber, false);
PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::_pbi::ExtensionIdentifier<
        ::google::protobuf::FieldOptions, ::_pbi::MessageTypeTraits< ::validate::FieldRules >, 11, false>
        rules(kRulesFieldNumber, &::validate::_FieldRules_default_instance_);
// @@protoc_insertion_point(namespace_scope)
}  // namespace validate
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ [[maybe_unused]] =
        (::_pbi::AddDescriptors(&descriptor_table_validate_2fvalidate_2eproto),
        ::_pbi::ExtensionSet::RegisterExtension(
            &::google::protobuf::MessageOptions::default_instance(), 1071, 8,
            false, false),
        ::_pbi::ExtensionSet::RegisterExtension(
            &::google::protobuf::MessageOptions::default_instance(), 1072, 8,
            false, false),
        ::_pbi::ExtensionSet::RegisterExtension(
            &::google::protobuf::OneofOptions::default_instance(), 1071, 8,
            false, false),
        ::_pbi::ExtensionSet::RegisterMessageExtension(
            &::google::protobuf::FieldOptions::default_instance(), 1071, 11,
            false, false, &::validate::FieldRules::default_instance(),
            nullptr, ::_pbi::LazyAnnotation::kUndefined),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
