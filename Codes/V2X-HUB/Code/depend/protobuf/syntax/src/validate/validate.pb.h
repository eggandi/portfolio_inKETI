// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: validate/validate.proto
// Protobuf C++ Version: 6.31.1

#ifndef validate_2fvalidate_2eproto_2epb_2eh
#define validate_2fvalidate_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/descriptor.pb.h"
#include "google/protobuf/duration.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_validate_2fvalidate_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_validate_2fvalidate_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_validate_2fvalidate_2eproto;
}  // extern "C"
namespace validate {
enum KnownRegex : int;
extern const uint32_t KnownRegex_internal_data_[];
class AnyRules;
struct AnyRulesDefaultTypeInternal;
extern AnyRulesDefaultTypeInternal _AnyRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AnyRules_class_data_;
class BoolRules;
struct BoolRulesDefaultTypeInternal;
extern BoolRulesDefaultTypeInternal _BoolRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BoolRules_class_data_;
class BytesRules;
struct BytesRulesDefaultTypeInternal;
extern BytesRulesDefaultTypeInternal _BytesRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BytesRules_class_data_;
class DoubleRules;
struct DoubleRulesDefaultTypeInternal;
extern DoubleRulesDefaultTypeInternal _DoubleRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DoubleRules_class_data_;
class DurationRules;
struct DurationRulesDefaultTypeInternal;
extern DurationRulesDefaultTypeInternal _DurationRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DurationRules_class_data_;
class EnumRules;
struct EnumRulesDefaultTypeInternal;
extern EnumRulesDefaultTypeInternal _EnumRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EnumRules_class_data_;
class FieldRules;
struct FieldRulesDefaultTypeInternal;
extern FieldRulesDefaultTypeInternal _FieldRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FieldRules_class_data_;
class Fixed32Rules;
struct Fixed32RulesDefaultTypeInternal;
extern Fixed32RulesDefaultTypeInternal _Fixed32Rules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Fixed32Rules_class_data_;
class Fixed64Rules;
struct Fixed64RulesDefaultTypeInternal;
extern Fixed64RulesDefaultTypeInternal _Fixed64Rules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Fixed64Rules_class_data_;
class FloatRules;
struct FloatRulesDefaultTypeInternal;
extern FloatRulesDefaultTypeInternal _FloatRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FloatRules_class_data_;
class Int32Rules;
struct Int32RulesDefaultTypeInternal;
extern Int32RulesDefaultTypeInternal _Int32Rules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Int32Rules_class_data_;
class Int64Rules;
struct Int64RulesDefaultTypeInternal;
extern Int64RulesDefaultTypeInternal _Int64Rules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Int64Rules_class_data_;
class MapRules;
struct MapRulesDefaultTypeInternal;
extern MapRulesDefaultTypeInternal _MapRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MapRules_class_data_;
class MessageRules;
struct MessageRulesDefaultTypeInternal;
extern MessageRulesDefaultTypeInternal _MessageRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MessageRules_class_data_;
class RepeatedRules;
struct RepeatedRulesDefaultTypeInternal;
extern RepeatedRulesDefaultTypeInternal _RepeatedRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RepeatedRules_class_data_;
class SFixed32Rules;
struct SFixed32RulesDefaultTypeInternal;
extern SFixed32RulesDefaultTypeInternal _SFixed32Rules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SFixed32Rules_class_data_;
class SFixed64Rules;
struct SFixed64RulesDefaultTypeInternal;
extern SFixed64RulesDefaultTypeInternal _SFixed64Rules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SFixed64Rules_class_data_;
class SInt32Rules;
struct SInt32RulesDefaultTypeInternal;
extern SInt32RulesDefaultTypeInternal _SInt32Rules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SInt32Rules_class_data_;
class SInt64Rules;
struct SInt64RulesDefaultTypeInternal;
extern SInt64RulesDefaultTypeInternal _SInt64Rules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SInt64Rules_class_data_;
class StringRules;
struct StringRulesDefaultTypeInternal;
extern StringRulesDefaultTypeInternal _StringRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StringRules_class_data_;
class TimestampRules;
struct TimestampRulesDefaultTypeInternal;
extern TimestampRulesDefaultTypeInternal _TimestampRules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TimestampRules_class_data_;
class UInt32Rules;
struct UInt32RulesDefaultTypeInternal;
extern UInt32RulesDefaultTypeInternal _UInt32Rules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UInt32Rules_class_data_;
class UInt64Rules;
struct UInt64RulesDefaultTypeInternal;
extern UInt64RulesDefaultTypeInternal _UInt64Rules_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UInt64Rules_class_data_;
}  // namespace validate
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::validate::KnownRegex_internal_data_>
    internal::EnumTraitsImpl::value<::validate::KnownRegex>;
}  // namespace protobuf
}  // namespace google

namespace validate {
enum KnownRegex : int {
  UNKNOWN = 0,
  HTTP_HEADER_NAME = 1,
  HTTP_HEADER_VALUE = 2,
};

extern const uint32_t KnownRegex_internal_data_[];
inline constexpr KnownRegex KnownRegex_MIN =
    static_cast<KnownRegex>(0);
inline constexpr KnownRegex KnownRegex_MAX =
    static_cast<KnownRegex>(2);
inline bool KnownRegex_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int KnownRegex_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL KnownRegex_descriptor();
template <typename T>
const ::std::string& KnownRegex_Name(T value) {
  static_assert(::std::is_same<T, KnownRegex>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to KnownRegex_Name().");
  return KnownRegex_Name(static_cast<KnownRegex>(value));
}
template <>
inline const ::std::string& KnownRegex_Name(KnownRegex value) {
  return ::google::protobuf::internal::NameOfDenseEnum<KnownRegex_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool KnownRegex_Parse(
    ::absl::string_view name, KnownRegex* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<KnownRegex>(KnownRegex_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class UInt64Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.UInt64Rules) */ {
 public:
  inline UInt64Rules() : UInt64Rules(nullptr) {}
  ~UInt64Rules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UInt64Rules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UInt64Rules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UInt64Rules(::google::protobuf::internal::ConstantInitialized);

  inline UInt64Rules(const UInt64Rules& from) : UInt64Rules(nullptr, from) {}
  inline UInt64Rules(UInt64Rules&& from) noexcept
      : UInt64Rules(nullptr, ::std::move(from)) {}
  inline UInt64Rules& operator=(const UInt64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline UInt64Rules& operator=(UInt64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UInt64Rules& default_instance() {
    return *reinterpret_cast<const UInt64Rules*>(
        &_UInt64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(UInt64Rules& a, UInt64Rules& b) { a.Swap(&b); }
  inline void Swap(UInt64Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UInt64Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UInt64Rules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UInt64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UInt64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UInt64Rules& from) { UInt64Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UInt64Rules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.UInt64Rules"; }

 protected:
  explicit UInt64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UInt64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UInt64Rules& from);
  UInt64Rules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UInt64Rules&& from) noexcept
      : UInt64Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
    kIgnoreEmptyFieldNumber = 8,
  };
  // repeated uint64 in = 6;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::uint64_t in(int index) const;
  void set_in(int index, ::uint64_t value);
  void add_in(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated uint64 not_in = 7;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::uint64_t not_in(int index) const;
  void set_not_in(int index, ::uint64_t value);
  void add_not_in(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional uint64 const = 1;
  bool has_const_() const;
  void clear_const_() ;
  ::uint64_t const_() const;
  void set_const_(::uint64_t value);

  private:
  ::uint64_t _internal_const_() const;
  void _internal_set_const_(::uint64_t value);

  public:
  // optional uint64 lt = 2;
  bool has_lt() const;
  void clear_lt() ;
  ::uint64_t lt() const;
  void set_lt(::uint64_t value);

  private:
  ::uint64_t _internal_lt() const;
  void _internal_set_lt(::uint64_t value);

  public:
  // optional uint64 lte = 3;
  bool has_lte() const;
  void clear_lte() ;
  ::uint64_t lte() const;
  void set_lte(::uint64_t value);

  private:
  ::uint64_t _internal_lte() const;
  void _internal_set_lte(::uint64_t value);

  public:
  // optional uint64 gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  ::uint64_t gt() const;
  void set_gt(::uint64_t value);

  private:
  ::uint64_t _internal_gt() const;
  void _internal_set_gt(::uint64_t value);

  public:
  // optional uint64 gte = 5;
  bool has_gte() const;
  void clear_gte() ;
  ::uint64_t gte() const;
  void set_gte(::uint64_t value);

  private:
  ::uint64_t _internal_gte() const;
  void _internal_set_gte(::uint64_t value);

  public:
  // optional bool ignore_empty = 8;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.UInt64Rules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UInt64Rules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> in_;
    ::google::protobuf::RepeatedField<::uint64_t> not_in_;
    ::uint64_t const__;
    ::uint64_t lt_;
    ::uint64_t lte_;
    ::uint64_t gt_;
    ::uint64_t gte_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UInt64Rules_class_data_;
// -------------------------------------------------------------------

class UInt32Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.UInt32Rules) */ {
 public:
  inline UInt32Rules() : UInt32Rules(nullptr) {}
  ~UInt32Rules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UInt32Rules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UInt32Rules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UInt32Rules(::google::protobuf::internal::ConstantInitialized);

  inline UInt32Rules(const UInt32Rules& from) : UInt32Rules(nullptr, from) {}
  inline UInt32Rules(UInt32Rules&& from) noexcept
      : UInt32Rules(nullptr, ::std::move(from)) {}
  inline UInt32Rules& operator=(const UInt32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline UInt32Rules& operator=(UInt32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UInt32Rules& default_instance() {
    return *reinterpret_cast<const UInt32Rules*>(
        &_UInt32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(UInt32Rules& a, UInt32Rules& b) { a.Swap(&b); }
  inline void Swap(UInt32Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UInt32Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UInt32Rules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UInt32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UInt32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UInt32Rules& from) { UInt32Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UInt32Rules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.UInt32Rules"; }

 protected:
  explicit UInt32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UInt32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UInt32Rules& from);
  UInt32Rules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UInt32Rules&& from) noexcept
      : UInt32Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
    kIgnoreEmptyFieldNumber = 8,
  };
  // repeated uint32 in = 6;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::uint32_t in(int index) const;
  void set_in(int index, ::uint32_t value);
  void add_in(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated uint32 not_in = 7;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::uint32_t not_in(int index) const;
  void set_not_in(int index, ::uint32_t value);
  void add_not_in(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional uint32 const = 1;
  bool has_const_() const;
  void clear_const_() ;
  ::uint32_t const_() const;
  void set_const_(::uint32_t value);

  private:
  ::uint32_t _internal_const_() const;
  void _internal_set_const_(::uint32_t value);

  public:
  // optional uint32 lt = 2;
  bool has_lt() const;
  void clear_lt() ;
  ::uint32_t lt() const;
  void set_lt(::uint32_t value);

  private:
  ::uint32_t _internal_lt() const;
  void _internal_set_lt(::uint32_t value);

  public:
  // optional uint32 lte = 3;
  bool has_lte() const;
  void clear_lte() ;
  ::uint32_t lte() const;
  void set_lte(::uint32_t value);

  private:
  ::uint32_t _internal_lte() const;
  void _internal_set_lte(::uint32_t value);

  public:
  // optional uint32 gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  ::uint32_t gt() const;
  void set_gt(::uint32_t value);

  private:
  ::uint32_t _internal_gt() const;
  void _internal_set_gt(::uint32_t value);

  public:
  // optional uint32 gte = 5;
  bool has_gte() const;
  void clear_gte() ;
  ::uint32_t gte() const;
  void set_gte(::uint32_t value);

  private:
  ::uint32_t _internal_gte() const;
  void _internal_set_gte(::uint32_t value);

  public:
  // optional bool ignore_empty = 8;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.UInt32Rules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UInt32Rules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> in_;
    ::google::protobuf::RepeatedField<::uint32_t> not_in_;
    ::uint32_t const__;
    ::uint32_t lt_;
    ::uint32_t lte_;
    ::uint32_t gt_;
    ::uint32_t gte_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UInt32Rules_class_data_;
// -------------------------------------------------------------------

class StringRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.StringRules) */ {
 public:
  inline StringRules() : StringRules(nullptr) {}
  ~StringRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StringRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StringRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StringRules(::google::protobuf::internal::ConstantInitialized);

  inline StringRules(const StringRules& from) : StringRules(nullptr, from) {}
  inline StringRules(StringRules&& from) noexcept
      : StringRules(nullptr, ::std::move(from)) {}
  inline StringRules& operator=(const StringRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringRules& operator=(StringRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringRules& default_instance() {
    return *reinterpret_cast<const StringRules*>(
        &_StringRules_default_instance_);
  }
  enum WellKnownCase {
    kEmail = 12,
    kHostname = 13,
    kIp = 14,
    kIpv4 = 15,
    kIpv6 = 16,
    kUri = 17,
    kUriRef = 18,
    kAddress = 21,
    kUuid = 22,
    kWellKnownRegex = 24,
    WELL_KNOWN_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(StringRules& a, StringRules& b) { a.Swap(&b); }
  inline void Swap(StringRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StringRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StringRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StringRules& from) { StringRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StringRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.StringRules"; }

 protected:
  explicit StringRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StringRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StringRules& from);
  StringRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StringRules&& from) noexcept
      : StringRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 10,
    kNotInFieldNumber = 11,
    kConstFieldNumber = 1,
    kPatternFieldNumber = 6,
    kPrefixFieldNumber = 7,
    kSuffixFieldNumber = 8,
    kContainsFieldNumber = 9,
    kNotContainsFieldNumber = 23,
    kMinLenFieldNumber = 2,
    kMaxLenFieldNumber = 3,
    kMinBytesFieldNumber = 4,
    kMaxBytesFieldNumber = 5,
    kLenFieldNumber = 19,
    kLenBytesFieldNumber = 20,
    kIgnoreEmptyFieldNumber = 26,
    kStrictFieldNumber = 25,
    kEmailFieldNumber = 12,
    kHostnameFieldNumber = 13,
    kIpFieldNumber = 14,
    kIpv4FieldNumber = 15,
    kIpv6FieldNumber = 16,
    kUriFieldNumber = 17,
    kUriRefFieldNumber = 18,
    kAddressFieldNumber = 21,
    kUuidFieldNumber = 22,
    kWellKnownRegexFieldNumber = 24,
  };
  // repeated string in = 10;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  const ::std::string& in(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_in(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_in(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_in();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_in(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated string not_in = 11;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  const ::std::string& not_in(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_not_in(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_not_in(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_not_in();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_not_in(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_not_in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional string const = 1;
  bool has_const_() const;
  void clear_const_() ;
  const ::std::string& const_() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_const_(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_const_();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_const_();
  void set_allocated_const_(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_const_() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_const_(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_const_();

  public:
  // optional string pattern = 6;
  bool has_pattern() const;
  void clear_pattern() ;
  const ::std::string& pattern() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_pattern(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_pattern();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_pattern();
  void set_allocated_pattern(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_pattern() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_pattern();

  public:
  // optional string prefix = 7;
  bool has_prefix() const;
  void clear_prefix() ;
  const ::std::string& prefix() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_prefix(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_prefix();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_prefix();
  void set_allocated_prefix(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_prefix() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_prefix();

  public:
  // optional string suffix = 8;
  bool has_suffix() const;
  void clear_suffix() ;
  const ::std::string& suffix() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_suffix(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_suffix();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_suffix();
  void set_allocated_suffix(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_suffix() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_suffix(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_suffix();

  public:
  // optional string contains = 9;
  bool has_contains() const;
  void clear_contains() ;
  const ::std::string& contains() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_contains(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_contains();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_contains();
  void set_allocated_contains(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_contains() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_contains(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_contains();

  public:
  // optional string not_contains = 23;
  bool has_not_contains() const;
  void clear_not_contains() ;
  const ::std::string& not_contains() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_not_contains(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_not_contains();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_not_contains();
  void set_allocated_not_contains(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_not_contains() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_not_contains(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_not_contains();

  public:
  // optional uint64 min_len = 2;
  bool has_min_len() const;
  void clear_min_len() ;
  ::uint64_t min_len() const;
  void set_min_len(::uint64_t value);

  private:
  ::uint64_t _internal_min_len() const;
  void _internal_set_min_len(::uint64_t value);

  public:
  // optional uint64 max_len = 3;
  bool has_max_len() const;
  void clear_max_len() ;
  ::uint64_t max_len() const;
  void set_max_len(::uint64_t value);

  private:
  ::uint64_t _internal_max_len() const;
  void _internal_set_max_len(::uint64_t value);

  public:
  // optional uint64 min_bytes = 4;
  bool has_min_bytes() const;
  void clear_min_bytes() ;
  ::uint64_t min_bytes() const;
  void set_min_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_min_bytes() const;
  void _internal_set_min_bytes(::uint64_t value);

  public:
  // optional uint64 max_bytes = 5;
  bool has_max_bytes() const;
  void clear_max_bytes() ;
  ::uint64_t max_bytes() const;
  void set_max_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_max_bytes() const;
  void _internal_set_max_bytes(::uint64_t value);

  public:
  // optional uint64 len = 19;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // optional uint64 len_bytes = 20;
  bool has_len_bytes() const;
  void clear_len_bytes() ;
  ::uint64_t len_bytes() const;
  void set_len_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_len_bytes() const;
  void _internal_set_len_bytes(::uint64_t value);

  public:
  // optional bool ignore_empty = 26;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // optional bool strict = 25 [default = true];
  bool has_strict() const;
  void clear_strict() ;
  bool strict() const;
  void set_strict(bool value);

  private:
  bool _internal_strict() const;
  void _internal_set_strict(bool value);

  public:
  // bool email = 12;
  bool has_email() const;
  void clear_email() ;
  bool email() const;
  void set_email(bool value);

  private:
  bool _internal_email() const;
  void _internal_set_email(bool value);

  public:
  // bool hostname = 13;
  bool has_hostname() const;
  void clear_hostname() ;
  bool hostname() const;
  void set_hostname(bool value);

  private:
  bool _internal_hostname() const;
  void _internal_set_hostname(bool value);

  public:
  // bool ip = 14;
  bool has_ip() const;
  void clear_ip() ;
  bool ip() const;
  void set_ip(bool value);

  private:
  bool _internal_ip() const;
  void _internal_set_ip(bool value);

  public:
  // bool ipv4 = 15;
  bool has_ipv4() const;
  void clear_ipv4() ;
  bool ipv4() const;
  void set_ipv4(bool value);

  private:
  bool _internal_ipv4() const;
  void _internal_set_ipv4(bool value);

  public:
  // bool ipv6 = 16;
  bool has_ipv6() const;
  void clear_ipv6() ;
  bool ipv6() const;
  void set_ipv6(bool value);

  private:
  bool _internal_ipv6() const;
  void _internal_set_ipv6(bool value);

  public:
  // bool uri = 17;
  bool has_uri() const;
  void clear_uri() ;
  bool uri() const;
  void set_uri(bool value);

  private:
  bool _internal_uri() const;
  void _internal_set_uri(bool value);

  public:
  // bool uri_ref = 18;
  bool has_uri_ref() const;
  void clear_uri_ref() ;
  bool uri_ref() const;
  void set_uri_ref(bool value);

  private:
  bool _internal_uri_ref() const;
  void _internal_set_uri_ref(bool value);

  public:
  // bool address = 21;
  bool has_address() const;
  void clear_address() ;
  bool address() const;
  void set_address(bool value);

  private:
  bool _internal_address() const;
  void _internal_set_address(bool value);

  public:
  // bool uuid = 22;
  bool has_uuid() const;
  void clear_uuid() ;
  bool uuid() const;
  void set_uuid(bool value);

  private:
  bool _internal_uuid() const;
  void _internal_set_uuid(bool value);

  public:
  // .validate.KnownRegex well_known_regex = 24;
  bool has_well_known_regex() const;
  void clear_well_known_regex() ;
  ::validate::KnownRegex well_known_regex() const;
  void set_well_known_regex(::validate::KnownRegex value);

  private:
  ::validate::KnownRegex _internal_well_known_regex() const;
  void _internal_set_well_known_regex(::validate::KnownRegex value);

  public:
  void clear_well_known();
  WellKnownCase well_known_case() const;
  // @@protoc_insertion_point(class_scope:validate.StringRules)
 private:
  class _Internal;
  void set_has_email();
  void set_has_hostname();
  void set_has_ip();
  void set_has_ipv4();
  void set_has_ipv6();
  void set_has_uri();
  void set_has_uri_ref();
  void set_has_address();
  void set_has_uuid();
  void set_has_well_known_regex();
  inline bool has_well_known() const;
  inline void clear_has_well_known();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 26,
                                   1, 105,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StringRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> in_;
    ::google::protobuf::RepeatedPtrField<::std::string> not_in_;
    ::google::protobuf::internal::ArenaStringPtr const__;
    ::google::protobuf::internal::ArenaStringPtr pattern_;
    ::google::protobuf::internal::ArenaStringPtr prefix_;
    ::google::protobuf::internal::ArenaStringPtr suffix_;
    ::google::protobuf::internal::ArenaStringPtr contains_;
    ::google::protobuf::internal::ArenaStringPtr not_contains_;
    ::uint64_t min_len_;
    ::uint64_t max_len_;
    ::uint64_t min_bytes_;
    ::uint64_t max_bytes_;
    ::uint64_t len_;
    ::uint64_t len_bytes_;
    bool ignore_empty_;
    bool strict_;
    union WellKnownUnion {
      constexpr WellKnownUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool email_;
      bool hostname_;
      bool ip_;
      bool ipv4_;
      bool ipv6_;
      bool uri_;
      bool uri_ref_;
      bool address_;
      bool uuid_;
      int well_known_regex_;
    } well_known_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StringRules_class_data_;
// -------------------------------------------------------------------

class SInt64Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.SInt64Rules) */ {
 public:
  inline SInt64Rules() : SInt64Rules(nullptr) {}
  ~SInt64Rules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SInt64Rules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SInt64Rules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SInt64Rules(::google::protobuf::internal::ConstantInitialized);

  inline SInt64Rules(const SInt64Rules& from) : SInt64Rules(nullptr, from) {}
  inline SInt64Rules(SInt64Rules&& from) noexcept
      : SInt64Rules(nullptr, ::std::move(from)) {}
  inline SInt64Rules& operator=(const SInt64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline SInt64Rules& operator=(SInt64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SInt64Rules& default_instance() {
    return *reinterpret_cast<const SInt64Rules*>(
        &_SInt64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(SInt64Rules& a, SInt64Rules& b) { a.Swap(&b); }
  inline void Swap(SInt64Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SInt64Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SInt64Rules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SInt64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SInt64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SInt64Rules& from) { SInt64Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SInt64Rules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.SInt64Rules"; }

 protected:
  explicit SInt64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SInt64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SInt64Rules& from);
  SInt64Rules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SInt64Rules&& from) noexcept
      : SInt64Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
    kIgnoreEmptyFieldNumber = 8,
  };
  // repeated sint64 in = 6;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int64_t in(int index) const;
  void set_in(int index, ::int64_t value);
  void add_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& in() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated sint64 not_in = 7;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int64_t not_in(int index) const;
  void set_not_in(int index, ::int64_t value);
  void add_not_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional sint64 const = 1;
  bool has_const_() const;
  void clear_const_() ;
  ::int64_t const_() const;
  void set_const_(::int64_t value);

  private:
  ::int64_t _internal_const_() const;
  void _internal_set_const_(::int64_t value);

  public:
  // optional sint64 lt = 2;
  bool has_lt() const;
  void clear_lt() ;
  ::int64_t lt() const;
  void set_lt(::int64_t value);

  private:
  ::int64_t _internal_lt() const;
  void _internal_set_lt(::int64_t value);

  public:
  // optional sint64 lte = 3;
  bool has_lte() const;
  void clear_lte() ;
  ::int64_t lte() const;
  void set_lte(::int64_t value);

  private:
  ::int64_t _internal_lte() const;
  void _internal_set_lte(::int64_t value);

  public:
  // optional sint64 gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  ::int64_t gt() const;
  void set_gt(::int64_t value);

  private:
  ::int64_t _internal_gt() const;
  void _internal_set_gt(::int64_t value);

  public:
  // optional sint64 gte = 5;
  bool has_gte() const;
  void clear_gte() ;
  ::int64_t gte() const;
  void set_gte(::int64_t value);

  private:
  ::int64_t _internal_gte() const;
  void _internal_set_gte(::int64_t value);

  public:
  // optional bool ignore_empty = 8;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.SInt64Rules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SInt64Rules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> in_;
    ::google::protobuf::RepeatedField<::int64_t> not_in_;
    ::int64_t const__;
    ::int64_t lt_;
    ::int64_t lte_;
    ::int64_t gt_;
    ::int64_t gte_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SInt64Rules_class_data_;
// -------------------------------------------------------------------

class SInt32Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.SInt32Rules) */ {
 public:
  inline SInt32Rules() : SInt32Rules(nullptr) {}
  ~SInt32Rules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SInt32Rules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SInt32Rules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SInt32Rules(::google::protobuf::internal::ConstantInitialized);

  inline SInt32Rules(const SInt32Rules& from) : SInt32Rules(nullptr, from) {}
  inline SInt32Rules(SInt32Rules&& from) noexcept
      : SInt32Rules(nullptr, ::std::move(from)) {}
  inline SInt32Rules& operator=(const SInt32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline SInt32Rules& operator=(SInt32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SInt32Rules& default_instance() {
    return *reinterpret_cast<const SInt32Rules*>(
        &_SInt32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(SInt32Rules& a, SInt32Rules& b) { a.Swap(&b); }
  inline void Swap(SInt32Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SInt32Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SInt32Rules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SInt32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SInt32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SInt32Rules& from) { SInt32Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SInt32Rules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.SInt32Rules"; }

 protected:
  explicit SInt32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SInt32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SInt32Rules& from);
  SInt32Rules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SInt32Rules&& from) noexcept
      : SInt32Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
    kIgnoreEmptyFieldNumber = 8,
  };
  // repeated sint32 in = 6;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int32_t in(int index) const;
  void set_in(int index, ::int32_t value);
  void add_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated sint32 not_in = 7;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int32_t not_in(int index) const;
  void set_not_in(int index, ::int32_t value);
  void add_not_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional sint32 const = 1;
  bool has_const_() const;
  void clear_const_() ;
  ::int32_t const_() const;
  void set_const_(::int32_t value);

  private:
  ::int32_t _internal_const_() const;
  void _internal_set_const_(::int32_t value);

  public:
  // optional sint32 lt = 2;
  bool has_lt() const;
  void clear_lt() ;
  ::int32_t lt() const;
  void set_lt(::int32_t value);

  private:
  ::int32_t _internal_lt() const;
  void _internal_set_lt(::int32_t value);

  public:
  // optional sint32 lte = 3;
  bool has_lte() const;
  void clear_lte() ;
  ::int32_t lte() const;
  void set_lte(::int32_t value);

  private:
  ::int32_t _internal_lte() const;
  void _internal_set_lte(::int32_t value);

  public:
  // optional sint32 gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  ::int32_t gt() const;
  void set_gt(::int32_t value);

  private:
  ::int32_t _internal_gt() const;
  void _internal_set_gt(::int32_t value);

  public:
  // optional sint32 gte = 5;
  bool has_gte() const;
  void clear_gte() ;
  ::int32_t gte() const;
  void set_gte(::int32_t value);

  private:
  ::int32_t _internal_gte() const;
  void _internal_set_gte(::int32_t value);

  public:
  // optional bool ignore_empty = 8;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.SInt32Rules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SInt32Rules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> in_;
    ::google::protobuf::RepeatedField<::int32_t> not_in_;
    ::int32_t const__;
    ::int32_t lt_;
    ::int32_t lte_;
    ::int32_t gt_;
    ::int32_t gte_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SInt32Rules_class_data_;
// -------------------------------------------------------------------

class SFixed64Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.SFixed64Rules) */ {
 public:
  inline SFixed64Rules() : SFixed64Rules(nullptr) {}
  ~SFixed64Rules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SFixed64Rules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SFixed64Rules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SFixed64Rules(::google::protobuf::internal::ConstantInitialized);

  inline SFixed64Rules(const SFixed64Rules& from) : SFixed64Rules(nullptr, from) {}
  inline SFixed64Rules(SFixed64Rules&& from) noexcept
      : SFixed64Rules(nullptr, ::std::move(from)) {}
  inline SFixed64Rules& operator=(const SFixed64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline SFixed64Rules& operator=(SFixed64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SFixed64Rules& default_instance() {
    return *reinterpret_cast<const SFixed64Rules*>(
        &_SFixed64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SFixed64Rules& a, SFixed64Rules& b) { a.Swap(&b); }
  inline void Swap(SFixed64Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SFixed64Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SFixed64Rules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SFixed64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SFixed64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SFixed64Rules& from) { SFixed64Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SFixed64Rules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.SFixed64Rules"; }

 protected:
  explicit SFixed64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SFixed64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SFixed64Rules& from);
  SFixed64Rules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SFixed64Rules&& from) noexcept
      : SFixed64Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
    kIgnoreEmptyFieldNumber = 8,
  };
  // repeated sfixed64 in = 6;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int64_t in(int index) const;
  void set_in(int index, ::int64_t value);
  void add_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& in() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated sfixed64 not_in = 7;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int64_t not_in(int index) const;
  void set_not_in(int index, ::int64_t value);
  void add_not_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional sfixed64 const = 1;
  bool has_const_() const;
  void clear_const_() ;
  ::int64_t const_() const;
  void set_const_(::int64_t value);

  private:
  ::int64_t _internal_const_() const;
  void _internal_set_const_(::int64_t value);

  public:
  // optional sfixed64 lt = 2;
  bool has_lt() const;
  void clear_lt() ;
  ::int64_t lt() const;
  void set_lt(::int64_t value);

  private:
  ::int64_t _internal_lt() const;
  void _internal_set_lt(::int64_t value);

  public:
  // optional sfixed64 lte = 3;
  bool has_lte() const;
  void clear_lte() ;
  ::int64_t lte() const;
  void set_lte(::int64_t value);

  private:
  ::int64_t _internal_lte() const;
  void _internal_set_lte(::int64_t value);

  public:
  // optional sfixed64 gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  ::int64_t gt() const;
  void set_gt(::int64_t value);

  private:
  ::int64_t _internal_gt() const;
  void _internal_set_gt(::int64_t value);

  public:
  // optional sfixed64 gte = 5;
  bool has_gte() const;
  void clear_gte() ;
  ::int64_t gte() const;
  void set_gte(::int64_t value);

  private:
  ::int64_t _internal_gte() const;
  void _internal_set_gte(::int64_t value);

  public:
  // optional bool ignore_empty = 8;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.SFixed64Rules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SFixed64Rules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> in_;
    ::google::protobuf::RepeatedField<::int64_t> not_in_;
    ::int64_t const__;
    ::int64_t lt_;
    ::int64_t lte_;
    ::int64_t gt_;
    ::int64_t gte_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SFixed64Rules_class_data_;
// -------------------------------------------------------------------

class SFixed32Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.SFixed32Rules) */ {
 public:
  inline SFixed32Rules() : SFixed32Rules(nullptr) {}
  ~SFixed32Rules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SFixed32Rules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SFixed32Rules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SFixed32Rules(::google::protobuf::internal::ConstantInitialized);

  inline SFixed32Rules(const SFixed32Rules& from) : SFixed32Rules(nullptr, from) {}
  inline SFixed32Rules(SFixed32Rules&& from) noexcept
      : SFixed32Rules(nullptr, ::std::move(from)) {}
  inline SFixed32Rules& operator=(const SFixed32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline SFixed32Rules& operator=(SFixed32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SFixed32Rules& default_instance() {
    return *reinterpret_cast<const SFixed32Rules*>(
        &_SFixed32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SFixed32Rules& a, SFixed32Rules& b) { a.Swap(&b); }
  inline void Swap(SFixed32Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SFixed32Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SFixed32Rules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SFixed32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SFixed32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SFixed32Rules& from) { SFixed32Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SFixed32Rules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.SFixed32Rules"; }

 protected:
  explicit SFixed32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SFixed32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SFixed32Rules& from);
  SFixed32Rules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SFixed32Rules&& from) noexcept
      : SFixed32Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
    kIgnoreEmptyFieldNumber = 8,
  };
  // repeated sfixed32 in = 6;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int32_t in(int index) const;
  void set_in(int index, ::int32_t value);
  void add_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated sfixed32 not_in = 7;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int32_t not_in(int index) const;
  void set_not_in(int index, ::int32_t value);
  void add_not_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional sfixed32 const = 1;
  bool has_const_() const;
  void clear_const_() ;
  ::int32_t const_() const;
  void set_const_(::int32_t value);

  private:
  ::int32_t _internal_const_() const;
  void _internal_set_const_(::int32_t value);

  public:
  // optional sfixed32 lt = 2;
  bool has_lt() const;
  void clear_lt() ;
  ::int32_t lt() const;
  void set_lt(::int32_t value);

  private:
  ::int32_t _internal_lt() const;
  void _internal_set_lt(::int32_t value);

  public:
  // optional sfixed32 lte = 3;
  bool has_lte() const;
  void clear_lte() ;
  ::int32_t lte() const;
  void set_lte(::int32_t value);

  private:
  ::int32_t _internal_lte() const;
  void _internal_set_lte(::int32_t value);

  public:
  // optional sfixed32 gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  ::int32_t gt() const;
  void set_gt(::int32_t value);

  private:
  ::int32_t _internal_gt() const;
  void _internal_set_gt(::int32_t value);

  public:
  // optional sfixed32 gte = 5;
  bool has_gte() const;
  void clear_gte() ;
  ::int32_t gte() const;
  void set_gte(::int32_t value);

  private:
  ::int32_t _internal_gte() const;
  void _internal_set_gte(::int32_t value);

  public:
  // optional bool ignore_empty = 8;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.SFixed32Rules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SFixed32Rules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> in_;
    ::google::protobuf::RepeatedField<::int32_t> not_in_;
    ::int32_t const__;
    ::int32_t lt_;
    ::int32_t lte_;
    ::int32_t gt_;
    ::int32_t gte_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SFixed32Rules_class_data_;
// -------------------------------------------------------------------

class MessageRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.MessageRules) */ {
 public:
  inline MessageRules() : MessageRules(nullptr) {}
  ~MessageRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MessageRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MessageRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MessageRules(::google::protobuf::internal::ConstantInitialized);

  inline MessageRules(const MessageRules& from) : MessageRules(nullptr, from) {}
  inline MessageRules(MessageRules&& from) noexcept
      : MessageRules(nullptr, ::std::move(from)) {}
  inline MessageRules& operator=(const MessageRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageRules& operator=(MessageRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageRules& default_instance() {
    return *reinterpret_cast<const MessageRules*>(
        &_MessageRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(MessageRules& a, MessageRules& b) { a.Swap(&b); }
  inline void Swap(MessageRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MessageRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MessageRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MessageRules& from) { MessageRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MessageRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.MessageRules"; }

 protected:
  explicit MessageRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MessageRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MessageRules& from);
  MessageRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MessageRules&& from) noexcept
      : MessageRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkipFieldNumber = 1,
    kRequiredFieldNumber = 2,
  };
  // optional bool skip = 1;
  bool has_skip() const;
  void clear_skip() ;
  bool skip() const;
  void set_skip(bool value);

  private:
  bool _internal_skip() const;
  void _internal_set_skip(bool value);

  public:
  // optional bool required = 2;
  bool has_required() const;
  void clear_required() ;
  bool required() const;
  void set_required(bool value);

  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.MessageRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MessageRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool skip_;
    bool required_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MessageRules_class_data_;
// -------------------------------------------------------------------

class Int64Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.Int64Rules) */ {
 public:
  inline Int64Rules() : Int64Rules(nullptr) {}
  ~Int64Rules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Int64Rules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Int64Rules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Int64Rules(::google::protobuf::internal::ConstantInitialized);

  inline Int64Rules(const Int64Rules& from) : Int64Rules(nullptr, from) {}
  inline Int64Rules(Int64Rules&& from) noexcept
      : Int64Rules(nullptr, ::std::move(from)) {}
  inline Int64Rules& operator=(const Int64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int64Rules& operator=(Int64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int64Rules& default_instance() {
    return *reinterpret_cast<const Int64Rules*>(
        &_Int64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Int64Rules& a, Int64Rules& b) { a.Swap(&b); }
  inline void Swap(Int64Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int64Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int64Rules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Int64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Int64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Int64Rules& from) { Int64Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Int64Rules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.Int64Rules"; }

 protected:
  explicit Int64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Int64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Int64Rules& from);
  Int64Rules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Int64Rules&& from) noexcept
      : Int64Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
    kIgnoreEmptyFieldNumber = 8,
  };
  // repeated int64 in = 6;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int64_t in(int index) const;
  void set_in(int index, ::int64_t value);
  void add_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& in() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated int64 not_in = 7;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int64_t not_in(int index) const;
  void set_not_in(int index, ::int64_t value);
  void add_not_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional int64 const = 1;
  bool has_const_() const;
  void clear_const_() ;
  ::int64_t const_() const;
  void set_const_(::int64_t value);

  private:
  ::int64_t _internal_const_() const;
  void _internal_set_const_(::int64_t value);

  public:
  // optional int64 lt = 2;
  bool has_lt() const;
  void clear_lt() ;
  ::int64_t lt() const;
  void set_lt(::int64_t value);

  private:
  ::int64_t _internal_lt() const;
  void _internal_set_lt(::int64_t value);

  public:
  // optional int64 lte = 3;
  bool has_lte() const;
  void clear_lte() ;
  ::int64_t lte() const;
  void set_lte(::int64_t value);

  private:
  ::int64_t _internal_lte() const;
  void _internal_set_lte(::int64_t value);

  public:
  // optional int64 gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  ::int64_t gt() const;
  void set_gt(::int64_t value);

  private:
  ::int64_t _internal_gt() const;
  void _internal_set_gt(::int64_t value);

  public:
  // optional int64 gte = 5;
  bool has_gte() const;
  void clear_gte() ;
  ::int64_t gte() const;
  void set_gte(::int64_t value);

  private:
  ::int64_t _internal_gte() const;
  void _internal_set_gte(::int64_t value);

  public:
  // optional bool ignore_empty = 8;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.Int64Rules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Int64Rules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> in_;
    ::google::protobuf::RepeatedField<::int64_t> not_in_;
    ::int64_t const__;
    ::int64_t lt_;
    ::int64_t lte_;
    ::int64_t gt_;
    ::int64_t gte_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Int64Rules_class_data_;
// -------------------------------------------------------------------

class Int32Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.Int32Rules) */ {
 public:
  inline Int32Rules() : Int32Rules(nullptr) {}
  ~Int32Rules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Int32Rules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Int32Rules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Int32Rules(::google::protobuf::internal::ConstantInitialized);

  inline Int32Rules(const Int32Rules& from) : Int32Rules(nullptr, from) {}
  inline Int32Rules(Int32Rules&& from) noexcept
      : Int32Rules(nullptr, ::std::move(from)) {}
  inline Int32Rules& operator=(const Int32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int32Rules& operator=(Int32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int32Rules& default_instance() {
    return *reinterpret_cast<const Int32Rules*>(
        &_Int32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Int32Rules& a, Int32Rules& b) { a.Swap(&b); }
  inline void Swap(Int32Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int32Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int32Rules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Int32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Int32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Int32Rules& from) { Int32Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Int32Rules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.Int32Rules"; }

 protected:
  explicit Int32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Int32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Int32Rules& from);
  Int32Rules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Int32Rules&& from) noexcept
      : Int32Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
    kIgnoreEmptyFieldNumber = 8,
  };
  // repeated int32 in = 6;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int32_t in(int index) const;
  void set_in(int index, ::int32_t value);
  void add_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated int32 not_in = 7;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int32_t not_in(int index) const;
  void set_not_in(int index, ::int32_t value);
  void add_not_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional int32 const = 1;
  bool has_const_() const;
  void clear_const_() ;
  ::int32_t const_() const;
  void set_const_(::int32_t value);

  private:
  ::int32_t _internal_const_() const;
  void _internal_set_const_(::int32_t value);

  public:
  // optional int32 lt = 2;
  bool has_lt() const;
  void clear_lt() ;
  ::int32_t lt() const;
  void set_lt(::int32_t value);

  private:
  ::int32_t _internal_lt() const;
  void _internal_set_lt(::int32_t value);

  public:
  // optional int32 lte = 3;
  bool has_lte() const;
  void clear_lte() ;
  ::int32_t lte() const;
  void set_lte(::int32_t value);

  private:
  ::int32_t _internal_lte() const;
  void _internal_set_lte(::int32_t value);

  public:
  // optional int32 gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  ::int32_t gt() const;
  void set_gt(::int32_t value);

  private:
  ::int32_t _internal_gt() const;
  void _internal_set_gt(::int32_t value);

  public:
  // optional int32 gte = 5;
  bool has_gte() const;
  void clear_gte() ;
  ::int32_t gte() const;
  void set_gte(::int32_t value);

  private:
  ::int32_t _internal_gte() const;
  void _internal_set_gte(::int32_t value);

  public:
  // optional bool ignore_empty = 8;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.Int32Rules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Int32Rules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> in_;
    ::google::protobuf::RepeatedField<::int32_t> not_in_;
    ::int32_t const__;
    ::int32_t lt_;
    ::int32_t lte_;
    ::int32_t gt_;
    ::int32_t gte_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Int32Rules_class_data_;
// -------------------------------------------------------------------

class FloatRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.FloatRules) */ {
 public:
  inline FloatRules() : FloatRules(nullptr) {}
  ~FloatRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FloatRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FloatRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FloatRules(::google::protobuf::internal::ConstantInitialized);

  inline FloatRules(const FloatRules& from) : FloatRules(nullptr, from) {}
  inline FloatRules(FloatRules&& from) noexcept
      : FloatRules(nullptr, ::std::move(from)) {}
  inline FloatRules& operator=(const FloatRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatRules& operator=(FloatRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatRules& default_instance() {
    return *reinterpret_cast<const FloatRules*>(
        &_FloatRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(FloatRules& a, FloatRules& b) { a.Swap(&b); }
  inline void Swap(FloatRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FloatRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FloatRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FloatRules& from) { FloatRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FloatRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.FloatRules"; }

 protected:
  explicit FloatRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FloatRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FloatRules& from);
  FloatRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FloatRules&& from) noexcept
      : FloatRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
    kIgnoreEmptyFieldNumber = 8,
  };
  // repeated float in = 6;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  float in(int index) const;
  void set_in(int index, float value);
  void add_in(float value);
  const ::google::protobuf::RepeatedField<float>& in() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_in() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated float not_in = 7;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  float not_in(int index) const;
  void set_not_in(int index, float value);
  void add_not_in(float value);
  const ::google::protobuf::RepeatedField<float>& not_in() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional float const = 1;
  bool has_const_() const;
  void clear_const_() ;
  float const_() const;
  void set_const_(float value);

  private:
  float _internal_const_() const;
  void _internal_set_const_(float value);

  public:
  // optional float lt = 2;
  bool has_lt() const;
  void clear_lt() ;
  float lt() const;
  void set_lt(float value);

  private:
  float _internal_lt() const;
  void _internal_set_lt(float value);

  public:
  // optional float lte = 3;
  bool has_lte() const;
  void clear_lte() ;
  float lte() const;
  void set_lte(float value);

  private:
  float _internal_lte() const;
  void _internal_set_lte(float value);

  public:
  // optional float gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  float gt() const;
  void set_gt(float value);

  private:
  float _internal_gt() const;
  void _internal_set_gt(float value);

  public:
  // optional float gte = 5;
  bool has_gte() const;
  void clear_gte() ;
  float gte() const;
  void set_gte(float value);

  private:
  float _internal_gte() const;
  void _internal_set_gte(float value);

  public:
  // optional bool ignore_empty = 8;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.FloatRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FloatRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> in_;
    ::google::protobuf::RepeatedField<float> not_in_;
    float const__;
    float lt_;
    float lte_;
    float gt_;
    float gte_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FloatRules_class_data_;
// -------------------------------------------------------------------

class Fixed64Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.Fixed64Rules) */ {
 public:
  inline Fixed64Rules() : Fixed64Rules(nullptr) {}
  ~Fixed64Rules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Fixed64Rules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Fixed64Rules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Fixed64Rules(::google::protobuf::internal::ConstantInitialized);

  inline Fixed64Rules(const Fixed64Rules& from) : Fixed64Rules(nullptr, from) {}
  inline Fixed64Rules(Fixed64Rules&& from) noexcept
      : Fixed64Rules(nullptr, ::std::move(from)) {}
  inline Fixed64Rules& operator=(const Fixed64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fixed64Rules& operator=(Fixed64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fixed64Rules& default_instance() {
    return *reinterpret_cast<const Fixed64Rules*>(
        &_Fixed64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Fixed64Rules& a, Fixed64Rules& b) { a.Swap(&b); }
  inline void Swap(Fixed64Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fixed64Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fixed64Rules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Fixed64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Fixed64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Fixed64Rules& from) { Fixed64Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Fixed64Rules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.Fixed64Rules"; }

 protected:
  explicit Fixed64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Fixed64Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Fixed64Rules& from);
  Fixed64Rules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Fixed64Rules&& from) noexcept
      : Fixed64Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
    kIgnoreEmptyFieldNumber = 8,
  };
  // repeated fixed64 in = 6;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::uint64_t in(int index) const;
  void set_in(int index, ::uint64_t value);
  void add_in(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated fixed64 not_in = 7;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::uint64_t not_in(int index) const;
  void set_not_in(int index, ::uint64_t value);
  void add_not_in(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional fixed64 const = 1;
  bool has_const_() const;
  void clear_const_() ;
  ::uint64_t const_() const;
  void set_const_(::uint64_t value);

  private:
  ::uint64_t _internal_const_() const;
  void _internal_set_const_(::uint64_t value);

  public:
  // optional fixed64 lt = 2;
  bool has_lt() const;
  void clear_lt() ;
  ::uint64_t lt() const;
  void set_lt(::uint64_t value);

  private:
  ::uint64_t _internal_lt() const;
  void _internal_set_lt(::uint64_t value);

  public:
  // optional fixed64 lte = 3;
  bool has_lte() const;
  void clear_lte() ;
  ::uint64_t lte() const;
  void set_lte(::uint64_t value);

  private:
  ::uint64_t _internal_lte() const;
  void _internal_set_lte(::uint64_t value);

  public:
  // optional fixed64 gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  ::uint64_t gt() const;
  void set_gt(::uint64_t value);

  private:
  ::uint64_t _internal_gt() const;
  void _internal_set_gt(::uint64_t value);

  public:
  // optional fixed64 gte = 5;
  bool has_gte() const;
  void clear_gte() ;
  ::uint64_t gte() const;
  void set_gte(::uint64_t value);

  private:
  ::uint64_t _internal_gte() const;
  void _internal_set_gte(::uint64_t value);

  public:
  // optional bool ignore_empty = 8;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.Fixed64Rules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Fixed64Rules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> in_;
    ::google::protobuf::RepeatedField<::uint64_t> not_in_;
    ::uint64_t const__;
    ::uint64_t lt_;
    ::uint64_t lte_;
    ::uint64_t gt_;
    ::uint64_t gte_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Fixed64Rules_class_data_;
// -------------------------------------------------------------------

class Fixed32Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.Fixed32Rules) */ {
 public:
  inline Fixed32Rules() : Fixed32Rules(nullptr) {}
  ~Fixed32Rules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Fixed32Rules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Fixed32Rules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Fixed32Rules(::google::protobuf::internal::ConstantInitialized);

  inline Fixed32Rules(const Fixed32Rules& from) : Fixed32Rules(nullptr, from) {}
  inline Fixed32Rules(Fixed32Rules&& from) noexcept
      : Fixed32Rules(nullptr, ::std::move(from)) {}
  inline Fixed32Rules& operator=(const Fixed32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fixed32Rules& operator=(Fixed32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fixed32Rules& default_instance() {
    return *reinterpret_cast<const Fixed32Rules*>(
        &_Fixed32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Fixed32Rules& a, Fixed32Rules& b) { a.Swap(&b); }
  inline void Swap(Fixed32Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fixed32Rules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fixed32Rules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Fixed32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Fixed32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Fixed32Rules& from) { Fixed32Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Fixed32Rules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.Fixed32Rules"; }

 protected:
  explicit Fixed32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Fixed32Rules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Fixed32Rules& from);
  Fixed32Rules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Fixed32Rules&& from) noexcept
      : Fixed32Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
    kIgnoreEmptyFieldNumber = 8,
  };
  // repeated fixed32 in = 6;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::uint32_t in(int index) const;
  void set_in(int index, ::uint32_t value);
  void add_in(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated fixed32 not_in = 7;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::uint32_t not_in(int index) const;
  void set_not_in(int index, ::uint32_t value);
  void add_not_in(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional fixed32 const = 1;
  bool has_const_() const;
  void clear_const_() ;
  ::uint32_t const_() const;
  void set_const_(::uint32_t value);

  private:
  ::uint32_t _internal_const_() const;
  void _internal_set_const_(::uint32_t value);

  public:
  // optional fixed32 lt = 2;
  bool has_lt() const;
  void clear_lt() ;
  ::uint32_t lt() const;
  void set_lt(::uint32_t value);

  private:
  ::uint32_t _internal_lt() const;
  void _internal_set_lt(::uint32_t value);

  public:
  // optional fixed32 lte = 3;
  bool has_lte() const;
  void clear_lte() ;
  ::uint32_t lte() const;
  void set_lte(::uint32_t value);

  private:
  ::uint32_t _internal_lte() const;
  void _internal_set_lte(::uint32_t value);

  public:
  // optional fixed32 gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  ::uint32_t gt() const;
  void set_gt(::uint32_t value);

  private:
  ::uint32_t _internal_gt() const;
  void _internal_set_gt(::uint32_t value);

  public:
  // optional fixed32 gte = 5;
  bool has_gte() const;
  void clear_gte() ;
  ::uint32_t gte() const;
  void set_gte(::uint32_t value);

  private:
  ::uint32_t _internal_gte() const;
  void _internal_set_gte(::uint32_t value);

  public:
  // optional bool ignore_empty = 8;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.Fixed32Rules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Fixed32Rules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> in_;
    ::google::protobuf::RepeatedField<::uint32_t> not_in_;
    ::uint32_t const__;
    ::uint32_t lt_;
    ::uint32_t lte_;
    ::uint32_t gt_;
    ::uint32_t gte_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Fixed32Rules_class_data_;
// -------------------------------------------------------------------

class EnumRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.EnumRules) */ {
 public:
  inline EnumRules() : EnumRules(nullptr) {}
  ~EnumRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EnumRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EnumRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EnumRules(::google::protobuf::internal::ConstantInitialized);

  inline EnumRules(const EnumRules& from) : EnumRules(nullptr, from) {}
  inline EnumRules(EnumRules&& from) noexcept
      : EnumRules(nullptr, ::std::move(from)) {}
  inline EnumRules& operator=(const EnumRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnumRules& operator=(EnumRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnumRules& default_instance() {
    return *reinterpret_cast<const EnumRules*>(
        &_EnumRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(EnumRules& a, EnumRules& b) { a.Swap(&b); }
  inline void Swap(EnumRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnumRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnumRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EnumRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EnumRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EnumRules& from) { EnumRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EnumRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.EnumRules"; }

 protected:
  explicit EnumRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EnumRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EnumRules& from);
  EnumRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EnumRules&& from) noexcept
      : EnumRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 3,
    kNotInFieldNumber = 4,
    kConstFieldNumber = 1,
    kDefinedOnlyFieldNumber = 2,
  };
  // repeated int32 in = 3;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int32_t in(int index) const;
  void set_in(int index, ::int32_t value);
  void add_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated int32 not_in = 4;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int32_t not_in(int index) const;
  void set_not_in(int index, ::int32_t value);
  void add_not_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional int32 const = 1;
  bool has_const_() const;
  void clear_const_() ;
  ::int32_t const_() const;
  void set_const_(::int32_t value);

  private:
  ::int32_t _internal_const_() const;
  void _internal_set_const_(::int32_t value);

  public:
  // optional bool defined_only = 2;
  bool has_defined_only() const;
  void clear_defined_only() ;
  bool defined_only() const;
  void set_defined_only(bool value);

  private:
  bool _internal_defined_only() const;
  void _internal_set_defined_only(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.EnumRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EnumRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> in_;
    ::google::protobuf::RepeatedField<::int32_t> not_in_;
    ::int32_t const__;
    bool defined_only_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EnumRules_class_data_;
// -------------------------------------------------------------------

class DoubleRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.DoubleRules) */ {
 public:
  inline DoubleRules() : DoubleRules(nullptr) {}
  ~DoubleRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DoubleRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DoubleRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DoubleRules(::google::protobuf::internal::ConstantInitialized);

  inline DoubleRules(const DoubleRules& from) : DoubleRules(nullptr, from) {}
  inline DoubleRules(DoubleRules&& from) noexcept
      : DoubleRules(nullptr, ::std::move(from)) {}
  inline DoubleRules& operator=(const DoubleRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleRules& operator=(DoubleRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleRules& default_instance() {
    return *reinterpret_cast<const DoubleRules*>(
        &_DoubleRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(DoubleRules& a, DoubleRules& b) { a.Swap(&b); }
  inline void Swap(DoubleRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DoubleRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoubleRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DoubleRules& from) { DoubleRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DoubleRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.DoubleRules"; }

 protected:
  explicit DoubleRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DoubleRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DoubleRules& from);
  DoubleRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DoubleRules&& from) noexcept
      : DoubleRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
    kIgnoreEmptyFieldNumber = 8,
  };
  // repeated double in = 6;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  double in(int index) const;
  void set_in(int index, double value);
  void add_in(double value);
  const ::google::protobuf::RepeatedField<double>& in() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_in() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated double not_in = 7;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  double not_in(int index) const;
  void set_not_in(int index, double value);
  void add_not_in(double value);
  const ::google::protobuf::RepeatedField<double>& not_in() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional double const = 1;
  bool has_const_() const;
  void clear_const_() ;
  double const_() const;
  void set_const_(double value);

  private:
  double _internal_const_() const;
  void _internal_set_const_(double value);

  public:
  // optional double lt = 2;
  bool has_lt() const;
  void clear_lt() ;
  double lt() const;
  void set_lt(double value);

  private:
  double _internal_lt() const;
  void _internal_set_lt(double value);

  public:
  // optional double lte = 3;
  bool has_lte() const;
  void clear_lte() ;
  double lte() const;
  void set_lte(double value);

  private:
  double _internal_lte() const;
  void _internal_set_lte(double value);

  public:
  // optional double gt = 4;
  bool has_gt() const;
  void clear_gt() ;
  double gt() const;
  void set_gt(double value);

  private:
  double _internal_gt() const;
  void _internal_set_gt(double value);

  public:
  // optional double gte = 5;
  bool has_gte() const;
  void clear_gte() ;
  double gte() const;
  void set_gte(double value);

  private:
  double _internal_gte() const;
  void _internal_set_gte(double value);

  public:
  // optional bool ignore_empty = 8;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.DoubleRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DoubleRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> in_;
    ::google::protobuf::RepeatedField<double> not_in_;
    double const__;
    double lt_;
    double lte_;
    double gt_;
    double gte_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DoubleRules_class_data_;
// -------------------------------------------------------------------

class BytesRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.BytesRules) */ {
 public:
  inline BytesRules() : BytesRules(nullptr) {}
  ~BytesRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BytesRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BytesRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BytesRules(::google::protobuf::internal::ConstantInitialized);

  inline BytesRules(const BytesRules& from) : BytesRules(nullptr, from) {}
  inline BytesRules(BytesRules&& from) noexcept
      : BytesRules(nullptr, ::std::move(from)) {}
  inline BytesRules& operator=(const BytesRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline BytesRules& operator=(BytesRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BytesRules& default_instance() {
    return *reinterpret_cast<const BytesRules*>(
        &_BytesRules_default_instance_);
  }
  enum WellKnownCase {
    kIp = 10,
    kIpv4 = 11,
    kIpv6 = 12,
    WELL_KNOWN_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(BytesRules& a, BytesRules& b) { a.Swap(&b); }
  inline void Swap(BytesRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BytesRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BytesRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BytesRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BytesRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BytesRules& from) { BytesRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BytesRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.BytesRules"; }

 protected:
  explicit BytesRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BytesRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BytesRules& from);
  BytesRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BytesRules&& from) noexcept
      : BytesRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 8,
    kNotInFieldNumber = 9,
    kConstFieldNumber = 1,
    kPatternFieldNumber = 4,
    kPrefixFieldNumber = 5,
    kSuffixFieldNumber = 6,
    kContainsFieldNumber = 7,
    kMinLenFieldNumber = 2,
    kMaxLenFieldNumber = 3,
    kLenFieldNumber = 13,
    kIgnoreEmptyFieldNumber = 14,
    kIpFieldNumber = 10,
    kIpv4FieldNumber = 11,
    kIpv6FieldNumber = 12,
  };
  // repeated bytes in = 8;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  const ::std::string& in(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_in(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_in(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_in();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_in(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated bytes not_in = 9;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  const ::std::string& not_in(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_not_in(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_not_in(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_not_in();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_not_in(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_not_in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional bytes const = 1;
  bool has_const_() const;
  void clear_const_() ;
  const ::std::string& const_() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_const_(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_const_();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_const_();
  void set_allocated_const_(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_const_() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_const_(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_const_();

  public:
  // optional string pattern = 4;
  bool has_pattern() const;
  void clear_pattern() ;
  const ::std::string& pattern() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_pattern(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_pattern();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_pattern();
  void set_allocated_pattern(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_pattern() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_pattern();

  public:
  // optional bytes prefix = 5;
  bool has_prefix() const;
  void clear_prefix() ;
  const ::std::string& prefix() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_prefix(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_prefix();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_prefix();
  void set_allocated_prefix(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_prefix() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_prefix();

  public:
  // optional bytes suffix = 6;
  bool has_suffix() const;
  void clear_suffix() ;
  const ::std::string& suffix() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_suffix(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_suffix();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_suffix();
  void set_allocated_suffix(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_suffix() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_suffix(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_suffix();

  public:
  // optional bytes contains = 7;
  bool has_contains() const;
  void clear_contains() ;
  const ::std::string& contains() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_contains(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_contains();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_contains();
  void set_allocated_contains(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_contains() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_contains(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_contains();

  public:
  // optional uint64 min_len = 2;
  bool has_min_len() const;
  void clear_min_len() ;
  ::uint64_t min_len() const;
  void set_min_len(::uint64_t value);

  private:
  ::uint64_t _internal_min_len() const;
  void _internal_set_min_len(::uint64_t value);

  public:
  // optional uint64 max_len = 3;
  bool has_max_len() const;
  void clear_max_len() ;
  ::uint64_t max_len() const;
  void set_max_len(::uint64_t value);

  private:
  ::uint64_t _internal_max_len() const;
  void _internal_set_max_len(::uint64_t value);

  public:
  // optional uint64 len = 13;
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // optional bool ignore_empty = 14;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // bool ip = 10;
  bool has_ip() const;
  void clear_ip() ;
  bool ip() const;
  void set_ip(bool value);

  private:
  bool _internal_ip() const;
  void _internal_set_ip(bool value);

  public:
  // bool ipv4 = 11;
  bool has_ipv4() const;
  void clear_ipv4() ;
  bool ipv4() const;
  void set_ipv4(bool value);

  private:
  bool _internal_ipv4() const;
  void _internal_set_ipv4(bool value);

  public:
  // bool ipv6 = 12;
  bool has_ipv6() const;
  void clear_ipv6() ;
  bool ipv6() const;
  void set_ipv6(bool value);

  private:
  bool _internal_ipv6() const;
  void _internal_set_ipv6(bool value);

  public:
  void clear_well_known();
  WellKnownCase well_known_case() const;
  // @@protoc_insertion_point(class_scope:validate.BytesRules)
 private:
  class _Internal;
  void set_has_ip();
  void set_has_ipv4();
  void set_has_ipv6();
  inline bool has_well_known() const;
  inline void clear_has_well_known();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 14,
                                   0, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BytesRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> in_;
    ::google::protobuf::RepeatedPtrField<::std::string> not_in_;
    ::google::protobuf::internal::ArenaStringPtr const__;
    ::google::protobuf::internal::ArenaStringPtr pattern_;
    ::google::protobuf::internal::ArenaStringPtr prefix_;
    ::google::protobuf::internal::ArenaStringPtr suffix_;
    ::google::protobuf::internal::ArenaStringPtr contains_;
    ::uint64_t min_len_;
    ::uint64_t max_len_;
    ::uint64_t len_;
    bool ignore_empty_;
    union WellKnownUnion {
      constexpr WellKnownUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool ip_;
      bool ipv4_;
      bool ipv6_;
    } well_known_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BytesRules_class_data_;
// -------------------------------------------------------------------

class BoolRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.BoolRules) */ {
 public:
  inline BoolRules() : BoolRules(nullptr) {}
  ~BoolRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BoolRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BoolRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BoolRules(::google::protobuf::internal::ConstantInitialized);

  inline BoolRules(const BoolRules& from) : BoolRules(nullptr, from) {}
  inline BoolRules(BoolRules&& from) noexcept
      : BoolRules(nullptr, ::std::move(from)) {}
  inline BoolRules& operator=(const BoolRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolRules& operator=(BoolRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolRules& default_instance() {
    return *reinterpret_cast<const BoolRules*>(
        &_BoolRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(BoolRules& a, BoolRules& b) { a.Swap(&b); }
  inline void Swap(BoolRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BoolRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoolRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BoolRules& from) { BoolRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BoolRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.BoolRules"; }

 protected:
  explicit BoolRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BoolRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BoolRules& from);
  BoolRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BoolRules&& from) noexcept
      : BoolRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConstFieldNumber = 1,
  };
  // optional bool const = 1;
  bool has_const_() const;
  void clear_const_() ;
  bool const_() const;
  void set_const_(bool value);

  private:
  bool _internal_const_() const;
  void _internal_set_const_(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.BoolRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BoolRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool const__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BoolRules_class_data_;
// -------------------------------------------------------------------

class AnyRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.AnyRules) */ {
 public:
  inline AnyRules() : AnyRules(nullptr) {}
  ~AnyRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AnyRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AnyRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AnyRules(::google::protobuf::internal::ConstantInitialized);

  inline AnyRules(const AnyRules& from) : AnyRules(nullptr, from) {}
  inline AnyRules(AnyRules&& from) noexcept
      : AnyRules(nullptr, ::std::move(from)) {}
  inline AnyRules& operator=(const AnyRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnyRules& operator=(AnyRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnyRules& default_instance() {
    return *reinterpret_cast<const AnyRules*>(
        &_AnyRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(AnyRules& a, AnyRules& b) { a.Swap(&b); }
  inline void Swap(AnyRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnyRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnyRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AnyRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnyRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AnyRules& from) { AnyRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AnyRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.AnyRules"; }

 protected:
  explicit AnyRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AnyRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AnyRules& from);
  AnyRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AnyRules&& from) noexcept
      : AnyRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 2,
    kNotInFieldNumber = 3,
    kRequiredFieldNumber = 1,
  };
  // repeated string in = 2;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  const ::std::string& in(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_in(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_in(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_in();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_in(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_in();

  public:
  // repeated string not_in = 3;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  const ::std::string& not_in(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_not_in(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_not_in(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_not_in();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_not_in(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_not_in() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_not_in();

  public:
  // optional bool required = 1;
  bool has_required() const;
  void clear_required() ;
  bool required() const;
  void set_required(bool value);

  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.AnyRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 34,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AnyRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> in_;
    ::google::protobuf::RepeatedPtrField<::std::string> not_in_;
    bool required_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AnyRules_class_data_;
// -------------------------------------------------------------------

class TimestampRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.TimestampRules) */ {
 public:
  inline TimestampRules() : TimestampRules(nullptr) {}
  ~TimestampRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TimestampRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TimestampRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TimestampRules(::google::protobuf::internal::ConstantInitialized);

  inline TimestampRules(const TimestampRules& from) : TimestampRules(nullptr, from) {}
  inline TimestampRules(TimestampRules&& from) noexcept
      : TimestampRules(nullptr, ::std::move(from)) {}
  inline TimestampRules& operator=(const TimestampRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimestampRules& operator=(TimestampRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimestampRules& default_instance() {
    return *reinterpret_cast<const TimestampRules*>(
        &_TimestampRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(TimestampRules& a, TimestampRules& b) { a.Swap(&b); }
  inline void Swap(TimestampRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimestampRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimestampRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TimestampRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimestampRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TimestampRules& from) { TimestampRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TimestampRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.TimestampRules"; }

 protected:
  explicit TimestampRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TimestampRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TimestampRules& from);
  TimestampRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TimestampRules&& from) noexcept
      : TimestampRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConstFieldNumber = 2,
    kLtFieldNumber = 3,
    kLteFieldNumber = 4,
    kGtFieldNumber = 5,
    kGteFieldNumber = 6,
    kWithinFieldNumber = 9,
    kRequiredFieldNumber = 1,
    kLtNowFieldNumber = 7,
    kGtNowFieldNumber = 8,
  };
  // optional .google.protobuf.Timestamp const = 2;
  bool has_const_() const;
  void clear_const_() ;
  const ::google::protobuf::Timestamp& const_() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_const_();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_const_();
  void set_allocated_const_(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_const_(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_const_();

  private:
  const ::google::protobuf::Timestamp& _internal_const_() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_const_();

  public:
  // optional .google.protobuf.Timestamp lt = 3;
  bool has_lt() const;
  void clear_lt() ;
  const ::google::protobuf::Timestamp& lt() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_lt();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_lt();
  void set_allocated_lt(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lt(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_lt();

  private:
  const ::google::protobuf::Timestamp& _internal_lt() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_lt();

  public:
  // optional .google.protobuf.Timestamp lte = 4;
  bool has_lte() const;
  void clear_lte() ;
  const ::google::protobuf::Timestamp& lte() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_lte();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_lte();
  void set_allocated_lte(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lte(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_lte();

  private:
  const ::google::protobuf::Timestamp& _internal_lte() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_lte();

  public:
  // optional .google.protobuf.Timestamp gt = 5;
  bool has_gt() const;
  void clear_gt() ;
  const ::google::protobuf::Timestamp& gt() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_gt();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_gt();
  void set_allocated_gt(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gt(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_gt();

  private:
  const ::google::protobuf::Timestamp& _internal_gt() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_gt();

  public:
  // optional .google.protobuf.Timestamp gte = 6;
  bool has_gte() const;
  void clear_gte() ;
  const ::google::protobuf::Timestamp& gte() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_gte();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_gte();
  void set_allocated_gte(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gte(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_gte();

  private:
  const ::google::protobuf::Timestamp& _internal_gte() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_gte();

  public:
  // optional .google.protobuf.Duration within = 9;
  bool has_within() const;
  void clear_within() ;
  const ::google::protobuf::Duration& within() const;
  [[nodiscard]] ::google::protobuf::Duration* PROTOBUF_NULLABLE release_within();
  ::google::protobuf::Duration* PROTOBUF_NONNULL mutable_within();
  void set_allocated_within(::google::protobuf::Duration* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_within(::google::protobuf::Duration* PROTOBUF_NULLABLE value);
  ::google::protobuf::Duration* PROTOBUF_NULLABLE unsafe_arena_release_within();

  private:
  const ::google::protobuf::Duration& _internal_within() const;
  ::google::protobuf::Duration* PROTOBUF_NONNULL _internal_mutable_within();

  public:
  // optional bool required = 1;
  bool has_required() const;
  void clear_required() ;
  bool required() const;
  void set_required(bool value);

  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);

  public:
  // optional bool lt_now = 7;
  bool has_lt_now() const;
  void clear_lt_now() ;
  bool lt_now() const;
  void set_lt_now(bool value);

  private:
  bool _internal_lt_now() const;
  void _internal_set_lt_now(bool value);

  public:
  // optional bool gt_now = 8;
  bool has_gt_now() const;
  void clear_gt_now() ;
  bool gt_now() const;
  void set_gt_now(bool value);

  private:
  bool _internal_gt_now() const;
  void _internal_set_gt_now(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.TimestampRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   6, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TimestampRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE const__;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE lt_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE lte_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE gt_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE gte_;
    ::google::protobuf::Duration* PROTOBUF_NULLABLE within_;
    bool required_;
    bool lt_now_;
    bool gt_now_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TimestampRules_class_data_;
// -------------------------------------------------------------------

class DurationRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.DurationRules) */ {
 public:
  inline DurationRules() : DurationRules(nullptr) {}
  ~DurationRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DurationRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DurationRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DurationRules(::google::protobuf::internal::ConstantInitialized);

  inline DurationRules(const DurationRules& from) : DurationRules(nullptr, from) {}
  inline DurationRules(DurationRules&& from) noexcept
      : DurationRules(nullptr, ::std::move(from)) {}
  inline DurationRules& operator=(const DurationRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline DurationRules& operator=(DurationRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DurationRules& default_instance() {
    return *reinterpret_cast<const DurationRules*>(
        &_DurationRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(DurationRules& a, DurationRules& b) { a.Swap(&b); }
  inline void Swap(DurationRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DurationRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DurationRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DurationRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DurationRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DurationRules& from) { DurationRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DurationRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.DurationRules"; }

 protected:
  explicit DurationRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DurationRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DurationRules& from);
  DurationRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DurationRules&& from) noexcept
      : DurationRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 7,
    kNotInFieldNumber = 8,
    kConstFieldNumber = 2,
    kLtFieldNumber = 3,
    kLteFieldNumber = 4,
    kGtFieldNumber = 5,
    kGteFieldNumber = 6,
    kRequiredFieldNumber = 1,
  };
  // repeated .google.protobuf.Duration in = 7;
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::google::protobuf::Duration* PROTOBUF_NONNULL mutable_in(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* PROTOBUF_NONNULL mutable_in();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& _internal_in() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* PROTOBUF_NONNULL _internal_mutable_in();
  public:
  const ::google::protobuf::Duration& in(int index) const;
  ::google::protobuf::Duration* PROTOBUF_NONNULL add_in();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& in() const;
  // repeated .google.protobuf.Duration not_in = 8;
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::google::protobuf::Duration* PROTOBUF_NONNULL mutable_not_in(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* PROTOBUF_NONNULL mutable_not_in();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& _internal_not_in() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* PROTOBUF_NONNULL _internal_mutable_not_in();
  public:
  const ::google::protobuf::Duration& not_in(int index) const;
  ::google::protobuf::Duration* PROTOBUF_NONNULL add_not_in();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& not_in() const;
  // optional .google.protobuf.Duration const = 2;
  bool has_const_() const;
  void clear_const_() ;
  const ::google::protobuf::Duration& const_() const;
  [[nodiscard]] ::google::protobuf::Duration* PROTOBUF_NULLABLE release_const_();
  ::google::protobuf::Duration* PROTOBUF_NONNULL mutable_const_();
  void set_allocated_const_(::google::protobuf::Duration* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_const_(::google::protobuf::Duration* PROTOBUF_NULLABLE value);
  ::google::protobuf::Duration* PROTOBUF_NULLABLE unsafe_arena_release_const_();

  private:
  const ::google::protobuf::Duration& _internal_const_() const;
  ::google::protobuf::Duration* PROTOBUF_NONNULL _internal_mutable_const_();

  public:
  // optional .google.protobuf.Duration lt = 3;
  bool has_lt() const;
  void clear_lt() ;
  const ::google::protobuf::Duration& lt() const;
  [[nodiscard]] ::google::protobuf::Duration* PROTOBUF_NULLABLE release_lt();
  ::google::protobuf::Duration* PROTOBUF_NONNULL mutable_lt();
  void set_allocated_lt(::google::protobuf::Duration* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lt(::google::protobuf::Duration* PROTOBUF_NULLABLE value);
  ::google::protobuf::Duration* PROTOBUF_NULLABLE unsafe_arena_release_lt();

  private:
  const ::google::protobuf::Duration& _internal_lt() const;
  ::google::protobuf::Duration* PROTOBUF_NONNULL _internal_mutable_lt();

  public:
  // optional .google.protobuf.Duration lte = 4;
  bool has_lte() const;
  void clear_lte() ;
  const ::google::protobuf::Duration& lte() const;
  [[nodiscard]] ::google::protobuf::Duration* PROTOBUF_NULLABLE release_lte();
  ::google::protobuf::Duration* PROTOBUF_NONNULL mutable_lte();
  void set_allocated_lte(::google::protobuf::Duration* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lte(::google::protobuf::Duration* PROTOBUF_NULLABLE value);
  ::google::protobuf::Duration* PROTOBUF_NULLABLE unsafe_arena_release_lte();

  private:
  const ::google::protobuf::Duration& _internal_lte() const;
  ::google::protobuf::Duration* PROTOBUF_NONNULL _internal_mutable_lte();

  public:
  // optional .google.protobuf.Duration gt = 5;
  bool has_gt() const;
  void clear_gt() ;
  const ::google::protobuf::Duration& gt() const;
  [[nodiscard]] ::google::protobuf::Duration* PROTOBUF_NULLABLE release_gt();
  ::google::protobuf::Duration* PROTOBUF_NONNULL mutable_gt();
  void set_allocated_gt(::google::protobuf::Duration* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gt(::google::protobuf::Duration* PROTOBUF_NULLABLE value);
  ::google::protobuf::Duration* PROTOBUF_NULLABLE unsafe_arena_release_gt();

  private:
  const ::google::protobuf::Duration& _internal_gt() const;
  ::google::protobuf::Duration* PROTOBUF_NONNULL _internal_mutable_gt();

  public:
  // optional .google.protobuf.Duration gte = 6;
  bool has_gte() const;
  void clear_gte() ;
  const ::google::protobuf::Duration& gte() const;
  [[nodiscard]] ::google::protobuf::Duration* PROTOBUF_NULLABLE release_gte();
  ::google::protobuf::Duration* PROTOBUF_NONNULL mutable_gte();
  void set_allocated_gte(::google::protobuf::Duration* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gte(::google::protobuf::Duration* PROTOBUF_NULLABLE value);
  ::google::protobuf::Duration* PROTOBUF_NULLABLE unsafe_arena_release_gte();

  private:
  const ::google::protobuf::Duration& _internal_gte() const;
  ::google::protobuf::Duration* PROTOBUF_NONNULL _internal_mutable_gte();

  public:
  // optional bool required = 1;
  bool has_required() const;
  void clear_required() ;
  bool required() const;
  void set_required(bool value);

  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.DurationRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   7, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DurationRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration > in_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration > not_in_;
    ::google::protobuf::Duration* PROTOBUF_NULLABLE const__;
    ::google::protobuf::Duration* PROTOBUF_NULLABLE lt_;
    ::google::protobuf::Duration* PROTOBUF_NULLABLE lte_;
    ::google::protobuf::Duration* PROTOBUF_NULLABLE gt_;
    ::google::protobuf::Duration* PROTOBUF_NULLABLE gte_;
    bool required_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DurationRules_class_data_;
// -------------------------------------------------------------------

class FieldRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.FieldRules) */ {
 public:
  inline FieldRules() : FieldRules(nullptr) {}
  ~FieldRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FieldRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FieldRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FieldRules(::google::protobuf::internal::ConstantInitialized);

  inline FieldRules(const FieldRules& from) : FieldRules(nullptr, from) {}
  inline FieldRules(FieldRules&& from) noexcept
      : FieldRules(nullptr, ::std::move(from)) {}
  inline FieldRules& operator=(const FieldRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldRules& operator=(FieldRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldRules& default_instance() {
    return *reinterpret_cast<const FieldRules*>(
        &_FieldRules_default_instance_);
  }
  enum TypeCase {
    kFloat = 1,
    kDouble = 2,
    kInt32 = 3,
    kInt64 = 4,
    kUint32 = 5,
    kUint64 = 6,
    kSint32 = 7,
    kSint64 = 8,
    kFixed32 = 9,
    kFixed64 = 10,
    kSfixed32 = 11,
    kSfixed64 = 12,
    kBool = 13,
    kString = 14,
    kBytes = 15,
    kEnum = 16,
    kRepeated = 18,
    kMap = 19,
    kAny = 20,
    kDuration = 21,
    kTimestamp = 22,
    TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(FieldRules& a, FieldRules& b) { a.Swap(&b); }
  inline void Swap(FieldRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FieldRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FieldRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FieldRules& from) { FieldRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FieldRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.FieldRules"; }

 protected:
  explicit FieldRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FieldRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FieldRules& from);
  FieldRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FieldRules&& from) noexcept
      : FieldRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 17,
    kFloatFieldNumber = 1,
    kDoubleFieldNumber = 2,
    kInt32FieldNumber = 3,
    kInt64FieldNumber = 4,
    kUint32FieldNumber = 5,
    kUint64FieldNumber = 6,
    kSint32FieldNumber = 7,
    kSint64FieldNumber = 8,
    kFixed32FieldNumber = 9,
    kFixed64FieldNumber = 10,
    kSfixed32FieldNumber = 11,
    kSfixed64FieldNumber = 12,
    kBoolFieldNumber = 13,
    kStringFieldNumber = 14,
    kBytesFieldNumber = 15,
    kEnumFieldNumber = 16,
    kRepeatedFieldNumber = 18,
    kMapFieldNumber = 19,
    kAnyFieldNumber = 20,
    kDurationFieldNumber = 21,
    kTimestampFieldNumber = 22,
  };
  // optional .validate.MessageRules message = 17;
  bool has_message() const;
  void clear_message() ;
  const ::validate::MessageRules& message() const;
  [[nodiscard]] ::validate::MessageRules* PROTOBUF_NULLABLE release_message();
  ::validate::MessageRules* PROTOBUF_NONNULL mutable_message();
  void set_allocated_message(::validate::MessageRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_message(::validate::MessageRules* PROTOBUF_NULLABLE value);
  ::validate::MessageRules* PROTOBUF_NULLABLE unsafe_arena_release_message();

  private:
  const ::validate::MessageRules& _internal_message() const;
  ::validate::MessageRules* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // .validate.FloatRules float = 1;
  bool has_float_() const;
  private:
  bool _internal_has_float_() const;

  public:
  void clear_float_() ;
  const ::validate::FloatRules& float_() const;
  [[nodiscard]] ::validate::FloatRules* PROTOBUF_NULLABLE release_float_();
  ::validate::FloatRules* PROTOBUF_NONNULL mutable_float_();
  void set_allocated_float_(::validate::FloatRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_float_(::validate::FloatRules* PROTOBUF_NULLABLE value);
  ::validate::FloatRules* PROTOBUF_NULLABLE unsafe_arena_release_float_();

  private:
  const ::validate::FloatRules& _internal_float_() const;
  ::validate::FloatRules* PROTOBUF_NONNULL _internal_mutable_float_();

  public:
  // .validate.DoubleRules double = 2;
  bool has_double_() const;
  private:
  bool _internal_has_double_() const;

  public:
  void clear_double_() ;
  const ::validate::DoubleRules& double_() const;
  [[nodiscard]] ::validate::DoubleRules* PROTOBUF_NULLABLE release_double_();
  ::validate::DoubleRules* PROTOBUF_NONNULL mutable_double_();
  void set_allocated_double_(::validate::DoubleRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_double_(::validate::DoubleRules* PROTOBUF_NULLABLE value);
  ::validate::DoubleRules* PROTOBUF_NULLABLE unsafe_arena_release_double_();

  private:
  const ::validate::DoubleRules& _internal_double_() const;
  ::validate::DoubleRules* PROTOBUF_NONNULL _internal_mutable_double_();

  public:
  // .validate.Int32Rules int32 = 3;
  bool has_int32() const;
  private:
  bool _internal_has_int32() const;

  public:
  void clear_int32() ;
  const ::validate::Int32Rules& int32() const;
  [[nodiscard]] ::validate::Int32Rules* PROTOBUF_NULLABLE release_int32();
  ::validate::Int32Rules* PROTOBUF_NONNULL mutable_int32();
  void set_allocated_int32(::validate::Int32Rules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_int32(::validate::Int32Rules* PROTOBUF_NULLABLE value);
  ::validate::Int32Rules* PROTOBUF_NULLABLE unsafe_arena_release_int32();

  private:
  const ::validate::Int32Rules& _internal_int32() const;
  ::validate::Int32Rules* PROTOBUF_NONNULL _internal_mutable_int32();

  public:
  // .validate.Int64Rules int64 = 4;
  bool has_int64() const;
  private:
  bool _internal_has_int64() const;

  public:
  void clear_int64() ;
  const ::validate::Int64Rules& int64() const;
  [[nodiscard]] ::validate::Int64Rules* PROTOBUF_NULLABLE release_int64();
  ::validate::Int64Rules* PROTOBUF_NONNULL mutable_int64();
  void set_allocated_int64(::validate::Int64Rules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_int64(::validate::Int64Rules* PROTOBUF_NULLABLE value);
  ::validate::Int64Rules* PROTOBUF_NULLABLE unsafe_arena_release_int64();

  private:
  const ::validate::Int64Rules& _internal_int64() const;
  ::validate::Int64Rules* PROTOBUF_NONNULL _internal_mutable_int64();

  public:
  // .validate.UInt32Rules uint32 = 5;
  bool has_uint32() const;
  private:
  bool _internal_has_uint32() const;

  public:
  void clear_uint32() ;
  const ::validate::UInt32Rules& uint32() const;
  [[nodiscard]] ::validate::UInt32Rules* PROTOBUF_NULLABLE release_uint32();
  ::validate::UInt32Rules* PROTOBUF_NONNULL mutable_uint32();
  void set_allocated_uint32(::validate::UInt32Rules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_uint32(::validate::UInt32Rules* PROTOBUF_NULLABLE value);
  ::validate::UInt32Rules* PROTOBUF_NULLABLE unsafe_arena_release_uint32();

  private:
  const ::validate::UInt32Rules& _internal_uint32() const;
  ::validate::UInt32Rules* PROTOBUF_NONNULL _internal_mutable_uint32();

  public:
  // .validate.UInt64Rules uint64 = 6;
  bool has_uint64() const;
  private:
  bool _internal_has_uint64() const;

  public:
  void clear_uint64() ;
  const ::validate::UInt64Rules& uint64() const;
  [[nodiscard]] ::validate::UInt64Rules* PROTOBUF_NULLABLE release_uint64();
  ::validate::UInt64Rules* PROTOBUF_NONNULL mutable_uint64();
  void set_allocated_uint64(::validate::UInt64Rules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_uint64(::validate::UInt64Rules* PROTOBUF_NULLABLE value);
  ::validate::UInt64Rules* PROTOBUF_NULLABLE unsafe_arena_release_uint64();

  private:
  const ::validate::UInt64Rules& _internal_uint64() const;
  ::validate::UInt64Rules* PROTOBUF_NONNULL _internal_mutable_uint64();

  public:
  // .validate.SInt32Rules sint32 = 7;
  bool has_sint32() const;
  private:
  bool _internal_has_sint32() const;

  public:
  void clear_sint32() ;
  const ::validate::SInt32Rules& sint32() const;
  [[nodiscard]] ::validate::SInt32Rules* PROTOBUF_NULLABLE release_sint32();
  ::validate::SInt32Rules* PROTOBUF_NONNULL mutable_sint32();
  void set_allocated_sint32(::validate::SInt32Rules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sint32(::validate::SInt32Rules* PROTOBUF_NULLABLE value);
  ::validate::SInt32Rules* PROTOBUF_NULLABLE unsafe_arena_release_sint32();

  private:
  const ::validate::SInt32Rules& _internal_sint32() const;
  ::validate::SInt32Rules* PROTOBUF_NONNULL _internal_mutable_sint32();

  public:
  // .validate.SInt64Rules sint64 = 8;
  bool has_sint64() const;
  private:
  bool _internal_has_sint64() const;

  public:
  void clear_sint64() ;
  const ::validate::SInt64Rules& sint64() const;
  [[nodiscard]] ::validate::SInt64Rules* PROTOBUF_NULLABLE release_sint64();
  ::validate::SInt64Rules* PROTOBUF_NONNULL mutable_sint64();
  void set_allocated_sint64(::validate::SInt64Rules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sint64(::validate::SInt64Rules* PROTOBUF_NULLABLE value);
  ::validate::SInt64Rules* PROTOBUF_NULLABLE unsafe_arena_release_sint64();

  private:
  const ::validate::SInt64Rules& _internal_sint64() const;
  ::validate::SInt64Rules* PROTOBUF_NONNULL _internal_mutable_sint64();

  public:
  // .validate.Fixed32Rules fixed32 = 9;
  bool has_fixed32() const;
  private:
  bool _internal_has_fixed32() const;

  public:
  void clear_fixed32() ;
  const ::validate::Fixed32Rules& fixed32() const;
  [[nodiscard]] ::validate::Fixed32Rules* PROTOBUF_NULLABLE release_fixed32();
  ::validate::Fixed32Rules* PROTOBUF_NONNULL mutable_fixed32();
  void set_allocated_fixed32(::validate::Fixed32Rules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_fixed32(::validate::Fixed32Rules* PROTOBUF_NULLABLE value);
  ::validate::Fixed32Rules* PROTOBUF_NULLABLE unsafe_arena_release_fixed32();

  private:
  const ::validate::Fixed32Rules& _internal_fixed32() const;
  ::validate::Fixed32Rules* PROTOBUF_NONNULL _internal_mutable_fixed32();

  public:
  // .validate.Fixed64Rules fixed64 = 10;
  bool has_fixed64() const;
  private:
  bool _internal_has_fixed64() const;

  public:
  void clear_fixed64() ;
  const ::validate::Fixed64Rules& fixed64() const;
  [[nodiscard]] ::validate::Fixed64Rules* PROTOBUF_NULLABLE release_fixed64();
  ::validate::Fixed64Rules* PROTOBUF_NONNULL mutable_fixed64();
  void set_allocated_fixed64(::validate::Fixed64Rules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_fixed64(::validate::Fixed64Rules* PROTOBUF_NULLABLE value);
  ::validate::Fixed64Rules* PROTOBUF_NULLABLE unsafe_arena_release_fixed64();

  private:
  const ::validate::Fixed64Rules& _internal_fixed64() const;
  ::validate::Fixed64Rules* PROTOBUF_NONNULL _internal_mutable_fixed64();

  public:
  // .validate.SFixed32Rules sfixed32 = 11;
  bool has_sfixed32() const;
  private:
  bool _internal_has_sfixed32() const;

  public:
  void clear_sfixed32() ;
  const ::validate::SFixed32Rules& sfixed32() const;
  [[nodiscard]] ::validate::SFixed32Rules* PROTOBUF_NULLABLE release_sfixed32();
  ::validate::SFixed32Rules* PROTOBUF_NONNULL mutable_sfixed32();
  void set_allocated_sfixed32(::validate::SFixed32Rules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sfixed32(::validate::SFixed32Rules* PROTOBUF_NULLABLE value);
  ::validate::SFixed32Rules* PROTOBUF_NULLABLE unsafe_arena_release_sfixed32();

  private:
  const ::validate::SFixed32Rules& _internal_sfixed32() const;
  ::validate::SFixed32Rules* PROTOBUF_NONNULL _internal_mutable_sfixed32();

  public:
  // .validate.SFixed64Rules sfixed64 = 12;
  bool has_sfixed64() const;
  private:
  bool _internal_has_sfixed64() const;

  public:
  void clear_sfixed64() ;
  const ::validate::SFixed64Rules& sfixed64() const;
  [[nodiscard]] ::validate::SFixed64Rules* PROTOBUF_NULLABLE release_sfixed64();
  ::validate::SFixed64Rules* PROTOBUF_NONNULL mutable_sfixed64();
  void set_allocated_sfixed64(::validate::SFixed64Rules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sfixed64(::validate::SFixed64Rules* PROTOBUF_NULLABLE value);
  ::validate::SFixed64Rules* PROTOBUF_NULLABLE unsafe_arena_release_sfixed64();

  private:
  const ::validate::SFixed64Rules& _internal_sfixed64() const;
  ::validate::SFixed64Rules* PROTOBUF_NONNULL _internal_mutable_sfixed64();

  public:
  // .validate.BoolRules bool = 13;
  bool has_bool_() const;
  private:
  bool _internal_has_bool_() const;

  public:
  void clear_bool_() ;
  const ::validate::BoolRules& bool_() const;
  [[nodiscard]] ::validate::BoolRules* PROTOBUF_NULLABLE release_bool_();
  ::validate::BoolRules* PROTOBUF_NONNULL mutable_bool_();
  void set_allocated_bool_(::validate::BoolRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bool_(::validate::BoolRules* PROTOBUF_NULLABLE value);
  ::validate::BoolRules* PROTOBUF_NULLABLE unsafe_arena_release_bool_();

  private:
  const ::validate::BoolRules& _internal_bool_() const;
  ::validate::BoolRules* PROTOBUF_NONNULL _internal_mutable_bool_();

  public:
  // .validate.StringRules string = 14;
  bool has_string() const;
  private:
  bool _internal_has_string() const;

  public:
  void clear_string() ;
  const ::validate::StringRules& string() const;
  [[nodiscard]] ::validate::StringRules* PROTOBUF_NULLABLE release_string();
  ::validate::StringRules* PROTOBUF_NONNULL mutable_string();
  void set_allocated_string(::validate::StringRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_string(::validate::StringRules* PROTOBUF_NULLABLE value);
  ::validate::StringRules* PROTOBUF_NULLABLE unsafe_arena_release_string();

  private:
  const ::validate::StringRules& _internal_string() const;
  ::validate::StringRules* PROTOBUF_NONNULL _internal_mutable_string();

  public:
  // .validate.BytesRules bytes = 15;
  bool has_bytes() const;
  private:
  bool _internal_has_bytes() const;

  public:
  void clear_bytes() ;
  const ::validate::BytesRules& bytes() const;
  [[nodiscard]] ::validate::BytesRules* PROTOBUF_NULLABLE release_bytes();
  ::validate::BytesRules* PROTOBUF_NONNULL mutable_bytes();
  void set_allocated_bytes(::validate::BytesRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bytes(::validate::BytesRules* PROTOBUF_NULLABLE value);
  ::validate::BytesRules* PROTOBUF_NULLABLE unsafe_arena_release_bytes();

  private:
  const ::validate::BytesRules& _internal_bytes() const;
  ::validate::BytesRules* PROTOBUF_NONNULL _internal_mutable_bytes();

  public:
  // .validate.EnumRules enum = 16;
  bool has_enum_() const;
  private:
  bool _internal_has_enum_() const;

  public:
  void clear_enum_() ;
  const ::validate::EnumRules& enum_() const;
  [[nodiscard]] ::validate::EnumRules* PROTOBUF_NULLABLE release_enum_();
  ::validate::EnumRules* PROTOBUF_NONNULL mutable_enum_();
  void set_allocated_enum_(::validate::EnumRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_enum_(::validate::EnumRules* PROTOBUF_NULLABLE value);
  ::validate::EnumRules* PROTOBUF_NULLABLE unsafe_arena_release_enum_();

  private:
  const ::validate::EnumRules& _internal_enum_() const;
  ::validate::EnumRules* PROTOBUF_NONNULL _internal_mutable_enum_();

  public:
  // .validate.RepeatedRules repeated = 18;
  bool has_repeated() const;
  private:
  bool _internal_has_repeated() const;

  public:
  void clear_repeated() ;
  const ::validate::RepeatedRules& repeated() const;
  [[nodiscard]] ::validate::RepeatedRules* PROTOBUF_NULLABLE release_repeated();
  ::validate::RepeatedRules* PROTOBUF_NONNULL mutable_repeated();
  void set_allocated_repeated(::validate::RepeatedRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_repeated(::validate::RepeatedRules* PROTOBUF_NULLABLE value);
  ::validate::RepeatedRules* PROTOBUF_NULLABLE unsafe_arena_release_repeated();

  private:
  const ::validate::RepeatedRules& _internal_repeated() const;
  ::validate::RepeatedRules* PROTOBUF_NONNULL _internal_mutable_repeated();

  public:
  // .validate.MapRules map = 19;
  bool has_map() const;
  private:
  bool _internal_has_map() const;

  public:
  void clear_map() ;
  const ::validate::MapRules& map() const;
  [[nodiscard]] ::validate::MapRules* PROTOBUF_NULLABLE release_map();
  ::validate::MapRules* PROTOBUF_NONNULL mutable_map();
  void set_allocated_map(::validate::MapRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_map(::validate::MapRules* PROTOBUF_NULLABLE value);
  ::validate::MapRules* PROTOBUF_NULLABLE unsafe_arena_release_map();

  private:
  const ::validate::MapRules& _internal_map() const;
  ::validate::MapRules* PROTOBUF_NONNULL _internal_mutable_map();

  public:
  // .validate.AnyRules any = 20;
  bool has_any() const;
  private:
  bool _internal_has_any() const;

  public:
  void clear_any() ;
  const ::validate::AnyRules& any() const;
  [[nodiscard]] ::validate::AnyRules* PROTOBUF_NULLABLE release_any();
  ::validate::AnyRules* PROTOBUF_NONNULL mutable_any();
  void set_allocated_any(::validate::AnyRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_any(::validate::AnyRules* PROTOBUF_NULLABLE value);
  ::validate::AnyRules* PROTOBUF_NULLABLE unsafe_arena_release_any();

  private:
  const ::validate::AnyRules& _internal_any() const;
  ::validate::AnyRules* PROTOBUF_NONNULL _internal_mutable_any();

  public:
  // .validate.DurationRules duration = 21;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;

  public:
  void clear_duration() ;
  const ::validate::DurationRules& duration() const;
  [[nodiscard]] ::validate::DurationRules* PROTOBUF_NULLABLE release_duration();
  ::validate::DurationRules* PROTOBUF_NONNULL mutable_duration();
  void set_allocated_duration(::validate::DurationRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_duration(::validate::DurationRules* PROTOBUF_NULLABLE value);
  ::validate::DurationRules* PROTOBUF_NULLABLE unsafe_arena_release_duration();

  private:
  const ::validate::DurationRules& _internal_duration() const;
  ::validate::DurationRules* PROTOBUF_NONNULL _internal_mutable_duration();

  public:
  // .validate.TimestampRules timestamp = 22;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;

  public:
  void clear_timestamp() ;
  const ::validate::TimestampRules& timestamp() const;
  [[nodiscard]] ::validate::TimestampRules* PROTOBUF_NULLABLE release_timestamp();
  ::validate::TimestampRules* PROTOBUF_NONNULL mutable_timestamp();
  void set_allocated_timestamp(::validate::TimestampRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_timestamp(::validate::TimestampRules* PROTOBUF_NULLABLE value);
  ::validate::TimestampRules* PROTOBUF_NULLABLE unsafe_arena_release_timestamp();

  private:
  const ::validate::TimestampRules& _internal_timestamp() const;
  ::validate::TimestampRules* PROTOBUF_NONNULL _internal_mutable_timestamp();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:validate.FieldRules)
 private:
  class _Internal;
  void set_has_float_();
  void set_has_double_();
  void set_has_int32();
  void set_has_int64();
  void set_has_uint32();
  void set_has_uint64();
  void set_has_sint32();
  void set_has_sint64();
  void set_has_fixed32();
  void set_has_fixed64();
  void set_has_sfixed32();
  void set_has_sfixed64();
  void set_has_bool_();
  void set_has_string();
  void set_has_bytes();
  void set_has_enum_();
  void set_has_repeated();
  void set_has_map();
  void set_has_any();
  void set_has_duration();
  void set_has_timestamp();
  inline bool has_type() const;
  inline void clear_has_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 22,
                                   22, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FieldRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::validate::MessageRules* PROTOBUF_NULLABLE message_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE float__;
      ::google::protobuf::Message* PROTOBUF_NULLABLE double__;
      ::google::protobuf::Message* PROTOBUF_NULLABLE int32_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE int64_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE uint32_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE uint64_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sint32_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sint64_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE fixed32_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE fixed64_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sfixed32_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sfixed64_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE bool__;
      ::google::protobuf::Message* PROTOBUF_NULLABLE string_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE bytes_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE enum__;
      ::google::protobuf::Message* PROTOBUF_NULLABLE repeated_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE map_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE any_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE duration_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE timestamp_;
    } type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FieldRules_class_data_;
// -------------------------------------------------------------------

class MapRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.MapRules) */ {
 public:
  inline MapRules() : MapRules(nullptr) {}
  ~MapRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MapRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MapRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MapRules(::google::protobuf::internal::ConstantInitialized);

  inline MapRules(const MapRules& from) : MapRules(nullptr, from) {}
  inline MapRules(MapRules&& from) noexcept
      : MapRules(nullptr, ::std::move(from)) {}
  inline MapRules& operator=(const MapRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapRules& operator=(MapRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapRules& default_instance() {
    return *reinterpret_cast<const MapRules*>(
        &_MapRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(MapRules& a, MapRules& b) { a.Swap(&b); }
  inline void Swap(MapRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MapRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MapRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MapRules& from) { MapRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MapRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.MapRules"; }

 protected:
  explicit MapRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MapRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MapRules& from);
  MapRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MapRules&& from) noexcept
      : MapRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeysFieldNumber = 4,
    kValuesFieldNumber = 5,
    kMinPairsFieldNumber = 1,
    kMaxPairsFieldNumber = 2,
    kNoSparseFieldNumber = 3,
    kIgnoreEmptyFieldNumber = 6,
  };
  // optional .validate.FieldRules keys = 4;
  bool has_keys() const;
  void clear_keys() ;
  const ::validate::FieldRules& keys() const;
  [[nodiscard]] ::validate::FieldRules* PROTOBUF_NULLABLE release_keys();
  ::validate::FieldRules* PROTOBUF_NONNULL mutable_keys();
  void set_allocated_keys(::validate::FieldRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_keys(::validate::FieldRules* PROTOBUF_NULLABLE value);
  ::validate::FieldRules* PROTOBUF_NULLABLE unsafe_arena_release_keys();

  private:
  const ::validate::FieldRules& _internal_keys() const;
  ::validate::FieldRules* PROTOBUF_NONNULL _internal_mutable_keys();

  public:
  // optional .validate.FieldRules values = 5;
  bool has_values() const;
  void clear_values() ;
  const ::validate::FieldRules& values() const;
  [[nodiscard]] ::validate::FieldRules* PROTOBUF_NULLABLE release_values();
  ::validate::FieldRules* PROTOBUF_NONNULL mutable_values();
  void set_allocated_values(::validate::FieldRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_values(::validate::FieldRules* PROTOBUF_NULLABLE value);
  ::validate::FieldRules* PROTOBUF_NULLABLE unsafe_arena_release_values();

  private:
  const ::validate::FieldRules& _internal_values() const;
  ::validate::FieldRules* PROTOBUF_NONNULL _internal_mutable_values();

  public:
  // optional uint64 min_pairs = 1;
  bool has_min_pairs() const;
  void clear_min_pairs() ;
  ::uint64_t min_pairs() const;
  void set_min_pairs(::uint64_t value);

  private:
  ::uint64_t _internal_min_pairs() const;
  void _internal_set_min_pairs(::uint64_t value);

  public:
  // optional uint64 max_pairs = 2;
  bool has_max_pairs() const;
  void clear_max_pairs() ;
  ::uint64_t max_pairs() const;
  void set_max_pairs(::uint64_t value);

  private:
  ::uint64_t _internal_max_pairs() const;
  void _internal_set_max_pairs(::uint64_t value);

  public:
  // optional bool no_sparse = 3;
  bool has_no_sparse() const;
  void clear_no_sparse() ;
  bool no_sparse() const;
  void set_no_sparse(bool value);

  private:
  bool _internal_no_sparse() const;
  void _internal_set_no_sparse(bool value);

  public:
  // optional bool ignore_empty = 6;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.MapRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MapRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::validate::FieldRules* PROTOBUF_NULLABLE keys_;
    ::validate::FieldRules* PROTOBUF_NULLABLE values_;
    ::uint64_t min_pairs_;
    ::uint64_t max_pairs_;
    bool no_sparse_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MapRules_class_data_;
// -------------------------------------------------------------------

class RepeatedRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:validate.RepeatedRules) */ {
 public:
  inline RepeatedRules() : RepeatedRules(nullptr) {}
  ~RepeatedRules() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RepeatedRules* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RepeatedRules));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RepeatedRules(::google::protobuf::internal::ConstantInitialized);

  inline RepeatedRules(const RepeatedRules& from) : RepeatedRules(nullptr, from) {}
  inline RepeatedRules(RepeatedRules&& from) noexcept
      : RepeatedRules(nullptr, ::std::move(from)) {}
  inline RepeatedRules& operator=(const RepeatedRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepeatedRules& operator=(RepeatedRules&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepeatedRules& default_instance() {
    return *reinterpret_cast<const RepeatedRules*>(
        &_RepeatedRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(RepeatedRules& a, RepeatedRules& b) { a.Swap(&b); }
  inline void Swap(RepeatedRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepeatedRules* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepeatedRules* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RepeatedRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepeatedRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RepeatedRules& from) { RepeatedRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RepeatedRules* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "validate.RepeatedRules"; }

 protected:
  explicit RepeatedRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RepeatedRules(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RepeatedRules& from);
  RepeatedRules(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RepeatedRules&& from) noexcept
      : RepeatedRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 4,
    kMinItemsFieldNumber = 1,
    kMaxItemsFieldNumber = 2,
    kUniqueFieldNumber = 3,
    kIgnoreEmptyFieldNumber = 5,
  };
  // optional .validate.FieldRules items = 4;
  bool has_items() const;
  void clear_items() ;
  const ::validate::FieldRules& items() const;
  [[nodiscard]] ::validate::FieldRules* PROTOBUF_NULLABLE release_items();
  ::validate::FieldRules* PROTOBUF_NONNULL mutable_items();
  void set_allocated_items(::validate::FieldRules* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_items(::validate::FieldRules* PROTOBUF_NULLABLE value);
  ::validate::FieldRules* PROTOBUF_NULLABLE unsafe_arena_release_items();

  private:
  const ::validate::FieldRules& _internal_items() const;
  ::validate::FieldRules* PROTOBUF_NONNULL _internal_mutable_items();

  public:
  // optional uint64 min_items = 1;
  bool has_min_items() const;
  void clear_min_items() ;
  ::uint64_t min_items() const;
  void set_min_items(::uint64_t value);

  private:
  ::uint64_t _internal_min_items() const;
  void _internal_set_min_items(::uint64_t value);

  public:
  // optional uint64 max_items = 2;
  bool has_max_items() const;
  void clear_max_items() ;
  ::uint64_t max_items() const;
  void set_max_items(::uint64_t value);

  private:
  ::uint64_t _internal_max_items() const;
  void _internal_set_max_items(::uint64_t value);

  public:
  // optional bool unique = 3;
  bool has_unique() const;
  void clear_unique() ;
  bool unique() const;
  void set_unique(bool value);

  private:
  bool _internal_unique() const;
  void _internal_set_unique(bool value);

  public:
  // optional bool ignore_empty = 5;
  bool has_ignore_empty() const;
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:validate.RepeatedRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RepeatedRules& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::validate::FieldRules* PROTOBUF_NULLABLE items_;
    ::uint64_t min_items_;
    ::uint64_t max_items_;
    bool unique_;
    bool ignore_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_validate_2fvalidate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RepeatedRules_class_data_;

// ===================================================================



inline constexpr int kDisabledFieldNumber = 1071;
extern ::google::protobuf::internal::ExtensionIdentifier<
    ::google::protobuf::MessageOptions, ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false>
    disabled;
inline constexpr int kIgnoredFieldNumber = 1072;
extern ::google::protobuf::internal::ExtensionIdentifier<
    ::google::protobuf::MessageOptions, ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false>
    ignored;
inline constexpr int kRequiredFieldNumber = 1071;
extern ::google::protobuf::internal::ExtensionIdentifier<
    ::google::protobuf::OneofOptions, ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false>
    required;
inline constexpr int kRulesFieldNumber = 1071;
extern ::google::protobuf::internal::ExtensionIdentifier<
    ::google::protobuf::FieldOptions, ::google::protobuf::internal::MessageTypeTraits< ::validate::FieldRules >, 11, false>
    rules;

// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FieldRules

// optional .validate.MessageRules message = 17;
inline bool FieldRules::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_ != nullptr);
  return value;
}
inline void FieldRules::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.message_ != nullptr) _impl_.message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::validate::MessageRules& FieldRules::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::validate::MessageRules* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::validate::MessageRules&>(::validate::_MessageRules_default_instance_);
}
inline const ::validate::MessageRules& FieldRules::message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.message)
  return _internal_message();
}
inline void FieldRules::unsafe_arena_set_allocated_message(
    ::validate::MessageRules* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = reinterpret_cast<::validate::MessageRules*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.message)
}
inline ::validate::MessageRules* PROTOBUF_NULLABLE FieldRules::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::validate::MessageRules* released = _impl_.message_;
  _impl_.message_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::validate::MessageRules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.FieldRules.message)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::validate::MessageRules* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::validate::MessageRules* PROTOBUF_NONNULL FieldRules::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.message_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::validate::MessageRules>(GetArena());
    _impl_.message_ = reinterpret_cast<::validate::MessageRules*>(p);
  }
  return _impl_.message_;
}
inline ::validate::MessageRules* PROTOBUF_NONNULL FieldRules::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::validate::MessageRules* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.message)
  return _msg;
}
inline void FieldRules::set_allocated_message(::validate::MessageRules* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.message_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.message_ = reinterpret_cast<::validate::MessageRules*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.FieldRules.message)
}

// .validate.FloatRules float = 1;
inline bool FieldRules::has_float_() const {
  return type_case() == kFloat;
}
inline bool FieldRules::_internal_has_float_() const {
  return type_case() == kFloat;
}
inline void FieldRules::set_has_float_() {
  _impl_._oneof_case_[0] = kFloat;
}
inline void FieldRules::clear_float_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kFloat) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.float__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.float__);
    }
    clear_has_type();
  }
}
inline ::validate::FloatRules* PROTOBUF_NULLABLE FieldRules::release_float_() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.float)
  if (type_case() == kFloat) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::FloatRules*>(_impl_.type_.float__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.float__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::FloatRules& FieldRules::_internal_float_() const {
  return type_case() == kFloat ? *reinterpret_cast<::validate::FloatRules*>(_impl_.type_.float__) : reinterpret_cast<::validate::FloatRules&>(::validate::_FloatRules_default_instance_);
}
inline const ::validate::FloatRules& FieldRules::float_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.float)
  return _internal_float_();
}
inline ::validate::FloatRules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_float_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.float)
  if (type_case() == kFloat) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::FloatRules*>(_impl_.type_.float__);
    _impl_.type_.float__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_float_(
    ::validate::FloatRules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_float_();
    _impl_.type_.float__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.float)
}
inline ::validate::FloatRules* PROTOBUF_NONNULL FieldRules::_internal_mutable_float_() {
  if (type_case() != kFloat) {
    clear_type();
    set_has_float_();
    _impl_.type_.float__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::FloatRules>(GetArena()));
  }
  return reinterpret_cast<::validate::FloatRules*>(_impl_.type_.float__);
}
inline ::validate::FloatRules* PROTOBUF_NONNULL FieldRules::mutable_float_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::FloatRules* _msg = _internal_mutable_float_();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.float)
  return _msg;
}

// .validate.DoubleRules double = 2;
inline bool FieldRules::has_double_() const {
  return type_case() == kDouble;
}
inline bool FieldRules::_internal_has_double_() const {
  return type_case() == kDouble;
}
inline void FieldRules::set_has_double_() {
  _impl_._oneof_case_[0] = kDouble;
}
inline void FieldRules::clear_double_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kDouble) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.double__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.double__);
    }
    clear_has_type();
  }
}
inline ::validate::DoubleRules* PROTOBUF_NULLABLE FieldRules::release_double_() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.double)
  if (type_case() == kDouble) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::DoubleRules*>(_impl_.type_.double__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.double__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::DoubleRules& FieldRules::_internal_double_() const {
  return type_case() == kDouble ? *reinterpret_cast<::validate::DoubleRules*>(_impl_.type_.double__) : reinterpret_cast<::validate::DoubleRules&>(::validate::_DoubleRules_default_instance_);
}
inline const ::validate::DoubleRules& FieldRules::double_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.double)
  return _internal_double_();
}
inline ::validate::DoubleRules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_double_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.double)
  if (type_case() == kDouble) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::DoubleRules*>(_impl_.type_.double__);
    _impl_.type_.double__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_double_(
    ::validate::DoubleRules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_double_();
    _impl_.type_.double__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.double)
}
inline ::validate::DoubleRules* PROTOBUF_NONNULL FieldRules::_internal_mutable_double_() {
  if (type_case() != kDouble) {
    clear_type();
    set_has_double_();
    _impl_.type_.double__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::DoubleRules>(GetArena()));
  }
  return reinterpret_cast<::validate::DoubleRules*>(_impl_.type_.double__);
}
inline ::validate::DoubleRules* PROTOBUF_NONNULL FieldRules::mutable_double_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::DoubleRules* _msg = _internal_mutable_double_();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.double)
  return _msg;
}

// .validate.Int32Rules int32 = 3;
inline bool FieldRules::has_int32() const {
  return type_case() == kInt32;
}
inline bool FieldRules::_internal_has_int32() const {
  return type_case() == kInt32;
}
inline void FieldRules::set_has_int32() {
  _impl_._oneof_case_[0] = kInt32;
}
inline void FieldRules::clear_int32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kInt32) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.int32_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.int32_);
    }
    clear_has_type();
  }
}
inline ::validate::Int32Rules* PROTOBUF_NULLABLE FieldRules::release_int32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.int32)
  if (type_case() == kInt32) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::Int32Rules*>(_impl_.type_.int32_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.int32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::Int32Rules& FieldRules::_internal_int32() const {
  return type_case() == kInt32 ? *reinterpret_cast<::validate::Int32Rules*>(_impl_.type_.int32_) : reinterpret_cast<::validate::Int32Rules&>(::validate::_Int32Rules_default_instance_);
}
inline const ::validate::Int32Rules& FieldRules::int32() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.int32)
  return _internal_int32();
}
inline ::validate::Int32Rules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_int32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.int32)
  if (type_case() == kInt32) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::Int32Rules*>(_impl_.type_.int32_);
    _impl_.type_.int32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_int32(
    ::validate::Int32Rules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_int32();
    _impl_.type_.int32_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.int32)
}
inline ::validate::Int32Rules* PROTOBUF_NONNULL FieldRules::_internal_mutable_int32() {
  if (type_case() != kInt32) {
    clear_type();
    set_has_int32();
    _impl_.type_.int32_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::Int32Rules>(GetArena()));
  }
  return reinterpret_cast<::validate::Int32Rules*>(_impl_.type_.int32_);
}
inline ::validate::Int32Rules* PROTOBUF_NONNULL FieldRules::mutable_int32()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::Int32Rules* _msg = _internal_mutable_int32();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.int32)
  return _msg;
}

// .validate.Int64Rules int64 = 4;
inline bool FieldRules::has_int64() const {
  return type_case() == kInt64;
}
inline bool FieldRules::_internal_has_int64() const {
  return type_case() == kInt64;
}
inline void FieldRules::set_has_int64() {
  _impl_._oneof_case_[0] = kInt64;
}
inline void FieldRules::clear_int64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kInt64) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.int64_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.int64_);
    }
    clear_has_type();
  }
}
inline ::validate::Int64Rules* PROTOBUF_NULLABLE FieldRules::release_int64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.int64)
  if (type_case() == kInt64) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::Int64Rules*>(_impl_.type_.int64_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.int64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::Int64Rules& FieldRules::_internal_int64() const {
  return type_case() == kInt64 ? *reinterpret_cast<::validate::Int64Rules*>(_impl_.type_.int64_) : reinterpret_cast<::validate::Int64Rules&>(::validate::_Int64Rules_default_instance_);
}
inline const ::validate::Int64Rules& FieldRules::int64() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.int64)
  return _internal_int64();
}
inline ::validate::Int64Rules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_int64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.int64)
  if (type_case() == kInt64) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::Int64Rules*>(_impl_.type_.int64_);
    _impl_.type_.int64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_int64(
    ::validate::Int64Rules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_int64();
    _impl_.type_.int64_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.int64)
}
inline ::validate::Int64Rules* PROTOBUF_NONNULL FieldRules::_internal_mutable_int64() {
  if (type_case() != kInt64) {
    clear_type();
    set_has_int64();
    _impl_.type_.int64_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::Int64Rules>(GetArena()));
  }
  return reinterpret_cast<::validate::Int64Rules*>(_impl_.type_.int64_);
}
inline ::validate::Int64Rules* PROTOBUF_NONNULL FieldRules::mutable_int64()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::Int64Rules* _msg = _internal_mutable_int64();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.int64)
  return _msg;
}

// .validate.UInt32Rules uint32 = 5;
inline bool FieldRules::has_uint32() const {
  return type_case() == kUint32;
}
inline bool FieldRules::_internal_has_uint32() const {
  return type_case() == kUint32;
}
inline void FieldRules::set_has_uint32() {
  _impl_._oneof_case_[0] = kUint32;
}
inline void FieldRules::clear_uint32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kUint32) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.uint32_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.uint32_);
    }
    clear_has_type();
  }
}
inline ::validate::UInt32Rules* PROTOBUF_NULLABLE FieldRules::release_uint32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.uint32)
  if (type_case() == kUint32) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::UInt32Rules*>(_impl_.type_.uint32_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.uint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::UInt32Rules& FieldRules::_internal_uint32() const {
  return type_case() == kUint32 ? *reinterpret_cast<::validate::UInt32Rules*>(_impl_.type_.uint32_) : reinterpret_cast<::validate::UInt32Rules&>(::validate::_UInt32Rules_default_instance_);
}
inline const ::validate::UInt32Rules& FieldRules::uint32() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.uint32)
  return _internal_uint32();
}
inline ::validate::UInt32Rules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_uint32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.uint32)
  if (type_case() == kUint32) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::UInt32Rules*>(_impl_.type_.uint32_);
    _impl_.type_.uint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_uint32(
    ::validate::UInt32Rules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_uint32();
    _impl_.type_.uint32_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.uint32)
}
inline ::validate::UInt32Rules* PROTOBUF_NONNULL FieldRules::_internal_mutable_uint32() {
  if (type_case() != kUint32) {
    clear_type();
    set_has_uint32();
    _impl_.type_.uint32_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::UInt32Rules>(GetArena()));
  }
  return reinterpret_cast<::validate::UInt32Rules*>(_impl_.type_.uint32_);
}
inline ::validate::UInt32Rules* PROTOBUF_NONNULL FieldRules::mutable_uint32()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::UInt32Rules* _msg = _internal_mutable_uint32();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.uint32)
  return _msg;
}

// .validate.UInt64Rules uint64 = 6;
inline bool FieldRules::has_uint64() const {
  return type_case() == kUint64;
}
inline bool FieldRules::_internal_has_uint64() const {
  return type_case() == kUint64;
}
inline void FieldRules::set_has_uint64() {
  _impl_._oneof_case_[0] = kUint64;
}
inline void FieldRules::clear_uint64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kUint64) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.uint64_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.uint64_);
    }
    clear_has_type();
  }
}
inline ::validate::UInt64Rules* PROTOBUF_NULLABLE FieldRules::release_uint64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.uint64)
  if (type_case() == kUint64) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::UInt64Rules*>(_impl_.type_.uint64_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.uint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::UInt64Rules& FieldRules::_internal_uint64() const {
  return type_case() == kUint64 ? *reinterpret_cast<::validate::UInt64Rules*>(_impl_.type_.uint64_) : reinterpret_cast<::validate::UInt64Rules&>(::validate::_UInt64Rules_default_instance_);
}
inline const ::validate::UInt64Rules& FieldRules::uint64() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.uint64)
  return _internal_uint64();
}
inline ::validate::UInt64Rules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_uint64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.uint64)
  if (type_case() == kUint64) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::UInt64Rules*>(_impl_.type_.uint64_);
    _impl_.type_.uint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_uint64(
    ::validate::UInt64Rules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_uint64();
    _impl_.type_.uint64_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.uint64)
}
inline ::validate::UInt64Rules* PROTOBUF_NONNULL FieldRules::_internal_mutable_uint64() {
  if (type_case() != kUint64) {
    clear_type();
    set_has_uint64();
    _impl_.type_.uint64_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::UInt64Rules>(GetArena()));
  }
  return reinterpret_cast<::validate::UInt64Rules*>(_impl_.type_.uint64_);
}
inline ::validate::UInt64Rules* PROTOBUF_NONNULL FieldRules::mutable_uint64()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::UInt64Rules* _msg = _internal_mutable_uint64();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.uint64)
  return _msg;
}

// .validate.SInt32Rules sint32 = 7;
inline bool FieldRules::has_sint32() const {
  return type_case() == kSint32;
}
inline bool FieldRules::_internal_has_sint32() const {
  return type_case() == kSint32;
}
inline void FieldRules::set_has_sint32() {
  _impl_._oneof_case_[0] = kSint32;
}
inline void FieldRules::clear_sint32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kSint32) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.sint32_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sint32_);
    }
    clear_has_type();
  }
}
inline ::validate::SInt32Rules* PROTOBUF_NULLABLE FieldRules::release_sint32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.sint32)
  if (type_case() == kSint32) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::SInt32Rules*>(_impl_.type_.sint32_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::SInt32Rules& FieldRules::_internal_sint32() const {
  return type_case() == kSint32 ? *reinterpret_cast<::validate::SInt32Rules*>(_impl_.type_.sint32_) : reinterpret_cast<::validate::SInt32Rules&>(::validate::_SInt32Rules_default_instance_);
}
inline const ::validate::SInt32Rules& FieldRules::sint32() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.sint32)
  return _internal_sint32();
}
inline ::validate::SInt32Rules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_sint32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.sint32)
  if (type_case() == kSint32) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::SInt32Rules*>(_impl_.type_.sint32_);
    _impl_.type_.sint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_sint32(
    ::validate::SInt32Rules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_sint32();
    _impl_.type_.sint32_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.sint32)
}
inline ::validate::SInt32Rules* PROTOBUF_NONNULL FieldRules::_internal_mutable_sint32() {
  if (type_case() != kSint32) {
    clear_type();
    set_has_sint32();
    _impl_.type_.sint32_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::SInt32Rules>(GetArena()));
  }
  return reinterpret_cast<::validate::SInt32Rules*>(_impl_.type_.sint32_);
}
inline ::validate::SInt32Rules* PROTOBUF_NONNULL FieldRules::mutable_sint32()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::SInt32Rules* _msg = _internal_mutable_sint32();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.sint32)
  return _msg;
}

// .validate.SInt64Rules sint64 = 8;
inline bool FieldRules::has_sint64() const {
  return type_case() == kSint64;
}
inline bool FieldRules::_internal_has_sint64() const {
  return type_case() == kSint64;
}
inline void FieldRules::set_has_sint64() {
  _impl_._oneof_case_[0] = kSint64;
}
inline void FieldRules::clear_sint64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kSint64) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.sint64_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sint64_);
    }
    clear_has_type();
  }
}
inline ::validate::SInt64Rules* PROTOBUF_NULLABLE FieldRules::release_sint64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.sint64)
  if (type_case() == kSint64) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::SInt64Rules*>(_impl_.type_.sint64_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::SInt64Rules& FieldRules::_internal_sint64() const {
  return type_case() == kSint64 ? *reinterpret_cast<::validate::SInt64Rules*>(_impl_.type_.sint64_) : reinterpret_cast<::validate::SInt64Rules&>(::validate::_SInt64Rules_default_instance_);
}
inline const ::validate::SInt64Rules& FieldRules::sint64() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.sint64)
  return _internal_sint64();
}
inline ::validate::SInt64Rules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_sint64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.sint64)
  if (type_case() == kSint64) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::SInt64Rules*>(_impl_.type_.sint64_);
    _impl_.type_.sint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_sint64(
    ::validate::SInt64Rules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_sint64();
    _impl_.type_.sint64_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.sint64)
}
inline ::validate::SInt64Rules* PROTOBUF_NONNULL FieldRules::_internal_mutable_sint64() {
  if (type_case() != kSint64) {
    clear_type();
    set_has_sint64();
    _impl_.type_.sint64_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::SInt64Rules>(GetArena()));
  }
  return reinterpret_cast<::validate::SInt64Rules*>(_impl_.type_.sint64_);
}
inline ::validate::SInt64Rules* PROTOBUF_NONNULL FieldRules::mutable_sint64()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::SInt64Rules* _msg = _internal_mutable_sint64();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.sint64)
  return _msg;
}

// .validate.Fixed32Rules fixed32 = 9;
inline bool FieldRules::has_fixed32() const {
  return type_case() == kFixed32;
}
inline bool FieldRules::_internal_has_fixed32() const {
  return type_case() == kFixed32;
}
inline void FieldRules::set_has_fixed32() {
  _impl_._oneof_case_[0] = kFixed32;
}
inline void FieldRules::clear_fixed32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kFixed32) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.fixed32_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.fixed32_);
    }
    clear_has_type();
  }
}
inline ::validate::Fixed32Rules* PROTOBUF_NULLABLE FieldRules::release_fixed32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.fixed32)
  if (type_case() == kFixed32) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::Fixed32Rules*>(_impl_.type_.fixed32_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.fixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::Fixed32Rules& FieldRules::_internal_fixed32() const {
  return type_case() == kFixed32 ? *reinterpret_cast<::validate::Fixed32Rules*>(_impl_.type_.fixed32_) : reinterpret_cast<::validate::Fixed32Rules&>(::validate::_Fixed32Rules_default_instance_);
}
inline const ::validate::Fixed32Rules& FieldRules::fixed32() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.fixed32)
  return _internal_fixed32();
}
inline ::validate::Fixed32Rules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_fixed32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.fixed32)
  if (type_case() == kFixed32) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::Fixed32Rules*>(_impl_.type_.fixed32_);
    _impl_.type_.fixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_fixed32(
    ::validate::Fixed32Rules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_fixed32();
    _impl_.type_.fixed32_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.fixed32)
}
inline ::validate::Fixed32Rules* PROTOBUF_NONNULL FieldRules::_internal_mutable_fixed32() {
  if (type_case() != kFixed32) {
    clear_type();
    set_has_fixed32();
    _impl_.type_.fixed32_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::Fixed32Rules>(GetArena()));
  }
  return reinterpret_cast<::validate::Fixed32Rules*>(_impl_.type_.fixed32_);
}
inline ::validate::Fixed32Rules* PROTOBUF_NONNULL FieldRules::mutable_fixed32()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::Fixed32Rules* _msg = _internal_mutable_fixed32();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.fixed32)
  return _msg;
}

// .validate.Fixed64Rules fixed64 = 10;
inline bool FieldRules::has_fixed64() const {
  return type_case() == kFixed64;
}
inline bool FieldRules::_internal_has_fixed64() const {
  return type_case() == kFixed64;
}
inline void FieldRules::set_has_fixed64() {
  _impl_._oneof_case_[0] = kFixed64;
}
inline void FieldRules::clear_fixed64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kFixed64) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.fixed64_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.fixed64_);
    }
    clear_has_type();
  }
}
inline ::validate::Fixed64Rules* PROTOBUF_NULLABLE FieldRules::release_fixed64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.fixed64)
  if (type_case() == kFixed64) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::Fixed64Rules*>(_impl_.type_.fixed64_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.fixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::Fixed64Rules& FieldRules::_internal_fixed64() const {
  return type_case() == kFixed64 ? *reinterpret_cast<::validate::Fixed64Rules*>(_impl_.type_.fixed64_) : reinterpret_cast<::validate::Fixed64Rules&>(::validate::_Fixed64Rules_default_instance_);
}
inline const ::validate::Fixed64Rules& FieldRules::fixed64() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.fixed64)
  return _internal_fixed64();
}
inline ::validate::Fixed64Rules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_fixed64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.fixed64)
  if (type_case() == kFixed64) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::Fixed64Rules*>(_impl_.type_.fixed64_);
    _impl_.type_.fixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_fixed64(
    ::validate::Fixed64Rules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_fixed64();
    _impl_.type_.fixed64_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.fixed64)
}
inline ::validate::Fixed64Rules* PROTOBUF_NONNULL FieldRules::_internal_mutable_fixed64() {
  if (type_case() != kFixed64) {
    clear_type();
    set_has_fixed64();
    _impl_.type_.fixed64_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::Fixed64Rules>(GetArena()));
  }
  return reinterpret_cast<::validate::Fixed64Rules*>(_impl_.type_.fixed64_);
}
inline ::validate::Fixed64Rules* PROTOBUF_NONNULL FieldRules::mutable_fixed64()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::Fixed64Rules* _msg = _internal_mutable_fixed64();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.fixed64)
  return _msg;
}

// .validate.SFixed32Rules sfixed32 = 11;
inline bool FieldRules::has_sfixed32() const {
  return type_case() == kSfixed32;
}
inline bool FieldRules::_internal_has_sfixed32() const {
  return type_case() == kSfixed32;
}
inline void FieldRules::set_has_sfixed32() {
  _impl_._oneof_case_[0] = kSfixed32;
}
inline void FieldRules::clear_sfixed32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kSfixed32) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.sfixed32_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sfixed32_);
    }
    clear_has_type();
  }
}
inline ::validate::SFixed32Rules* PROTOBUF_NULLABLE FieldRules::release_sfixed32() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.sfixed32)
  if (type_case() == kSfixed32) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::SFixed32Rules*>(_impl_.type_.sfixed32_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sfixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::SFixed32Rules& FieldRules::_internal_sfixed32() const {
  return type_case() == kSfixed32 ? *reinterpret_cast<::validate::SFixed32Rules*>(_impl_.type_.sfixed32_) : reinterpret_cast<::validate::SFixed32Rules&>(::validate::_SFixed32Rules_default_instance_);
}
inline const ::validate::SFixed32Rules& FieldRules::sfixed32() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.sfixed32)
  return _internal_sfixed32();
}
inline ::validate::SFixed32Rules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_sfixed32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.sfixed32)
  if (type_case() == kSfixed32) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::SFixed32Rules*>(_impl_.type_.sfixed32_);
    _impl_.type_.sfixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_sfixed32(
    ::validate::SFixed32Rules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_sfixed32();
    _impl_.type_.sfixed32_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.sfixed32)
}
inline ::validate::SFixed32Rules* PROTOBUF_NONNULL FieldRules::_internal_mutable_sfixed32() {
  if (type_case() != kSfixed32) {
    clear_type();
    set_has_sfixed32();
    _impl_.type_.sfixed32_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::SFixed32Rules>(GetArena()));
  }
  return reinterpret_cast<::validate::SFixed32Rules*>(_impl_.type_.sfixed32_);
}
inline ::validate::SFixed32Rules* PROTOBUF_NONNULL FieldRules::mutable_sfixed32()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::SFixed32Rules* _msg = _internal_mutable_sfixed32();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.sfixed32)
  return _msg;
}

// .validate.SFixed64Rules sfixed64 = 12;
inline bool FieldRules::has_sfixed64() const {
  return type_case() == kSfixed64;
}
inline bool FieldRules::_internal_has_sfixed64() const {
  return type_case() == kSfixed64;
}
inline void FieldRules::set_has_sfixed64() {
  _impl_._oneof_case_[0] = kSfixed64;
}
inline void FieldRules::clear_sfixed64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kSfixed64) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.sfixed64_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sfixed64_);
    }
    clear_has_type();
  }
}
inline ::validate::SFixed64Rules* PROTOBUF_NULLABLE FieldRules::release_sfixed64() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.sfixed64)
  if (type_case() == kSfixed64) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::SFixed64Rules*>(_impl_.type_.sfixed64_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sfixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::SFixed64Rules& FieldRules::_internal_sfixed64() const {
  return type_case() == kSfixed64 ? *reinterpret_cast<::validate::SFixed64Rules*>(_impl_.type_.sfixed64_) : reinterpret_cast<::validate::SFixed64Rules&>(::validate::_SFixed64Rules_default_instance_);
}
inline const ::validate::SFixed64Rules& FieldRules::sfixed64() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.sfixed64)
  return _internal_sfixed64();
}
inline ::validate::SFixed64Rules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_sfixed64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.sfixed64)
  if (type_case() == kSfixed64) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::SFixed64Rules*>(_impl_.type_.sfixed64_);
    _impl_.type_.sfixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_sfixed64(
    ::validate::SFixed64Rules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_sfixed64();
    _impl_.type_.sfixed64_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.sfixed64)
}
inline ::validate::SFixed64Rules* PROTOBUF_NONNULL FieldRules::_internal_mutable_sfixed64() {
  if (type_case() != kSfixed64) {
    clear_type();
    set_has_sfixed64();
    _impl_.type_.sfixed64_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::SFixed64Rules>(GetArena()));
  }
  return reinterpret_cast<::validate::SFixed64Rules*>(_impl_.type_.sfixed64_);
}
inline ::validate::SFixed64Rules* PROTOBUF_NONNULL FieldRules::mutable_sfixed64()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::SFixed64Rules* _msg = _internal_mutable_sfixed64();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.sfixed64)
  return _msg;
}

// .validate.BoolRules bool = 13;
inline bool FieldRules::has_bool_() const {
  return type_case() == kBool;
}
inline bool FieldRules::_internal_has_bool_() const {
  return type_case() == kBool;
}
inline void FieldRules::set_has_bool_() {
  _impl_._oneof_case_[0] = kBool;
}
inline void FieldRules::clear_bool_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kBool) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.bool__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.bool__);
    }
    clear_has_type();
  }
}
inline ::validate::BoolRules* PROTOBUF_NULLABLE FieldRules::release_bool_() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.bool)
  if (type_case() == kBool) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::BoolRules*>(_impl_.type_.bool__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::BoolRules& FieldRules::_internal_bool_() const {
  return type_case() == kBool ? *reinterpret_cast<::validate::BoolRules*>(_impl_.type_.bool__) : reinterpret_cast<::validate::BoolRules&>(::validate::_BoolRules_default_instance_);
}
inline const ::validate::BoolRules& FieldRules::bool_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.bool)
  return _internal_bool_();
}
inline ::validate::BoolRules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_bool_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.bool)
  if (type_case() == kBool) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::BoolRules*>(_impl_.type_.bool__);
    _impl_.type_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_bool_(
    ::validate::BoolRules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_bool_();
    _impl_.type_.bool__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.bool)
}
inline ::validate::BoolRules* PROTOBUF_NONNULL FieldRules::_internal_mutable_bool_() {
  if (type_case() != kBool) {
    clear_type();
    set_has_bool_();
    _impl_.type_.bool__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::BoolRules>(GetArena()));
  }
  return reinterpret_cast<::validate::BoolRules*>(_impl_.type_.bool__);
}
inline ::validate::BoolRules* PROTOBUF_NONNULL FieldRules::mutable_bool_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::BoolRules* _msg = _internal_mutable_bool_();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.bool)
  return _msg;
}

// .validate.StringRules string = 14;
inline bool FieldRules::has_string() const {
  return type_case() == kString;
}
inline bool FieldRules::_internal_has_string() const {
  return type_case() == kString;
}
inline void FieldRules::set_has_string() {
  _impl_._oneof_case_[0] = kString;
}
inline void FieldRules::clear_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kString) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.string_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.string_);
    }
    clear_has_type();
  }
}
inline ::validate::StringRules* PROTOBUF_NULLABLE FieldRules::release_string() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.string)
  if (type_case() == kString) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::StringRules*>(_impl_.type_.string_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::StringRules& FieldRules::_internal_string() const {
  return type_case() == kString ? *reinterpret_cast<::validate::StringRules*>(_impl_.type_.string_) : reinterpret_cast<::validate::StringRules&>(::validate::_StringRules_default_instance_);
}
inline const ::validate::StringRules& FieldRules::string() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.string)
  return _internal_string();
}
inline ::validate::StringRules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.string)
  if (type_case() == kString) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::StringRules*>(_impl_.type_.string_);
    _impl_.type_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_string(
    ::validate::StringRules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_string();
    _impl_.type_.string_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.string)
}
inline ::validate::StringRules* PROTOBUF_NONNULL FieldRules::_internal_mutable_string() {
  if (type_case() != kString) {
    clear_type();
    set_has_string();
    _impl_.type_.string_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::StringRules>(GetArena()));
  }
  return reinterpret_cast<::validate::StringRules*>(_impl_.type_.string_);
}
inline ::validate::StringRules* PROTOBUF_NONNULL FieldRules::mutable_string()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::StringRules* _msg = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.string)
  return _msg;
}

// .validate.BytesRules bytes = 15;
inline bool FieldRules::has_bytes() const {
  return type_case() == kBytes;
}
inline bool FieldRules::_internal_has_bytes() const {
  return type_case() == kBytes;
}
inline void FieldRules::set_has_bytes() {
  _impl_._oneof_case_[0] = kBytes;
}
inline void FieldRules::clear_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kBytes) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.bytes_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.bytes_);
    }
    clear_has_type();
  }
}
inline ::validate::BytesRules* PROTOBUF_NULLABLE FieldRules::release_bytes() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.bytes)
  if (type_case() == kBytes) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::BytesRules*>(_impl_.type_.bytes_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::BytesRules& FieldRules::_internal_bytes() const {
  return type_case() == kBytes ? *reinterpret_cast<::validate::BytesRules*>(_impl_.type_.bytes_) : reinterpret_cast<::validate::BytesRules&>(::validate::_BytesRules_default_instance_);
}
inline const ::validate::BytesRules& FieldRules::bytes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.bytes)
  return _internal_bytes();
}
inline ::validate::BytesRules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_bytes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.bytes)
  if (type_case() == kBytes) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::BytesRules*>(_impl_.type_.bytes_);
    _impl_.type_.bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_bytes(
    ::validate::BytesRules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_bytes();
    _impl_.type_.bytes_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.bytes)
}
inline ::validate::BytesRules* PROTOBUF_NONNULL FieldRules::_internal_mutable_bytes() {
  if (type_case() != kBytes) {
    clear_type();
    set_has_bytes();
    _impl_.type_.bytes_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::BytesRules>(GetArena()));
  }
  return reinterpret_cast<::validate::BytesRules*>(_impl_.type_.bytes_);
}
inline ::validate::BytesRules* PROTOBUF_NONNULL FieldRules::mutable_bytes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::BytesRules* _msg = _internal_mutable_bytes();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.bytes)
  return _msg;
}

// .validate.EnumRules enum = 16;
inline bool FieldRules::has_enum_() const {
  return type_case() == kEnum;
}
inline bool FieldRules::_internal_has_enum_() const {
  return type_case() == kEnum;
}
inline void FieldRules::set_has_enum_() {
  _impl_._oneof_case_[0] = kEnum;
}
inline void FieldRules::clear_enum_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kEnum) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.enum__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.enum__);
    }
    clear_has_type();
  }
}
inline ::validate::EnumRules* PROTOBUF_NULLABLE FieldRules::release_enum_() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.enum)
  if (type_case() == kEnum) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::EnumRules*>(_impl_.type_.enum__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.enum__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::EnumRules& FieldRules::_internal_enum_() const {
  return type_case() == kEnum ? *reinterpret_cast<::validate::EnumRules*>(_impl_.type_.enum__) : reinterpret_cast<::validate::EnumRules&>(::validate::_EnumRules_default_instance_);
}
inline const ::validate::EnumRules& FieldRules::enum_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.enum)
  return _internal_enum_();
}
inline ::validate::EnumRules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_enum_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.enum)
  if (type_case() == kEnum) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::EnumRules*>(_impl_.type_.enum__);
    _impl_.type_.enum__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_enum_(
    ::validate::EnumRules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_enum_();
    _impl_.type_.enum__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.enum)
}
inline ::validate::EnumRules* PROTOBUF_NONNULL FieldRules::_internal_mutable_enum_() {
  if (type_case() != kEnum) {
    clear_type();
    set_has_enum_();
    _impl_.type_.enum__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::EnumRules>(GetArena()));
  }
  return reinterpret_cast<::validate::EnumRules*>(_impl_.type_.enum__);
}
inline ::validate::EnumRules* PROTOBUF_NONNULL FieldRules::mutable_enum_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::EnumRules* _msg = _internal_mutable_enum_();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.enum)
  return _msg;
}

// .validate.RepeatedRules repeated = 18;
inline bool FieldRules::has_repeated() const {
  return type_case() == kRepeated;
}
inline bool FieldRules::_internal_has_repeated() const {
  return type_case() == kRepeated;
}
inline void FieldRules::set_has_repeated() {
  _impl_._oneof_case_[0] = kRepeated;
}
inline void FieldRules::clear_repeated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kRepeated) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.repeated_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.repeated_);
    }
    clear_has_type();
  }
}
inline ::validate::RepeatedRules* PROTOBUF_NULLABLE FieldRules::release_repeated() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.repeated)
  if (type_case() == kRepeated) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::RepeatedRules*>(_impl_.type_.repeated_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.repeated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::RepeatedRules& FieldRules::_internal_repeated() const {
  return type_case() == kRepeated ? *reinterpret_cast<::validate::RepeatedRules*>(_impl_.type_.repeated_) : reinterpret_cast<::validate::RepeatedRules&>(::validate::_RepeatedRules_default_instance_);
}
inline const ::validate::RepeatedRules& FieldRules::repeated() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.repeated)
  return _internal_repeated();
}
inline ::validate::RepeatedRules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_repeated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.repeated)
  if (type_case() == kRepeated) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::RepeatedRules*>(_impl_.type_.repeated_);
    _impl_.type_.repeated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_repeated(
    ::validate::RepeatedRules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_repeated();
    _impl_.type_.repeated_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.repeated)
}
inline ::validate::RepeatedRules* PROTOBUF_NONNULL FieldRules::_internal_mutable_repeated() {
  if (type_case() != kRepeated) {
    clear_type();
    set_has_repeated();
    _impl_.type_.repeated_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::RepeatedRules>(GetArena()));
  }
  return reinterpret_cast<::validate::RepeatedRules*>(_impl_.type_.repeated_);
}
inline ::validate::RepeatedRules* PROTOBUF_NONNULL FieldRules::mutable_repeated()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::RepeatedRules* _msg = _internal_mutable_repeated();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.repeated)
  return _msg;
}

// .validate.MapRules map = 19;
inline bool FieldRules::has_map() const {
  return type_case() == kMap;
}
inline bool FieldRules::_internal_has_map() const {
  return type_case() == kMap;
}
inline void FieldRules::set_has_map() {
  _impl_._oneof_case_[0] = kMap;
}
inline void FieldRules::clear_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kMap) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.map_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.map_);
    }
    clear_has_type();
  }
}
inline ::validate::MapRules* PROTOBUF_NULLABLE FieldRules::release_map() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.map)
  if (type_case() == kMap) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::MapRules*>(_impl_.type_.map_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::MapRules& FieldRules::_internal_map() const {
  return type_case() == kMap ? *reinterpret_cast<::validate::MapRules*>(_impl_.type_.map_) : reinterpret_cast<::validate::MapRules&>(::validate::_MapRules_default_instance_);
}
inline const ::validate::MapRules& FieldRules::map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.map)
  return _internal_map();
}
inline ::validate::MapRules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.map)
  if (type_case() == kMap) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::MapRules*>(_impl_.type_.map_);
    _impl_.type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_map(
    ::validate::MapRules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_map();
    _impl_.type_.map_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.map)
}
inline ::validate::MapRules* PROTOBUF_NONNULL FieldRules::_internal_mutable_map() {
  if (type_case() != kMap) {
    clear_type();
    set_has_map();
    _impl_.type_.map_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::MapRules>(GetArena()));
  }
  return reinterpret_cast<::validate::MapRules*>(_impl_.type_.map_);
}
inline ::validate::MapRules* PROTOBUF_NONNULL FieldRules::mutable_map()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::MapRules* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.map)
  return _msg;
}

// .validate.AnyRules any = 20;
inline bool FieldRules::has_any() const {
  return type_case() == kAny;
}
inline bool FieldRules::_internal_has_any() const {
  return type_case() == kAny;
}
inline void FieldRules::set_has_any() {
  _impl_._oneof_case_[0] = kAny;
}
inline void FieldRules::clear_any() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kAny) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.any_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.any_);
    }
    clear_has_type();
  }
}
inline ::validate::AnyRules* PROTOBUF_NULLABLE FieldRules::release_any() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.any)
  if (type_case() == kAny) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::AnyRules*>(_impl_.type_.any_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.any_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::AnyRules& FieldRules::_internal_any() const {
  return type_case() == kAny ? *reinterpret_cast<::validate::AnyRules*>(_impl_.type_.any_) : reinterpret_cast<::validate::AnyRules&>(::validate::_AnyRules_default_instance_);
}
inline const ::validate::AnyRules& FieldRules::any() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.any)
  return _internal_any();
}
inline ::validate::AnyRules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_any() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.any)
  if (type_case() == kAny) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::AnyRules*>(_impl_.type_.any_);
    _impl_.type_.any_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_any(
    ::validate::AnyRules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_any();
    _impl_.type_.any_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.any)
}
inline ::validate::AnyRules* PROTOBUF_NONNULL FieldRules::_internal_mutable_any() {
  if (type_case() != kAny) {
    clear_type();
    set_has_any();
    _impl_.type_.any_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::AnyRules>(GetArena()));
  }
  return reinterpret_cast<::validate::AnyRules*>(_impl_.type_.any_);
}
inline ::validate::AnyRules* PROTOBUF_NONNULL FieldRules::mutable_any()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::AnyRules* _msg = _internal_mutable_any();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.any)
  return _msg;
}

// .validate.DurationRules duration = 21;
inline bool FieldRules::has_duration() const {
  return type_case() == kDuration;
}
inline bool FieldRules::_internal_has_duration() const {
  return type_case() == kDuration;
}
inline void FieldRules::set_has_duration() {
  _impl_._oneof_case_[0] = kDuration;
}
inline void FieldRules::clear_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kDuration) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.duration_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.duration_);
    }
    clear_has_type();
  }
}
inline ::validate::DurationRules* PROTOBUF_NULLABLE FieldRules::release_duration() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.duration)
  if (type_case() == kDuration) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::DurationRules*>(_impl_.type_.duration_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::DurationRules& FieldRules::_internal_duration() const {
  return type_case() == kDuration ? *reinterpret_cast<::validate::DurationRules*>(_impl_.type_.duration_) : reinterpret_cast<::validate::DurationRules&>(::validate::_DurationRules_default_instance_);
}
inline const ::validate::DurationRules& FieldRules::duration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.duration)
  return _internal_duration();
}
inline ::validate::DurationRules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.duration)
  if (type_case() == kDuration) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::DurationRules*>(_impl_.type_.duration_);
    _impl_.type_.duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_duration(
    ::validate::DurationRules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_duration();
    _impl_.type_.duration_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.duration)
}
inline ::validate::DurationRules* PROTOBUF_NONNULL FieldRules::_internal_mutable_duration() {
  if (type_case() != kDuration) {
    clear_type();
    set_has_duration();
    _impl_.type_.duration_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::DurationRules>(GetArena()));
  }
  return reinterpret_cast<::validate::DurationRules*>(_impl_.type_.duration_);
}
inline ::validate::DurationRules* PROTOBUF_NONNULL FieldRules::mutable_duration()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::DurationRules* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.duration)
  return _msg;
}

// .validate.TimestampRules timestamp = 22;
inline bool FieldRules::has_timestamp() const {
  return type_case() == kTimestamp;
}
inline bool FieldRules::_internal_has_timestamp() const {
  return type_case() == kTimestamp;
}
inline void FieldRules::set_has_timestamp() {
  _impl_._oneof_case_[0] = kTimestamp;
}
inline void FieldRules::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kTimestamp) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.timestamp_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.timestamp_);
    }
    clear_has_type();
  }
}
inline ::validate::TimestampRules* PROTOBUF_NULLABLE FieldRules::release_timestamp() {
  // @@protoc_insertion_point(field_release:validate.FieldRules.timestamp)
  if (type_case() == kTimestamp) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::TimestampRules*>(_impl_.type_.timestamp_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::validate::TimestampRules& FieldRules::_internal_timestamp() const {
  return type_case() == kTimestamp ? *reinterpret_cast<::validate::TimestampRules*>(_impl_.type_.timestamp_) : reinterpret_cast<::validate::TimestampRules&>(::validate::_TimestampRules_default_instance_);
}
inline const ::validate::TimestampRules& FieldRules::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.FieldRules.timestamp)
  return _internal_timestamp();
}
inline ::validate::TimestampRules* PROTOBUF_NULLABLE FieldRules::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:validate.FieldRules.timestamp)
  if (type_case() == kTimestamp) {
    clear_has_type();
    auto* temp = reinterpret_cast<::validate::TimestampRules*>(_impl_.type_.timestamp_);
    _impl_.type_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldRules::unsafe_arena_set_allocated_timestamp(
    ::validate::TimestampRules* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_timestamp();
    _impl_.type_.timestamp_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.FieldRules.timestamp)
}
inline ::validate::TimestampRules* PROTOBUF_NONNULL FieldRules::_internal_mutable_timestamp() {
  if (type_case() != kTimestamp) {
    clear_type();
    set_has_timestamp();
    _impl_.type_.timestamp_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::validate::TimestampRules>(GetArena()));
  }
  return reinterpret_cast<::validate::TimestampRules*>(_impl_.type_.timestamp_);
}
inline ::validate::TimestampRules* PROTOBUF_NONNULL FieldRules::mutable_timestamp()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::validate::TimestampRules* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:validate.FieldRules.timestamp)
  return _msg;
}

inline bool FieldRules::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void FieldRules::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline FieldRules::TypeCase FieldRules::type_case() const {
  return FieldRules::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FloatRules

// optional float const = 1;
inline bool FloatRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FloatRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float FloatRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.const)
  return _internal_const_();
}
inline void FloatRules::set_const_(float value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.FloatRules.const)
}
inline float FloatRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void FloatRules::_internal_set_const_(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional float lt = 2;
inline bool FloatRules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FloatRules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float FloatRules::lt() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.lt)
  return _internal_lt();
}
inline void FloatRules::set_lt(float value) {
  _internal_set_lt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.FloatRules.lt)
}
inline float FloatRules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void FloatRules::_internal_set_lt(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional float lte = 3;
inline bool FloatRules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FloatRules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float FloatRules::lte() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.lte)
  return _internal_lte();
}
inline void FloatRules::set_lte(float value) {
  _internal_set_lte(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.FloatRules.lte)
}
inline float FloatRules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void FloatRules::_internal_set_lte(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// optional float gt = 4;
inline bool FloatRules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FloatRules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float FloatRules::gt() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.gt)
  return _internal_gt();
}
inline void FloatRules::set_gt(float value) {
  _internal_set_gt(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.FloatRules.gt)
}
inline float FloatRules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void FloatRules::_internal_set_gt(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional float gte = 5;
inline bool FloatRules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void FloatRules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float FloatRules::gte() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.gte)
  return _internal_gte();
}
inline void FloatRules::set_gte(float value) {
  _internal_set_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.FloatRules.gte)
}
inline float FloatRules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void FloatRules::_internal_set_gte(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// repeated float in = 6;
inline int FloatRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int FloatRules::in_size() const {
  return _internal_in_size();
}
inline void FloatRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline float FloatRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.in)
  return _internal_in().Get(index);
}
inline void FloatRules::set_in(int index, float value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.FloatRules.in)
}
inline void FloatRules::add_in(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.FloatRules.in)
}
inline const ::google::protobuf::RepeatedField<float>& FloatRules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.FloatRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL FloatRules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.FloatRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<float>&
FloatRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL
FloatRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated float not_in = 7;
inline int FloatRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int FloatRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void FloatRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline float FloatRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.not_in)
  return _internal_not_in().Get(index);
}
inline void FloatRules::set_not_in(int index, float value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.FloatRules.not_in)
}
inline void FloatRules::add_not_in(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.FloatRules.not_in)
}
inline const ::google::protobuf::RepeatedField<float>& FloatRules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.FloatRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL FloatRules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.FloatRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<float>&
FloatRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL
FloatRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool ignore_empty = 8;
inline bool FloatRules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void FloatRules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool FloatRules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.FloatRules.ignore_empty)
  return _internal_ignore_empty();
}
inline void FloatRules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.FloatRules.ignore_empty)
}
inline bool FloatRules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void FloatRules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// DoubleRules

// optional double const = 1;
inline bool DoubleRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DoubleRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double DoubleRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.const)
  return _internal_const_();
}
inline void DoubleRules::set_const_(double value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.const)
}
inline double DoubleRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void DoubleRules::_internal_set_const_(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional double lt = 2;
inline bool DoubleRules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DoubleRules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double DoubleRules::lt() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.lt)
  return _internal_lt();
}
inline void DoubleRules::set_lt(double value) {
  _internal_set_lt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.lt)
}
inline double DoubleRules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void DoubleRules::_internal_set_lt(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional double lte = 3;
inline bool DoubleRules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DoubleRules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double DoubleRules::lte() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.lte)
  return _internal_lte();
}
inline void DoubleRules::set_lte(double value) {
  _internal_set_lte(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.lte)
}
inline double DoubleRules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void DoubleRules::_internal_set_lte(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// optional double gt = 4;
inline bool DoubleRules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DoubleRules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double DoubleRules::gt() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.gt)
  return _internal_gt();
}
inline void DoubleRules::set_gt(double value) {
  _internal_set_gt(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.gt)
}
inline double DoubleRules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void DoubleRules::_internal_set_gt(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional double gte = 5;
inline bool DoubleRules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void DoubleRules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double DoubleRules::gte() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.gte)
  return _internal_gte();
}
inline void DoubleRules::set_gte(double value) {
  _internal_set_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.gte)
}
inline double DoubleRules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void DoubleRules::_internal_set_gte(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// repeated double in = 6;
inline int DoubleRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int DoubleRules::in_size() const {
  return _internal_in_size();
}
inline void DoubleRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline double DoubleRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.in)
  return _internal_in().Get(index);
}
inline void DoubleRules::set_in(int index, double value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.DoubleRules.in)
}
inline void DoubleRules::add_in(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.DoubleRules.in)
}
inline const ::google::protobuf::RepeatedField<double>& DoubleRules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.DoubleRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL DoubleRules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.DoubleRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<double>&
DoubleRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL
DoubleRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated double not_in = 7;
inline int DoubleRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int DoubleRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void DoubleRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline double DoubleRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.not_in)
  return _internal_not_in().Get(index);
}
inline void DoubleRules::set_not_in(int index, double value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.DoubleRules.not_in)
}
inline void DoubleRules::add_not_in(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.DoubleRules.not_in)
}
inline const ::google::protobuf::RepeatedField<double>& DoubleRules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.DoubleRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL DoubleRules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.DoubleRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<double>&
DoubleRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL
DoubleRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool ignore_empty = 8;
inline bool DoubleRules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void DoubleRules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool DoubleRules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.DoubleRules.ignore_empty)
  return _internal_ignore_empty();
}
inline void DoubleRules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.DoubleRules.ignore_empty)
}
inline bool DoubleRules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void DoubleRules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// Int32Rules

// optional int32 const = 1;
inline bool Int32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Int32Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Int32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.const)
  return _internal_const_();
}
inline void Int32Rules::set_const_(::int32_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.const)
}
inline ::int32_t Int32Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void Int32Rules::_internal_set_const_(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional int32 lt = 2;
inline bool Int32Rules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Int32Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Int32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.lt)
  return _internal_lt();
}
inline void Int32Rules::set_lt(::int32_t value) {
  _internal_set_lt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.lt)
}
inline ::int32_t Int32Rules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void Int32Rules::_internal_set_lt(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional int32 lte = 3;
inline bool Int32Rules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Int32Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t Int32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.lte)
  return _internal_lte();
}
inline void Int32Rules::set_lte(::int32_t value) {
  _internal_set_lte(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.lte)
}
inline ::int32_t Int32Rules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void Int32Rules::_internal_set_lte(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// optional int32 gt = 4;
inline bool Int32Rules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Int32Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t Int32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.gt)
  return _internal_gt();
}
inline void Int32Rules::set_gt(::int32_t value) {
  _internal_set_gt(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.gt)
}
inline ::int32_t Int32Rules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void Int32Rules::_internal_set_gt(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional int32 gte = 5;
inline bool Int32Rules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Int32Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t Int32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.gte)
  return _internal_gte();
}
inline void Int32Rules::set_gte(::int32_t value) {
  _internal_set_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.gte)
}
inline ::int32_t Int32Rules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void Int32Rules::_internal_set_gte(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// repeated int32 in = 6;
inline int Int32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int Int32Rules::in_size() const {
  return _internal_in_size();
}
inline void Int32Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int32_t Int32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.in)
  return _internal_in().Get(index);
}
inline void Int32Rules::set_in(int index, ::int32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Int32Rules.in)
}
inline void Int32Rules::add_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.Int32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Int32Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.Int32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL Int32Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.Int32Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
Int32Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
Int32Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated int32 not_in = 7;
inline int Int32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int Int32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void Int32Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int32_t Int32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void Int32Rules::set_not_in(int index, ::int32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Int32Rules.not_in)
}
inline void Int32Rules::add_not_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.Int32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Int32Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.Int32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL Int32Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.Int32Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
Int32Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
Int32Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool ignore_empty = 8;
inline bool Int32Rules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Int32Rules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Int32Rules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.Int32Rules.ignore_empty)
  return _internal_ignore_empty();
}
inline void Int32Rules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.Int32Rules.ignore_empty)
}
inline bool Int32Rules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void Int32Rules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// Int64Rules

// optional int64 const = 1;
inline bool Int64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Int64Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t Int64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.const)
  return _internal_const_();
}
inline void Int64Rules::set_const_(::int64_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.const)
}
inline ::int64_t Int64Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void Int64Rules::_internal_set_const_(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional int64 lt = 2;
inline bool Int64Rules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Int64Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t Int64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.lt)
  return _internal_lt();
}
inline void Int64Rules::set_lt(::int64_t value) {
  _internal_set_lt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.lt)
}
inline ::int64_t Int64Rules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void Int64Rules::_internal_set_lt(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional int64 lte = 3;
inline bool Int64Rules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Int64Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t Int64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.lte)
  return _internal_lte();
}
inline void Int64Rules::set_lte(::int64_t value) {
  _internal_set_lte(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.lte)
}
inline ::int64_t Int64Rules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void Int64Rules::_internal_set_lte(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// optional int64 gt = 4;
inline bool Int64Rules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Int64Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t Int64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.gt)
  return _internal_gt();
}
inline void Int64Rules::set_gt(::int64_t value) {
  _internal_set_gt(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.gt)
}
inline ::int64_t Int64Rules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void Int64Rules::_internal_set_gt(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional int64 gte = 5;
inline bool Int64Rules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Int64Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t Int64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.gte)
  return _internal_gte();
}
inline void Int64Rules::set_gte(::int64_t value) {
  _internal_set_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.gte)
}
inline ::int64_t Int64Rules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void Int64Rules::_internal_set_gte(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// repeated int64 in = 6;
inline int Int64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int Int64Rules::in_size() const {
  return _internal_in_size();
}
inline void Int64Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int64_t Int64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.in)
  return _internal_in().Get(index);
}
inline void Int64Rules::set_in(int index, ::int64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Int64Rules.in)
}
inline void Int64Rules::add_in(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.Int64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Int64Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.Int64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL Int64Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.Int64Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
Int64Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
Int64Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated int64 not_in = 7;
inline int Int64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int Int64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void Int64Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int64_t Int64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void Int64Rules::set_not_in(int index, ::int64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Int64Rules.not_in)
}
inline void Int64Rules::add_not_in(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.Int64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Int64Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.Int64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL Int64Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.Int64Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
Int64Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
Int64Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool ignore_empty = 8;
inline bool Int64Rules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Int64Rules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Int64Rules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.Int64Rules.ignore_empty)
  return _internal_ignore_empty();
}
inline void Int64Rules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.Int64Rules.ignore_empty)
}
inline bool Int64Rules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void Int64Rules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// UInt32Rules

// optional uint32 const = 1;
inline bool UInt32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UInt32Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t UInt32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.const)
  return _internal_const_();
}
inline void UInt32Rules::set_const_(::uint32_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.const)
}
inline ::uint32_t UInt32Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void UInt32Rules::_internal_set_const_(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional uint32 lt = 2;
inline bool UInt32Rules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UInt32Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t UInt32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.lt)
  return _internal_lt();
}
inline void UInt32Rules::set_lt(::uint32_t value) {
  _internal_set_lt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.lt)
}
inline ::uint32_t UInt32Rules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void UInt32Rules::_internal_set_lt(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional uint32 lte = 3;
inline bool UInt32Rules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UInt32Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t UInt32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.lte)
  return _internal_lte();
}
inline void UInt32Rules::set_lte(::uint32_t value) {
  _internal_set_lte(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.lte)
}
inline ::uint32_t UInt32Rules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void UInt32Rules::_internal_set_lte(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// optional uint32 gt = 4;
inline bool UInt32Rules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UInt32Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t UInt32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.gt)
  return _internal_gt();
}
inline void UInt32Rules::set_gt(::uint32_t value) {
  _internal_set_gt(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.gt)
}
inline ::uint32_t UInt32Rules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void UInt32Rules::_internal_set_gt(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional uint32 gte = 5;
inline bool UInt32Rules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UInt32Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t UInt32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.gte)
  return _internal_gte();
}
inline void UInt32Rules::set_gte(::uint32_t value) {
  _internal_set_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.gte)
}
inline ::uint32_t UInt32Rules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void UInt32Rules::_internal_set_gte(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// repeated uint32 in = 6;
inline int UInt32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int UInt32Rules::in_size() const {
  return _internal_in_size();
}
inline void UInt32Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::uint32_t UInt32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.in)
  return _internal_in().Get(index);
}
inline void UInt32Rules::set_in(int index, ::uint32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.in)
}
inline void UInt32Rules::add_in(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.UInt32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& UInt32Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.UInt32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL UInt32Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.UInt32Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
UInt32Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
UInt32Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated uint32 not_in = 7;
inline int UInt32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int UInt32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void UInt32Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::uint32_t UInt32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void UInt32Rules::set_not_in(int index, ::uint32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.not_in)
}
inline void UInt32Rules::add_not_in(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.UInt32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& UInt32Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.UInt32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL UInt32Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.UInt32Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
UInt32Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
UInt32Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool ignore_empty = 8;
inline bool UInt32Rules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UInt32Rules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool UInt32Rules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.UInt32Rules.ignore_empty)
  return _internal_ignore_empty();
}
inline void UInt32Rules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.UInt32Rules.ignore_empty)
}
inline bool UInt32Rules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void UInt32Rules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// UInt64Rules

// optional uint64 const = 1;
inline bool UInt64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UInt64Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t UInt64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.const)
  return _internal_const_();
}
inline void UInt64Rules::set_const_(::uint64_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.const)
}
inline ::uint64_t UInt64Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void UInt64Rules::_internal_set_const_(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional uint64 lt = 2;
inline bool UInt64Rules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UInt64Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t UInt64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.lt)
  return _internal_lt();
}
inline void UInt64Rules::set_lt(::uint64_t value) {
  _internal_set_lt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.lt)
}
inline ::uint64_t UInt64Rules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void UInt64Rules::_internal_set_lt(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional uint64 lte = 3;
inline bool UInt64Rules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UInt64Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t UInt64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.lte)
  return _internal_lte();
}
inline void UInt64Rules::set_lte(::uint64_t value) {
  _internal_set_lte(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.lte)
}
inline ::uint64_t UInt64Rules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void UInt64Rules::_internal_set_lte(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// optional uint64 gt = 4;
inline bool UInt64Rules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UInt64Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t UInt64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.gt)
  return _internal_gt();
}
inline void UInt64Rules::set_gt(::uint64_t value) {
  _internal_set_gt(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.gt)
}
inline ::uint64_t UInt64Rules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void UInt64Rules::_internal_set_gt(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional uint64 gte = 5;
inline bool UInt64Rules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UInt64Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t UInt64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.gte)
  return _internal_gte();
}
inline void UInt64Rules::set_gte(::uint64_t value) {
  _internal_set_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.gte)
}
inline ::uint64_t UInt64Rules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void UInt64Rules::_internal_set_gte(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// repeated uint64 in = 6;
inline int UInt64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int UInt64Rules::in_size() const {
  return _internal_in_size();
}
inline void UInt64Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::uint64_t UInt64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.in)
  return _internal_in().Get(index);
}
inline void UInt64Rules::set_in(int index, ::uint64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.in)
}
inline void UInt64Rules::add_in(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.UInt64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& UInt64Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.UInt64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL UInt64Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.UInt64Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
UInt64Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL
UInt64Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated uint64 not_in = 7;
inline int UInt64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int UInt64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void UInt64Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::uint64_t UInt64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void UInt64Rules::set_not_in(int index, ::uint64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.not_in)
}
inline void UInt64Rules::add_not_in(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.UInt64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& UInt64Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.UInt64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL UInt64Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.UInt64Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
UInt64Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL
UInt64Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool ignore_empty = 8;
inline bool UInt64Rules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UInt64Rules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool UInt64Rules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.UInt64Rules.ignore_empty)
  return _internal_ignore_empty();
}
inline void UInt64Rules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.UInt64Rules.ignore_empty)
}
inline bool UInt64Rules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void UInt64Rules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// SInt32Rules

// optional sint32 const = 1;
inline bool SInt32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SInt32Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SInt32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.const)
  return _internal_const_();
}
inline void SInt32Rules::set_const_(::int32_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.const)
}
inline ::int32_t SInt32Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void SInt32Rules::_internal_set_const_(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional sint32 lt = 2;
inline bool SInt32Rules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SInt32Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SInt32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.lt)
  return _internal_lt();
}
inline void SInt32Rules::set_lt(::int32_t value) {
  _internal_set_lt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.lt)
}
inline ::int32_t SInt32Rules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void SInt32Rules::_internal_set_lt(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional sint32 lte = 3;
inline bool SInt32Rules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SInt32Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SInt32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.lte)
  return _internal_lte();
}
inline void SInt32Rules::set_lte(::int32_t value) {
  _internal_set_lte(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.lte)
}
inline ::int32_t SInt32Rules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void SInt32Rules::_internal_set_lte(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// optional sint32 gt = 4;
inline bool SInt32Rules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SInt32Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SInt32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.gt)
  return _internal_gt();
}
inline void SInt32Rules::set_gt(::int32_t value) {
  _internal_set_gt(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.gt)
}
inline ::int32_t SInt32Rules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void SInt32Rules::_internal_set_gt(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional sint32 gte = 5;
inline bool SInt32Rules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SInt32Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SInt32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.gte)
  return _internal_gte();
}
inline void SInt32Rules::set_gte(::int32_t value) {
  _internal_set_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.gte)
}
inline ::int32_t SInt32Rules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void SInt32Rules::_internal_set_gte(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// repeated sint32 in = 6;
inline int SInt32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int SInt32Rules::in_size() const {
  return _internal_in_size();
}
inline void SInt32Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int32_t SInt32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.in)
  return _internal_in().Get(index);
}
inline void SInt32Rules::set_in(int index, ::int32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.in)
}
inline void SInt32Rules::add_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.SInt32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SInt32Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.SInt32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL SInt32Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.SInt32Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SInt32Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
SInt32Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated sint32 not_in = 7;
inline int SInt32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int SInt32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void SInt32Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int32_t SInt32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void SInt32Rules::set_not_in(int index, ::int32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.not_in)
}
inline void SInt32Rules::add_not_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.SInt32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SInt32Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.SInt32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL SInt32Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.SInt32Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SInt32Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
SInt32Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool ignore_empty = 8;
inline bool SInt32Rules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SInt32Rules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool SInt32Rules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.SInt32Rules.ignore_empty)
  return _internal_ignore_empty();
}
inline void SInt32Rules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.SInt32Rules.ignore_empty)
}
inline bool SInt32Rules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void SInt32Rules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// SInt64Rules

// optional sint64 const = 1;
inline bool SInt64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SInt64Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t SInt64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.const)
  return _internal_const_();
}
inline void SInt64Rules::set_const_(::int64_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.const)
}
inline ::int64_t SInt64Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void SInt64Rules::_internal_set_const_(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional sint64 lt = 2;
inline bool SInt64Rules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SInt64Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t SInt64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.lt)
  return _internal_lt();
}
inline void SInt64Rules::set_lt(::int64_t value) {
  _internal_set_lt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.lt)
}
inline ::int64_t SInt64Rules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void SInt64Rules::_internal_set_lt(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional sint64 lte = 3;
inline bool SInt64Rules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SInt64Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t SInt64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.lte)
  return _internal_lte();
}
inline void SInt64Rules::set_lte(::int64_t value) {
  _internal_set_lte(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.lte)
}
inline ::int64_t SInt64Rules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void SInt64Rules::_internal_set_lte(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// optional sint64 gt = 4;
inline bool SInt64Rules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SInt64Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t SInt64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.gt)
  return _internal_gt();
}
inline void SInt64Rules::set_gt(::int64_t value) {
  _internal_set_gt(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.gt)
}
inline ::int64_t SInt64Rules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void SInt64Rules::_internal_set_gt(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional sint64 gte = 5;
inline bool SInt64Rules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SInt64Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t SInt64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.gte)
  return _internal_gte();
}
inline void SInt64Rules::set_gte(::int64_t value) {
  _internal_set_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.gte)
}
inline ::int64_t SInt64Rules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void SInt64Rules::_internal_set_gte(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// repeated sint64 in = 6;
inline int SInt64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int SInt64Rules::in_size() const {
  return _internal_in_size();
}
inline void SInt64Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int64_t SInt64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.in)
  return _internal_in().Get(index);
}
inline void SInt64Rules::set_in(int index, ::int64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.in)
}
inline void SInt64Rules::add_in(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.SInt64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SInt64Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.SInt64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL SInt64Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.SInt64Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
SInt64Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
SInt64Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated sint64 not_in = 7;
inline int SInt64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int SInt64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void SInt64Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int64_t SInt64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void SInt64Rules::set_not_in(int index, ::int64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.not_in)
}
inline void SInt64Rules::add_not_in(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.SInt64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SInt64Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.SInt64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL SInt64Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.SInt64Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
SInt64Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
SInt64Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool ignore_empty = 8;
inline bool SInt64Rules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SInt64Rules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool SInt64Rules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.SInt64Rules.ignore_empty)
  return _internal_ignore_empty();
}
inline void SInt64Rules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.SInt64Rules.ignore_empty)
}
inline bool SInt64Rules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void SInt64Rules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// Fixed32Rules

// optional fixed32 const = 1;
inline bool Fixed32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Fixed32Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t Fixed32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.const)
  return _internal_const_();
}
inline void Fixed32Rules::set_const_(::uint32_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.const)
}
inline ::uint32_t Fixed32Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void Fixed32Rules::_internal_set_const_(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional fixed32 lt = 2;
inline bool Fixed32Rules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Fixed32Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Fixed32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.lt)
  return _internal_lt();
}
inline void Fixed32Rules::set_lt(::uint32_t value) {
  _internal_set_lt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.lt)
}
inline ::uint32_t Fixed32Rules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void Fixed32Rules::_internal_set_lt(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional fixed32 lte = 3;
inline bool Fixed32Rules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Fixed32Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t Fixed32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.lte)
  return _internal_lte();
}
inline void Fixed32Rules::set_lte(::uint32_t value) {
  _internal_set_lte(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.lte)
}
inline ::uint32_t Fixed32Rules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void Fixed32Rules::_internal_set_lte(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// optional fixed32 gt = 4;
inline bool Fixed32Rules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Fixed32Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t Fixed32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.gt)
  return _internal_gt();
}
inline void Fixed32Rules::set_gt(::uint32_t value) {
  _internal_set_gt(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.gt)
}
inline ::uint32_t Fixed32Rules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void Fixed32Rules::_internal_set_gt(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional fixed32 gte = 5;
inline bool Fixed32Rules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Fixed32Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t Fixed32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.gte)
  return _internal_gte();
}
inline void Fixed32Rules::set_gte(::uint32_t value) {
  _internal_set_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.gte)
}
inline ::uint32_t Fixed32Rules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void Fixed32Rules::_internal_set_gte(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// repeated fixed32 in = 6;
inline int Fixed32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int Fixed32Rules::in_size() const {
  return _internal_in_size();
}
inline void Fixed32Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::uint32_t Fixed32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.in)
  return _internal_in().Get(index);
}
inline void Fixed32Rules::set_in(int index, ::uint32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.in)
}
inline void Fixed32Rules::add_in(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.Fixed32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Fixed32Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.Fixed32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL Fixed32Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.Fixed32Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Fixed32Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
Fixed32Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated fixed32 not_in = 7;
inline int Fixed32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int Fixed32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void Fixed32Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::uint32_t Fixed32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void Fixed32Rules::set_not_in(int index, ::uint32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.not_in)
}
inline void Fixed32Rules::add_not_in(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.Fixed32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Fixed32Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.Fixed32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL Fixed32Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.Fixed32Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Fixed32Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
Fixed32Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool ignore_empty = 8;
inline bool Fixed32Rules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Fixed32Rules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Fixed32Rules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.Fixed32Rules.ignore_empty)
  return _internal_ignore_empty();
}
inline void Fixed32Rules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.Fixed32Rules.ignore_empty)
}
inline bool Fixed32Rules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void Fixed32Rules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// Fixed64Rules

// optional fixed64 const = 1;
inline bool Fixed64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Fixed64Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t Fixed64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.const)
  return _internal_const_();
}
inline void Fixed64Rules::set_const_(::uint64_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.const)
}
inline ::uint64_t Fixed64Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void Fixed64Rules::_internal_set_const_(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional fixed64 lt = 2;
inline bool Fixed64Rules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Fixed64Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t Fixed64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.lt)
  return _internal_lt();
}
inline void Fixed64Rules::set_lt(::uint64_t value) {
  _internal_set_lt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.lt)
}
inline ::uint64_t Fixed64Rules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void Fixed64Rules::_internal_set_lt(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional fixed64 lte = 3;
inline bool Fixed64Rules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Fixed64Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t Fixed64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.lte)
  return _internal_lte();
}
inline void Fixed64Rules::set_lte(::uint64_t value) {
  _internal_set_lte(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.lte)
}
inline ::uint64_t Fixed64Rules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void Fixed64Rules::_internal_set_lte(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// optional fixed64 gt = 4;
inline bool Fixed64Rules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Fixed64Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t Fixed64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.gt)
  return _internal_gt();
}
inline void Fixed64Rules::set_gt(::uint64_t value) {
  _internal_set_gt(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.gt)
}
inline ::uint64_t Fixed64Rules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void Fixed64Rules::_internal_set_gt(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional fixed64 gte = 5;
inline bool Fixed64Rules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Fixed64Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t Fixed64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.gte)
  return _internal_gte();
}
inline void Fixed64Rules::set_gte(::uint64_t value) {
  _internal_set_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.gte)
}
inline ::uint64_t Fixed64Rules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void Fixed64Rules::_internal_set_gte(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// repeated fixed64 in = 6;
inline int Fixed64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int Fixed64Rules::in_size() const {
  return _internal_in_size();
}
inline void Fixed64Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::uint64_t Fixed64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.in)
  return _internal_in().Get(index);
}
inline void Fixed64Rules::set_in(int index, ::uint64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.in)
}
inline void Fixed64Rules::add_in(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.Fixed64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Fixed64Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.Fixed64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL Fixed64Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.Fixed64Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
Fixed64Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL
Fixed64Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated fixed64 not_in = 7;
inline int Fixed64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int Fixed64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void Fixed64Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::uint64_t Fixed64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void Fixed64Rules::set_not_in(int index, ::uint64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.not_in)
}
inline void Fixed64Rules::add_not_in(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.Fixed64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Fixed64Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.Fixed64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL Fixed64Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.Fixed64Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
Fixed64Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* PROTOBUF_NONNULL
Fixed64Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool ignore_empty = 8;
inline bool Fixed64Rules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Fixed64Rules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Fixed64Rules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.Fixed64Rules.ignore_empty)
  return _internal_ignore_empty();
}
inline void Fixed64Rules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.Fixed64Rules.ignore_empty)
}
inline bool Fixed64Rules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void Fixed64Rules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// SFixed32Rules

// optional sfixed32 const = 1;
inline bool SFixed32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SFixed32Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SFixed32Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.const)
  return _internal_const_();
}
inline void SFixed32Rules::set_const_(::int32_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.const)
}
inline ::int32_t SFixed32Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void SFixed32Rules::_internal_set_const_(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional sfixed32 lt = 2;
inline bool SFixed32Rules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SFixed32Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SFixed32Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.lt)
  return _internal_lt();
}
inline void SFixed32Rules::set_lt(::int32_t value) {
  _internal_set_lt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.lt)
}
inline ::int32_t SFixed32Rules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void SFixed32Rules::_internal_set_lt(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional sfixed32 lte = 3;
inline bool SFixed32Rules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SFixed32Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SFixed32Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.lte)
  return _internal_lte();
}
inline void SFixed32Rules::set_lte(::int32_t value) {
  _internal_set_lte(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.lte)
}
inline ::int32_t SFixed32Rules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void SFixed32Rules::_internal_set_lte(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// optional sfixed32 gt = 4;
inline bool SFixed32Rules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SFixed32Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SFixed32Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.gt)
  return _internal_gt();
}
inline void SFixed32Rules::set_gt(::int32_t value) {
  _internal_set_gt(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.gt)
}
inline ::int32_t SFixed32Rules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void SFixed32Rules::_internal_set_gt(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional sfixed32 gte = 5;
inline bool SFixed32Rules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SFixed32Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SFixed32Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.gte)
  return _internal_gte();
}
inline void SFixed32Rules::set_gte(::int32_t value) {
  _internal_set_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.gte)
}
inline ::int32_t SFixed32Rules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void SFixed32Rules::_internal_set_gte(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// repeated sfixed32 in = 6;
inline int SFixed32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int SFixed32Rules::in_size() const {
  return _internal_in_size();
}
inline void SFixed32Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int32_t SFixed32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.in)
  return _internal_in().Get(index);
}
inline void SFixed32Rules::set_in(int index, ::int32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.in)
}
inline void SFixed32Rules::add_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.SFixed32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SFixed32Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.SFixed32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL SFixed32Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.SFixed32Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SFixed32Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
SFixed32Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated sfixed32 not_in = 7;
inline int SFixed32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int SFixed32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void SFixed32Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int32_t SFixed32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void SFixed32Rules::set_not_in(int index, ::int32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.not_in)
}
inline void SFixed32Rules::add_not_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.SFixed32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SFixed32Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.SFixed32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL SFixed32Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.SFixed32Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SFixed32Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
SFixed32Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool ignore_empty = 8;
inline bool SFixed32Rules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SFixed32Rules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool SFixed32Rules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.SFixed32Rules.ignore_empty)
  return _internal_ignore_empty();
}
inline void SFixed32Rules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.SFixed32Rules.ignore_empty)
}
inline bool SFixed32Rules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void SFixed32Rules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// SFixed64Rules

// optional sfixed64 const = 1;
inline bool SFixed64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SFixed64Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t SFixed64Rules::const_() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.const)
  return _internal_const_();
}
inline void SFixed64Rules::set_const_(::int64_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.const)
}
inline ::int64_t SFixed64Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void SFixed64Rules::_internal_set_const_(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional sfixed64 lt = 2;
inline bool SFixed64Rules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SFixed64Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t SFixed64Rules::lt() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.lt)
  return _internal_lt();
}
inline void SFixed64Rules::set_lt(::int64_t value) {
  _internal_set_lt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.lt)
}
inline ::int64_t SFixed64Rules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_;
}
inline void SFixed64Rules::_internal_set_lt(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_ = value;
}

// optional sfixed64 lte = 3;
inline bool SFixed64Rules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SFixed64Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t SFixed64Rules::lte() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.lte)
  return _internal_lte();
}
inline void SFixed64Rules::set_lte(::int64_t value) {
  _internal_set_lte(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.lte)
}
inline ::int64_t SFixed64Rules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lte_;
}
inline void SFixed64Rules::_internal_set_lte(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lte_ = value;
}

// optional sfixed64 gt = 4;
inline bool SFixed64Rules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SFixed64Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t SFixed64Rules::gt() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.gt)
  return _internal_gt();
}
inline void SFixed64Rules::set_gt(::int64_t value) {
  _internal_set_gt(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.gt)
}
inline ::int64_t SFixed64Rules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_;
}
inline void SFixed64Rules::_internal_set_gt(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_ = value;
}

// optional sfixed64 gte = 5;
inline bool SFixed64Rules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SFixed64Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t SFixed64Rules::gte() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.gte)
  return _internal_gte();
}
inline void SFixed64Rules::set_gte(::int64_t value) {
  _internal_set_gte(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.gte)
}
inline ::int64_t SFixed64Rules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gte_;
}
inline void SFixed64Rules::_internal_set_gte(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gte_ = value;
}

// repeated sfixed64 in = 6;
inline int SFixed64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int SFixed64Rules::in_size() const {
  return _internal_in_size();
}
inline void SFixed64Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int64_t SFixed64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.in)
  return _internal_in().Get(index);
}
inline void SFixed64Rules::set_in(int index, ::int64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.in)
}
inline void SFixed64Rules::add_in(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.SFixed64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SFixed64Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.SFixed64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL SFixed64Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.SFixed64Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
SFixed64Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
SFixed64Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated sfixed64 not_in = 7;
inline int SFixed64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int SFixed64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void SFixed64Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int64_t SFixed64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void SFixed64Rules::set_not_in(int index, ::int64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.not_in)
}
inline void SFixed64Rules::add_not_in(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.SFixed64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SFixed64Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.SFixed64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL SFixed64Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.SFixed64Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
SFixed64Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
SFixed64Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool ignore_empty = 8;
inline bool SFixed64Rules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SFixed64Rules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool SFixed64Rules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.SFixed64Rules.ignore_empty)
  return _internal_ignore_empty();
}
inline void SFixed64Rules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.SFixed64Rules.ignore_empty)
}
inline bool SFixed64Rules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void SFixed64Rules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// BoolRules

// optional bool const = 1;
inline bool BoolRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BoolRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool BoolRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.BoolRules.const)
  return _internal_const_();
}
inline void BoolRules::set_const_(bool value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.BoolRules.const)
}
inline bool BoolRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void BoolRules::_internal_set_const_(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// -------------------------------------------------------------------

// StringRules

// optional string const = 1;
inline bool StringRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StringRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& StringRules::const_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.StringRules.const)
  return _internal_const_();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StringRules::set_const_(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:validate.StringRules.const)
}
inline ::std::string* PROTOBUF_NONNULL StringRules::mutable_const_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:validate.StringRules.const)
  return _s;
}
inline const ::std::string& StringRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__.Get();
}
inline void StringRules::_internal_set_const_(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StringRules::_internal_mutable_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.const__.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StringRules::release_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.StringRules.const)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.const__.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.const__.Set("", GetArena());
  }
  return released;
}
inline void StringRules::set_allocated_const_(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.const__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.const__.IsDefault()) {
    _impl_.const__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.const)
}

// optional uint64 len = 19;
inline bool StringRules::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void StringRules::clear_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint64_t StringRules::len() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.len)
  return _internal_len();
}
inline void StringRules::set_len(::uint64_t value) {
  _internal_set_len(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:validate.StringRules.len)
}
inline ::uint64_t StringRules::_internal_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.len_;
}
inline void StringRules::_internal_set_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_ = value;
}

// optional uint64 min_len = 2;
inline bool StringRules::has_min_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void StringRules::clear_min_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t StringRules::min_len() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.min_len)
  return _internal_min_len();
}
inline void StringRules::set_min_len(::uint64_t value) {
  _internal_set_min_len(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:validate.StringRules.min_len)
}
inline ::uint64_t StringRules::_internal_min_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_len_;
}
inline void StringRules::_internal_set_min_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_len_ = value;
}

// optional uint64 max_len = 3;
inline bool StringRules::has_max_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void StringRules::clear_max_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t StringRules::max_len() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.max_len)
  return _internal_max_len();
}
inline void StringRules::set_max_len(::uint64_t value) {
  _internal_set_max_len(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:validate.StringRules.max_len)
}
inline ::uint64_t StringRules::_internal_max_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_len_;
}
inline void StringRules::_internal_set_max_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_len_ = value;
}

// optional uint64 len_bytes = 20;
inline bool StringRules::has_len_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void StringRules::clear_len_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::uint64_t StringRules::len_bytes() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.len_bytes)
  return _internal_len_bytes();
}
inline void StringRules::set_len_bytes(::uint64_t value) {
  _internal_set_len_bytes(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:validate.StringRules.len_bytes)
}
inline ::uint64_t StringRules::_internal_len_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.len_bytes_;
}
inline void StringRules::_internal_set_len_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_bytes_ = value;
}

// optional uint64 min_bytes = 4;
inline bool StringRules::has_min_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void StringRules::clear_min_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint64_t StringRules::min_bytes() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.min_bytes)
  return _internal_min_bytes();
}
inline void StringRules::set_min_bytes(::uint64_t value) {
  _internal_set_min_bytes(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:validate.StringRules.min_bytes)
}
inline ::uint64_t StringRules::_internal_min_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_bytes_;
}
inline void StringRules::_internal_set_min_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_bytes_ = value;
}

// optional uint64 max_bytes = 5;
inline bool StringRules::has_max_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void StringRules::clear_max_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint64_t StringRules::max_bytes() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.max_bytes)
  return _internal_max_bytes();
}
inline void StringRules::set_max_bytes(::uint64_t value) {
  _internal_set_max_bytes(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:validate.StringRules.max_bytes)
}
inline ::uint64_t StringRules::_internal_max_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_bytes_;
}
inline void StringRules::_internal_set_max_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_bytes_ = value;
}

// optional string pattern = 6;
inline bool StringRules::has_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StringRules::clear_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pattern_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& StringRules::pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.StringRules.pattern)
  return _internal_pattern();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StringRules::set_pattern(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:validate.StringRules.pattern)
}
inline ::std::string* PROTOBUF_NONNULL StringRules::mutable_pattern()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:validate.StringRules.pattern)
  return _s;
}
inline const ::std::string& StringRules::_internal_pattern() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pattern_.Get();
}
inline void StringRules::_internal_set_pattern(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pattern_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StringRules::_internal_mutable_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pattern_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StringRules::release_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.StringRules.pattern)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.pattern_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.pattern_.Set("", GetArena());
  }
  return released;
}
inline void StringRules::set_allocated_pattern(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pattern_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pattern_.IsDefault()) {
    _impl_.pattern_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.pattern)
}

// optional string prefix = 7;
inline bool StringRules::has_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StringRules::clear_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& StringRules::prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.StringRules.prefix)
  return _internal_prefix();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StringRules::set_prefix(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:validate.StringRules.prefix)
}
inline ::std::string* PROTOBUF_NONNULL StringRules::mutable_prefix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:validate.StringRules.prefix)
  return _s;
}
inline const ::std::string& StringRules::_internal_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prefix_.Get();
}
inline void StringRules::_internal_set_prefix(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prefix_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StringRules::_internal_mutable_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.prefix_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StringRules::release_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.StringRules.prefix)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.prefix_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.prefix_.Set("", GetArena());
  }
  return released;
}
inline void StringRules::set_allocated_prefix(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prefix_.IsDefault()) {
    _impl_.prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.prefix)
}

// optional string suffix = 8;
inline bool StringRules::has_suffix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void StringRules::clear_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suffix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& StringRules::suffix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.StringRules.suffix)
  return _internal_suffix();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StringRules::set_suffix(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.suffix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:validate.StringRules.suffix)
}
inline ::std::string* PROTOBUF_NONNULL StringRules::mutable_suffix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_suffix();
  // @@protoc_insertion_point(field_mutable:validate.StringRules.suffix)
  return _s;
}
inline const ::std::string& StringRules::_internal_suffix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.suffix_.Get();
}
inline void StringRules::_internal_set_suffix(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.suffix_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StringRules::_internal_mutable_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.suffix_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StringRules::release_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.StringRules.suffix)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.suffix_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.suffix_.Set("", GetArena());
  }
  return released;
}
inline void StringRules::set_allocated_suffix(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.suffix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.suffix_.IsDefault()) {
    _impl_.suffix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.suffix)
}

// optional string contains = 9;
inline bool StringRules::has_contains() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void StringRules::clear_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contains_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& StringRules::contains() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.StringRules.contains)
  return _internal_contains();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StringRules::set_contains(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.contains_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:validate.StringRules.contains)
}
inline ::std::string* PROTOBUF_NONNULL StringRules::mutable_contains()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_contains();
  // @@protoc_insertion_point(field_mutable:validate.StringRules.contains)
  return _s;
}
inline const ::std::string& StringRules::_internal_contains() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contains_.Get();
}
inline void StringRules::_internal_set_contains(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.contains_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StringRules::_internal_mutable_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.contains_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StringRules::release_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.StringRules.contains)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.contains_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.contains_.Set("", GetArena());
  }
  return released;
}
inline void StringRules::set_allocated_contains(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.contains_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contains_.IsDefault()) {
    _impl_.contains_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.contains)
}

// optional string not_contains = 23;
inline bool StringRules::has_not_contains() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void StringRules::clear_not_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_contains_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& StringRules::not_contains() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.StringRules.not_contains)
  return _internal_not_contains();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void StringRules::set_not_contains(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.not_contains_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:validate.StringRules.not_contains)
}
inline ::std::string* PROTOBUF_NONNULL StringRules::mutable_not_contains()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_not_contains();
  // @@protoc_insertion_point(field_mutable:validate.StringRules.not_contains)
  return _s;
}
inline const ::std::string& StringRules::_internal_not_contains() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_contains_.Get();
}
inline void StringRules::_internal_set_not_contains(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.not_contains_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL StringRules::_internal_mutable_not_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.not_contains_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE StringRules::release_not_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.StringRules.not_contains)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.not_contains_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.not_contains_.Set("", GetArena());
  }
  return released;
}
inline void StringRules::set_allocated_not_contains(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.not_contains_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.not_contains_.IsDefault()) {
    _impl_.not_contains_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:validate.StringRules.not_contains)
}

// repeated string in = 10;
inline int StringRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int StringRules::in_size() const {
  return _internal_in_size();
}
inline void StringRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL StringRules::add_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:validate.StringRules.in)
  return _s;
}
inline const ::std::string& StringRules::in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.StringRules.in)
  return _internal_in().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL StringRules::mutable_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:validate.StringRules.in)
  return _internal_mutable_in()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void StringRules::set_in(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_in()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:validate.StringRules.in)
}
template <typename Arg_, typename... Args_>
inline void StringRules::add_in(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_in(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:validate.StringRules.in)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& StringRules::in()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.StringRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
StringRules::mutable_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.StringRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
StringRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
StringRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated string not_in = 11;
inline int StringRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int StringRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void StringRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL StringRules::add_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_not_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:validate.StringRules.not_in)
  return _s;
}
inline const ::std::string& StringRules::not_in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.StringRules.not_in)
  return _internal_not_in().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL StringRules::mutable_not_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:validate.StringRules.not_in)
  return _internal_mutable_not_in()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void StringRules::set_not_in(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_not_in()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:validate.StringRules.not_in)
}
template <typename Arg_, typename... Args_>
inline void StringRules::add_not_in(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_not_in(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:validate.StringRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& StringRules::not_in()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.StringRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
StringRules::mutable_not_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.StringRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
StringRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
StringRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// bool email = 12;
inline bool StringRules::has_email() const {
  return well_known_case() == kEmail;
}
inline void StringRules::set_has_email() {
  _impl_._oneof_case_[0] = kEmail;
}
inline void StringRules::clear_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kEmail) {
    _impl_.well_known_.email_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::email() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.email)
  return _internal_email();
}
inline void StringRules::set_email(bool value) {
  if (well_known_case() != kEmail) {
    clear_well_known();
    set_has_email();
  }
  _impl_.well_known_.email_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.email)
}
inline bool StringRules::_internal_email() const {
  if (well_known_case() == kEmail) {
    return _impl_.well_known_.email_;
  }
  return false;
}

// bool hostname = 13;
inline bool StringRules::has_hostname() const {
  return well_known_case() == kHostname;
}
inline void StringRules::set_has_hostname() {
  _impl_._oneof_case_[0] = kHostname;
}
inline void StringRules::clear_hostname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kHostname) {
    _impl_.well_known_.hostname_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::hostname() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.hostname)
  return _internal_hostname();
}
inline void StringRules::set_hostname(bool value) {
  if (well_known_case() != kHostname) {
    clear_well_known();
    set_has_hostname();
  }
  _impl_.well_known_.hostname_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.hostname)
}
inline bool StringRules::_internal_hostname() const {
  if (well_known_case() == kHostname) {
    return _impl_.well_known_.hostname_;
  }
  return false;
}

// bool ip = 14;
inline bool StringRules::has_ip() const {
  return well_known_case() == kIp;
}
inline void StringRules::set_has_ip() {
  _impl_._oneof_case_[0] = kIp;
}
inline void StringRules::clear_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIp) {
    _impl_.well_known_.ip_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ip() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.ip)
  return _internal_ip();
}
inline void StringRules::set_ip(bool value) {
  if (well_known_case() != kIp) {
    clear_well_known();
    set_has_ip();
  }
  _impl_.well_known_.ip_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.ip)
}
inline bool StringRules::_internal_ip() const {
  if (well_known_case() == kIp) {
    return _impl_.well_known_.ip_;
  }
  return false;
}

// bool ipv4 = 15;
inline bool StringRules::has_ipv4() const {
  return well_known_case() == kIpv4;
}
inline void StringRules::set_has_ipv4() {
  _impl_._oneof_case_[0] = kIpv4;
}
inline void StringRules::clear_ipv4() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpv4) {
    _impl_.well_known_.ipv4_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv4() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.ipv4)
  return _internal_ipv4();
}
inline void StringRules::set_ipv4(bool value) {
  if (well_known_case() != kIpv4) {
    clear_well_known();
    set_has_ipv4();
  }
  _impl_.well_known_.ipv4_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.ipv4)
}
inline bool StringRules::_internal_ipv4() const {
  if (well_known_case() == kIpv4) {
    return _impl_.well_known_.ipv4_;
  }
  return false;
}

// bool ipv6 = 16;
inline bool StringRules::has_ipv6() const {
  return well_known_case() == kIpv6;
}
inline void StringRules::set_has_ipv6() {
  _impl_._oneof_case_[0] = kIpv6;
}
inline void StringRules::clear_ipv6() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpv6) {
    _impl_.well_known_.ipv6_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv6() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.ipv6)
  return _internal_ipv6();
}
inline void StringRules::set_ipv6(bool value) {
  if (well_known_case() != kIpv6) {
    clear_well_known();
    set_has_ipv6();
  }
  _impl_.well_known_.ipv6_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.ipv6)
}
inline bool StringRules::_internal_ipv6() const {
  if (well_known_case() == kIpv6) {
    return _impl_.well_known_.ipv6_;
  }
  return false;
}

// bool uri = 17;
inline bool StringRules::has_uri() const {
  return well_known_case() == kUri;
}
inline void StringRules::set_has_uri() {
  _impl_._oneof_case_[0] = kUri;
}
inline void StringRules::clear_uri() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kUri) {
    _impl_.well_known_.uri_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uri() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.uri)
  return _internal_uri();
}
inline void StringRules::set_uri(bool value) {
  if (well_known_case() != kUri) {
    clear_well_known();
    set_has_uri();
  }
  _impl_.well_known_.uri_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.uri)
}
inline bool StringRules::_internal_uri() const {
  if (well_known_case() == kUri) {
    return _impl_.well_known_.uri_;
  }
  return false;
}

// bool uri_ref = 18;
inline bool StringRules::has_uri_ref() const {
  return well_known_case() == kUriRef;
}
inline void StringRules::set_has_uri_ref() {
  _impl_._oneof_case_[0] = kUriRef;
}
inline void StringRules::clear_uri_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kUriRef) {
    _impl_.well_known_.uri_ref_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uri_ref() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.uri_ref)
  return _internal_uri_ref();
}
inline void StringRules::set_uri_ref(bool value) {
  if (well_known_case() != kUriRef) {
    clear_well_known();
    set_has_uri_ref();
  }
  _impl_.well_known_.uri_ref_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.uri_ref)
}
inline bool StringRules::_internal_uri_ref() const {
  if (well_known_case() == kUriRef) {
    return _impl_.well_known_.uri_ref_;
  }
  return false;
}

// bool address = 21;
inline bool StringRules::has_address() const {
  return well_known_case() == kAddress;
}
inline void StringRules::set_has_address() {
  _impl_._oneof_case_[0] = kAddress;
}
inline void StringRules::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kAddress) {
    _impl_.well_known_.address_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::address() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.address)
  return _internal_address();
}
inline void StringRules::set_address(bool value) {
  if (well_known_case() != kAddress) {
    clear_well_known();
    set_has_address();
  }
  _impl_.well_known_.address_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.address)
}
inline bool StringRules::_internal_address() const {
  if (well_known_case() == kAddress) {
    return _impl_.well_known_.address_;
  }
  return false;
}

// bool uuid = 22;
inline bool StringRules::has_uuid() const {
  return well_known_case() == kUuid;
}
inline void StringRules::set_has_uuid() {
  _impl_._oneof_case_[0] = kUuid;
}
inline void StringRules::clear_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kUuid) {
    _impl_.well_known_.uuid_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uuid() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.uuid)
  return _internal_uuid();
}
inline void StringRules::set_uuid(bool value) {
  if (well_known_case() != kUuid) {
    clear_well_known();
    set_has_uuid();
  }
  _impl_.well_known_.uuid_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.uuid)
}
inline bool StringRules::_internal_uuid() const {
  if (well_known_case() == kUuid) {
    return _impl_.well_known_.uuid_;
  }
  return false;
}

// .validate.KnownRegex well_known_regex = 24;
inline bool StringRules::has_well_known_regex() const {
  return well_known_case() == kWellKnownRegex;
}
inline void StringRules::set_has_well_known_regex() {
  _impl_._oneof_case_[0] = kWellKnownRegex;
}
inline void StringRules::clear_well_known_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kWellKnownRegex) {
    _impl_.well_known_.well_known_regex_ = 0;
    clear_has_well_known();
  }
}
inline ::validate::KnownRegex StringRules::well_known_regex() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.well_known_regex)
  return _internal_well_known_regex();
}
inline void StringRules::set_well_known_regex(::validate::KnownRegex value) {

                                          assert(::google::protobuf::internal::ValidateEnum(
                                              value, ::validate::KnownRegex_internal_data_));
                                          if (well_known_case() != kWellKnownRegex) {
    clear_well_known();
    set_has_well_known_regex();
  }
  _impl_.well_known_.well_known_regex_ = value;
  // @@protoc_insertion_point(field_set:validate.StringRules.well_known_regex)
}
inline ::validate::KnownRegex StringRules::_internal_well_known_regex() const {
  if (well_known_case() == kWellKnownRegex) {
    return static_cast<::validate::KnownRegex>(_impl_.well_known_.well_known_regex_);
  }
  return static_cast<::validate::KnownRegex>(0);
}

// optional bool strict = 25 [default = true];
inline bool StringRules::has_strict() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void StringRules::clear_strict() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strict_ = true;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool StringRules::strict() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.strict)
  return _internal_strict();
}
inline void StringRules::set_strict(bool value) {
  _internal_set_strict(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:validate.StringRules.strict)
}
inline bool StringRules::_internal_strict() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strict_;
}
inline void StringRules::_internal_set_strict(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strict_ = value;
}

// optional bool ignore_empty = 26;
inline bool StringRules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void StringRules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool StringRules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.StringRules.ignore_empty)
  return _internal_ignore_empty();
}
inline void StringRules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:validate.StringRules.ignore_empty)
}
inline bool StringRules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void StringRules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

inline bool StringRules::has_well_known() const {
  return well_known_case() != WELL_KNOWN_NOT_SET;
}
inline void StringRules::clear_has_well_known() {
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}
inline StringRules::WellKnownCase StringRules::well_known_case() const {
  return StringRules::WellKnownCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BytesRules

// optional bytes const = 1;
inline bool BytesRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BytesRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BytesRules::const_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.BytesRules.const)
  return _internal_const_();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BytesRules::set_const_(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:validate.BytesRules.const)
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::mutable_const_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.const)
  return _s;
}
inline const ::std::string& BytesRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__.Get();
}
inline void BytesRules::_internal_set_const_(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::_internal_mutable_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.const__.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BytesRules::release_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.BytesRules.const)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.const__.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.const__.Set("", GetArena());
  }
  return released;
}
inline void BytesRules::set_allocated_const_(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.const__.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.const__.IsDefault()) {
    _impl_.const__.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.const)
}

// optional uint64 len = 13;
inline bool BytesRules::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void BytesRules::clear_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t BytesRules::len() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.len)
  return _internal_len();
}
inline void BytesRules::set_len(::uint64_t value) {
  _internal_set_len(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:validate.BytesRules.len)
}
inline ::uint64_t BytesRules::_internal_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.len_;
}
inline void BytesRules::_internal_set_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_ = value;
}

// optional uint64 min_len = 2;
inline bool BytesRules::has_min_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BytesRules::clear_min_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t BytesRules::min_len() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.min_len)
  return _internal_min_len();
}
inline void BytesRules::set_min_len(::uint64_t value) {
  _internal_set_min_len(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.BytesRules.min_len)
}
inline ::uint64_t BytesRules::_internal_min_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_len_;
}
inline void BytesRules::_internal_set_min_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_len_ = value;
}

// optional uint64 max_len = 3;
inline bool BytesRules::has_max_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BytesRules::clear_max_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t BytesRules::max_len() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.max_len)
  return _internal_max_len();
}
inline void BytesRules::set_max_len(::uint64_t value) {
  _internal_set_max_len(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:validate.BytesRules.max_len)
}
inline ::uint64_t BytesRules::_internal_max_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_len_;
}
inline void BytesRules::_internal_set_max_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_len_ = value;
}

// optional string pattern = 4;
inline bool BytesRules::has_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BytesRules::clear_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pattern_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& BytesRules::pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.BytesRules.pattern)
  return _internal_pattern();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BytesRules::set_pattern(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:validate.BytesRules.pattern)
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::mutable_pattern()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.pattern)
  return _s;
}
inline const ::std::string& BytesRules::_internal_pattern() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pattern_.Get();
}
inline void BytesRules::_internal_set_pattern(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pattern_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::_internal_mutable_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pattern_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BytesRules::release_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.BytesRules.pattern)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.pattern_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.pattern_.Set("", GetArena());
  }
  return released;
}
inline void BytesRules::set_allocated_pattern(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pattern_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pattern_.IsDefault()) {
    _impl_.pattern_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.pattern)
}

// optional bytes prefix = 5;
inline bool BytesRules::has_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BytesRules::clear_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& BytesRules::prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.BytesRules.prefix)
  return _internal_prefix();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BytesRules::set_prefix(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prefix_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:validate.BytesRules.prefix)
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::mutable_prefix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.prefix)
  return _s;
}
inline const ::std::string& BytesRules::_internal_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prefix_.Get();
}
inline void BytesRules::_internal_set_prefix(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prefix_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::_internal_mutable_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.prefix_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BytesRules::release_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.BytesRules.prefix)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.prefix_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.prefix_.Set("", GetArena());
  }
  return released;
}
inline void BytesRules::set_allocated_prefix(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prefix_.IsDefault()) {
    _impl_.prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.prefix)
}

// optional bytes suffix = 6;
inline bool BytesRules::has_suffix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BytesRules::clear_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suffix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& BytesRules::suffix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.BytesRules.suffix)
  return _internal_suffix();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BytesRules::set_suffix(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.suffix_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:validate.BytesRules.suffix)
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::mutable_suffix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_suffix();
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.suffix)
  return _s;
}
inline const ::std::string& BytesRules::_internal_suffix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.suffix_.Get();
}
inline void BytesRules::_internal_set_suffix(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.suffix_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::_internal_mutable_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.suffix_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BytesRules::release_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.BytesRules.suffix)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.suffix_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.suffix_.Set("", GetArena());
  }
  return released;
}
inline void BytesRules::set_allocated_suffix(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.suffix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.suffix_.IsDefault()) {
    _impl_.suffix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.suffix)
}

// optional bytes contains = 7;
inline bool BytesRules::has_contains() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BytesRules::clear_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contains_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& BytesRules::contains() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.BytesRules.contains)
  return _internal_contains();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BytesRules::set_contains(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.contains_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:validate.BytesRules.contains)
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::mutable_contains()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_contains();
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.contains)
  return _s;
}
inline const ::std::string& BytesRules::_internal_contains() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contains_.Get();
}
inline void BytesRules::_internal_set_contains(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.contains_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::_internal_mutable_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.contains_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BytesRules::release_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.BytesRules.contains)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.contains_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.contains_.Set("", GetArena());
  }
  return released;
}
inline void BytesRules::set_allocated_contains(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.contains_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contains_.IsDefault()) {
    _impl_.contains_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:validate.BytesRules.contains)
}

// repeated bytes in = 8;
inline int BytesRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int BytesRules::in_size() const {
  return _internal_in_size();
}
inline void BytesRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::add_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:validate.BytesRules.in)
  return _s;
}
inline const ::std::string& BytesRules::in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.BytesRules.in)
  return _internal_in().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::mutable_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.in)
  return _internal_mutable_in()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void BytesRules::set_in(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_in()->Mutable(index), ::std::forward<Arg_>(value),
                        args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:validate.BytesRules.in)
}
template <typename Arg_, typename... Args_>
inline void BytesRules::add_in(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_in(),
                               ::std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:validate.BytesRules.in)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& BytesRules::in()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.BytesRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BytesRules::mutable_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.BytesRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
BytesRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BytesRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated bytes not_in = 9;
inline int BytesRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int BytesRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void BytesRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::add_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_not_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:validate.BytesRules.not_in)
  return _s;
}
inline const ::std::string& BytesRules::not_in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.BytesRules.not_in)
  return _internal_not_in().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL BytesRules::mutable_not_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:validate.BytesRules.not_in)
  return _internal_mutable_not_in()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void BytesRules::set_not_in(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_not_in()->Mutable(index), ::std::forward<Arg_>(value),
                        args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:validate.BytesRules.not_in)
}
template <typename Arg_, typename... Args_>
inline void BytesRules::add_not_in(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_not_in(),
                               ::std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:validate.BytesRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& BytesRules::not_in()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.BytesRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BytesRules::mutable_not_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.BytesRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
BytesRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
BytesRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// bool ip = 10;
inline bool BytesRules::has_ip() const {
  return well_known_case() == kIp;
}
inline void BytesRules::set_has_ip() {
  _impl_._oneof_case_[0] = kIp;
}
inline void BytesRules::clear_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIp) {
    _impl_.well_known_.ip_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ip() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.ip)
  return _internal_ip();
}
inline void BytesRules::set_ip(bool value) {
  if (well_known_case() != kIp) {
    clear_well_known();
    set_has_ip();
  }
  _impl_.well_known_.ip_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.ip)
}
inline bool BytesRules::_internal_ip() const {
  if (well_known_case() == kIp) {
    return _impl_.well_known_.ip_;
  }
  return false;
}

// bool ipv4 = 11;
inline bool BytesRules::has_ipv4() const {
  return well_known_case() == kIpv4;
}
inline void BytesRules::set_has_ipv4() {
  _impl_._oneof_case_[0] = kIpv4;
}
inline void BytesRules::clear_ipv4() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpv4) {
    _impl_.well_known_.ipv4_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ipv4() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.ipv4)
  return _internal_ipv4();
}
inline void BytesRules::set_ipv4(bool value) {
  if (well_known_case() != kIpv4) {
    clear_well_known();
    set_has_ipv4();
  }
  _impl_.well_known_.ipv4_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.ipv4)
}
inline bool BytesRules::_internal_ipv4() const {
  if (well_known_case() == kIpv4) {
    return _impl_.well_known_.ipv4_;
  }
  return false;
}

// bool ipv6 = 12;
inline bool BytesRules::has_ipv6() const {
  return well_known_case() == kIpv6;
}
inline void BytesRules::set_has_ipv6() {
  _impl_._oneof_case_[0] = kIpv6;
}
inline void BytesRules::clear_ipv6() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpv6) {
    _impl_.well_known_.ipv6_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ipv6() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.ipv6)
  return _internal_ipv6();
}
inline void BytesRules::set_ipv6(bool value) {
  if (well_known_case() != kIpv6) {
    clear_well_known();
    set_has_ipv6();
  }
  _impl_.well_known_.ipv6_ = value;
  // @@protoc_insertion_point(field_set:validate.BytesRules.ipv6)
}
inline bool BytesRules::_internal_ipv6() const {
  if (well_known_case() == kIpv6) {
    return _impl_.well_known_.ipv6_;
  }
  return false;
}

// optional bool ignore_empty = 14;
inline bool BytesRules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void BytesRules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool BytesRules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.BytesRules.ignore_empty)
  return _internal_ignore_empty();
}
inline void BytesRules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:validate.BytesRules.ignore_empty)
}
inline bool BytesRules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void BytesRules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

inline bool BytesRules::has_well_known() const {
  return well_known_case() != WELL_KNOWN_NOT_SET;
}
inline void BytesRules::clear_has_well_known() {
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}
inline BytesRules::WellKnownCase BytesRules::well_known_case() const {
  return BytesRules::WellKnownCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EnumRules

// optional int32 const = 1;
inline bool EnumRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EnumRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t EnumRules::const_() const {
  // @@protoc_insertion_point(field_get:validate.EnumRules.const)
  return _internal_const_();
}
inline void EnumRules::set_const_(::int32_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.EnumRules.const)
}
inline ::int32_t EnumRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void EnumRules::_internal_set_const_(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional bool defined_only = 2;
inline bool EnumRules::has_defined_only() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EnumRules::clear_defined_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.defined_only_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool EnumRules::defined_only() const {
  // @@protoc_insertion_point(field_get:validate.EnumRules.defined_only)
  return _internal_defined_only();
}
inline void EnumRules::set_defined_only(bool value) {
  _internal_set_defined_only(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.EnumRules.defined_only)
}
inline bool EnumRules::_internal_defined_only() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.defined_only_;
}
inline void EnumRules::_internal_set_defined_only(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.defined_only_ = value;
}

// repeated int32 in = 3;
inline int EnumRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int EnumRules::in_size() const {
  return _internal_in_size();
}
inline void EnumRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int32_t EnumRules::in(int index) const {
  // @@protoc_insertion_point(field_get:validate.EnumRules.in)
  return _internal_in().Get(index);
}
inline void EnumRules::set_in(int index, ::int32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.EnumRules.in)
}
inline void EnumRules::add_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.EnumRules.in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& EnumRules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.EnumRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL EnumRules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.EnumRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
EnumRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
EnumRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated int32 not_in = 4;
inline int EnumRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int EnumRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void EnumRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int32_t EnumRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:validate.EnumRules.not_in)
  return _internal_not_in().Get(index);
}
inline void EnumRules::set_not_in(int index, ::int32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:validate.EnumRules.not_in)
}
inline void EnumRules::add_not_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:validate.EnumRules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& EnumRules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.EnumRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL EnumRules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.EnumRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
EnumRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
EnumRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// -------------------------------------------------------------------

// MessageRules

// optional bool skip = 1;
inline bool MessageRules::has_skip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MessageRules::clear_skip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skip_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool MessageRules::skip() const {
  // @@protoc_insertion_point(field_get:validate.MessageRules.skip)
  return _internal_skip();
}
inline void MessageRules::set_skip(bool value) {
  _internal_set_skip(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.MessageRules.skip)
}
inline bool MessageRules::_internal_skip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skip_;
}
inline void MessageRules::_internal_set_skip(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skip_ = value;
}

// optional bool required = 2;
inline bool MessageRules::has_required() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MessageRules::clear_required() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool MessageRules::required() const {
  // @@protoc_insertion_point(field_get:validate.MessageRules.required)
  return _internal_required();
}
inline void MessageRules::set_required(bool value) {
  _internal_set_required(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.MessageRules.required)
}
inline bool MessageRules::_internal_required() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.required_;
}
inline void MessageRules::_internal_set_required(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_ = value;
}

// -------------------------------------------------------------------

// RepeatedRules

// optional uint64 min_items = 1;
inline bool RepeatedRules::has_min_items() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepeatedRules::clear_min_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_items_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t RepeatedRules::min_items() const {
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.min_items)
  return _internal_min_items();
}
inline void RepeatedRules::set_min_items(::uint64_t value) {
  _internal_set_min_items(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:validate.RepeatedRules.min_items)
}
inline ::uint64_t RepeatedRules::_internal_min_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_items_;
}
inline void RepeatedRules::_internal_set_min_items(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_items_ = value;
}

// optional uint64 max_items = 2;
inline bool RepeatedRules::has_max_items() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RepeatedRules::clear_max_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_items_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t RepeatedRules::max_items() const {
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.max_items)
  return _internal_max_items();
}
inline void RepeatedRules::set_max_items(::uint64_t value) {
  _internal_set_max_items(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.RepeatedRules.max_items)
}
inline ::uint64_t RepeatedRules::_internal_max_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_items_;
}
inline void RepeatedRules::_internal_set_max_items(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_items_ = value;
}

// optional bool unique = 3;
inline bool RepeatedRules::has_unique() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RepeatedRules::clear_unique() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unique_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RepeatedRules::unique() const {
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.unique)
  return _internal_unique();
}
inline void RepeatedRules::set_unique(bool value) {
  _internal_set_unique(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.RepeatedRules.unique)
}
inline bool RepeatedRules::_internal_unique() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unique_;
}
inline void RepeatedRules::_internal_set_unique(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unique_ = value;
}

// optional .validate.FieldRules items = 4;
inline bool RepeatedRules::has_items() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.items_ != nullptr);
  return value;
}
inline void RepeatedRules::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.items_ != nullptr) _impl_.items_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::validate::FieldRules& RepeatedRules::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::validate::FieldRules* p = _impl_.items_;
  return p != nullptr ? *p : reinterpret_cast<const ::validate::FieldRules&>(::validate::_FieldRules_default_instance_);
}
inline const ::validate::FieldRules& RepeatedRules::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.items)
  return _internal_items();
}
inline void RepeatedRules::unsafe_arena_set_allocated_items(
    ::validate::FieldRules* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.items_);
  }
  _impl_.items_ = reinterpret_cast<::validate::FieldRules*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.RepeatedRules.items)
}
inline ::validate::FieldRules* PROTOBUF_NULLABLE RepeatedRules::release_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::validate::FieldRules* released = _impl_.items_;
  _impl_.items_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::validate::FieldRules* PROTOBUF_NULLABLE RepeatedRules::unsafe_arena_release_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.RepeatedRules.items)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::validate::FieldRules* temp = _impl_.items_;
  _impl_.items_ = nullptr;
  return temp;
}
inline ::validate::FieldRules* PROTOBUF_NONNULL RepeatedRules::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.items_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::validate::FieldRules>(GetArena());
    _impl_.items_ = reinterpret_cast<::validate::FieldRules*>(p);
  }
  return _impl_.items_;
}
inline ::validate::FieldRules* PROTOBUF_NONNULL RepeatedRules::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::validate::FieldRules* _msg = _internal_mutable_items();
  // @@protoc_insertion_point(field_mutable:validate.RepeatedRules.items)
  return _msg;
}
inline void RepeatedRules::set_allocated_items(::validate::FieldRules* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.items_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.items_ = reinterpret_cast<::validate::FieldRules*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.RepeatedRules.items)
}

// optional bool ignore_empty = 5;
inline bool RepeatedRules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RepeatedRules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool RepeatedRules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.RepeatedRules.ignore_empty)
  return _internal_ignore_empty();
}
inline void RepeatedRules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.RepeatedRules.ignore_empty)
}
inline bool RepeatedRules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void RepeatedRules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// MapRules

// optional uint64 min_pairs = 1;
inline bool MapRules::has_min_pairs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MapRules::clear_min_pairs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_pairs_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t MapRules::min_pairs() const {
  // @@protoc_insertion_point(field_get:validate.MapRules.min_pairs)
  return _internal_min_pairs();
}
inline void MapRules::set_min_pairs(::uint64_t value) {
  _internal_set_min_pairs(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:validate.MapRules.min_pairs)
}
inline ::uint64_t MapRules::_internal_min_pairs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_pairs_;
}
inline void MapRules::_internal_set_min_pairs(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_pairs_ = value;
}

// optional uint64 max_pairs = 2;
inline bool MapRules::has_max_pairs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MapRules::clear_max_pairs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_pairs_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t MapRules::max_pairs() const {
  // @@protoc_insertion_point(field_get:validate.MapRules.max_pairs)
  return _internal_max_pairs();
}
inline void MapRules::set_max_pairs(::uint64_t value) {
  _internal_set_max_pairs(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:validate.MapRules.max_pairs)
}
inline ::uint64_t MapRules::_internal_max_pairs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_pairs_;
}
inline void MapRules::_internal_set_max_pairs(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_pairs_ = value;
}

// optional bool no_sparse = 3;
inline bool MapRules::has_no_sparse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MapRules::clear_no_sparse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.no_sparse_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool MapRules::no_sparse() const {
  // @@protoc_insertion_point(field_get:validate.MapRules.no_sparse)
  return _internal_no_sparse();
}
inline void MapRules::set_no_sparse(bool value) {
  _internal_set_no_sparse(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:validate.MapRules.no_sparse)
}
inline bool MapRules::_internal_no_sparse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.no_sparse_;
}
inline void MapRules::_internal_set_no_sparse(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.no_sparse_ = value;
}

// optional .validate.FieldRules keys = 4;
inline bool MapRules::has_keys() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.keys_ != nullptr);
  return value;
}
inline void MapRules::clear_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.keys_ != nullptr) _impl_.keys_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::validate::FieldRules& MapRules::_internal_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::validate::FieldRules* p = _impl_.keys_;
  return p != nullptr ? *p : reinterpret_cast<const ::validate::FieldRules&>(::validate::_FieldRules_default_instance_);
}
inline const ::validate::FieldRules& MapRules::keys() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.MapRules.keys)
  return _internal_keys();
}
inline void MapRules::unsafe_arena_set_allocated_keys(
    ::validate::FieldRules* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.keys_);
  }
  _impl_.keys_ = reinterpret_cast<::validate::FieldRules*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.MapRules.keys)
}
inline ::validate::FieldRules* PROTOBUF_NULLABLE MapRules::release_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::validate::FieldRules* released = _impl_.keys_;
  _impl_.keys_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::validate::FieldRules* PROTOBUF_NULLABLE MapRules::unsafe_arena_release_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.MapRules.keys)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::validate::FieldRules* temp = _impl_.keys_;
  _impl_.keys_ = nullptr;
  return temp;
}
inline ::validate::FieldRules* PROTOBUF_NONNULL MapRules::_internal_mutable_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.keys_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::validate::FieldRules>(GetArena());
    _impl_.keys_ = reinterpret_cast<::validate::FieldRules*>(p);
  }
  return _impl_.keys_;
}
inline ::validate::FieldRules* PROTOBUF_NONNULL MapRules::mutable_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::validate::FieldRules* _msg = _internal_mutable_keys();
  // @@protoc_insertion_point(field_mutable:validate.MapRules.keys)
  return _msg;
}
inline void MapRules::set_allocated_keys(::validate::FieldRules* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.keys_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.keys_ = reinterpret_cast<::validate::FieldRules*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.MapRules.keys)
}

// optional .validate.FieldRules values = 5;
inline bool MapRules::has_values() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.values_ != nullptr);
  return value;
}
inline void MapRules::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.values_ != nullptr) _impl_.values_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::validate::FieldRules& MapRules::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::validate::FieldRules* p = _impl_.values_;
  return p != nullptr ? *p : reinterpret_cast<const ::validate::FieldRules&>(::validate::_FieldRules_default_instance_);
}
inline const ::validate::FieldRules& MapRules::values() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.MapRules.values)
  return _internal_values();
}
inline void MapRules::unsafe_arena_set_allocated_values(
    ::validate::FieldRules* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.values_);
  }
  _impl_.values_ = reinterpret_cast<::validate::FieldRules*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.MapRules.values)
}
inline ::validate::FieldRules* PROTOBUF_NULLABLE MapRules::release_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::validate::FieldRules* released = _impl_.values_;
  _impl_.values_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::validate::FieldRules* PROTOBUF_NULLABLE MapRules::unsafe_arena_release_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.MapRules.values)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::validate::FieldRules* temp = _impl_.values_;
  _impl_.values_ = nullptr;
  return temp;
}
inline ::validate::FieldRules* PROTOBUF_NONNULL MapRules::_internal_mutable_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.values_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::validate::FieldRules>(GetArena());
    _impl_.values_ = reinterpret_cast<::validate::FieldRules*>(p);
  }
  return _impl_.values_;
}
inline ::validate::FieldRules* PROTOBUF_NONNULL MapRules::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::validate::FieldRules* _msg = _internal_mutable_values();
  // @@protoc_insertion_point(field_mutable:validate.MapRules.values)
  return _msg;
}
inline void MapRules::set_allocated_values(::validate::FieldRules* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.values_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.values_ = reinterpret_cast<::validate::FieldRules*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.MapRules.values)
}

// optional bool ignore_empty = 6;
inline bool MapRules::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MapRules::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool MapRules::ignore_empty() const {
  // @@protoc_insertion_point(field_get:validate.MapRules.ignore_empty)
  return _internal_ignore_empty();
}
inline void MapRules::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.MapRules.ignore_empty)
}
inline bool MapRules::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void MapRules::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

// -------------------------------------------------------------------

// AnyRules

// optional bool required = 1;
inline bool AnyRules::has_required() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AnyRules::clear_required() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool AnyRules::required() const {
  // @@protoc_insertion_point(field_get:validate.AnyRules.required)
  return _internal_required();
}
inline void AnyRules::set_required(bool value) {
  _internal_set_required(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:validate.AnyRules.required)
}
inline bool AnyRules::_internal_required() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.required_;
}
inline void AnyRules::_internal_set_required(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_ = value;
}

// repeated string in = 2;
inline int AnyRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int AnyRules::in_size() const {
  return _internal_in_size();
}
inline void AnyRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL AnyRules::add_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:validate.AnyRules.in)
  return _s;
}
inline const ::std::string& AnyRules::in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.AnyRules.in)
  return _internal_in().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL AnyRules::mutable_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:validate.AnyRules.in)
  return _internal_mutable_in()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void AnyRules::set_in(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_in()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:validate.AnyRules.in)
}
template <typename Arg_, typename... Args_>
inline void AnyRules::add_in(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_in(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:validate.AnyRules.in)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& AnyRules::in()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.AnyRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
AnyRules::mutable_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.AnyRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
AnyRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
AnyRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated string not_in = 3;
inline int AnyRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int AnyRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void AnyRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL AnyRules::add_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_not_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:validate.AnyRules.not_in)
  return _s;
}
inline const ::std::string& AnyRules::not_in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.AnyRules.not_in)
  return _internal_not_in().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL AnyRules::mutable_not_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:validate.AnyRules.not_in)
  return _internal_mutable_not_in()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void AnyRules::set_not_in(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_not_in()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:validate.AnyRules.not_in)
}
template <typename Arg_, typename... Args_>
inline void AnyRules::add_not_in(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_not_in(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:validate.AnyRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& AnyRules::not_in()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.AnyRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
AnyRules::mutable_not_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.AnyRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
AnyRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
AnyRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// -------------------------------------------------------------------

// DurationRules

// optional bool required = 1;
inline bool DurationRules::has_required() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void DurationRules::clear_required() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool DurationRules::required() const {
  // @@protoc_insertion_point(field_get:validate.DurationRules.required)
  return _internal_required();
}
inline void DurationRules::set_required(bool value) {
  _internal_set_required(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:validate.DurationRules.required)
}
inline bool DurationRules::_internal_required() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.required_;
}
inline void DurationRules::_internal_set_required(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_ = value;
}

// optional .google.protobuf.Duration const = 2;
inline bool DurationRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.const__ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& DurationRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Duration* p = _impl_.const__;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::const_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.DurationRules.const)
  return _internal_const_();
}
inline void DurationRules::unsafe_arena_set_allocated_const_(
    ::google::protobuf::Duration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.const__);
  }
  _impl_.const__ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.DurationRules.const)
}
inline ::google::protobuf::Duration* PROTOBUF_NULLABLE DurationRules::release_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.const__;
  _impl_.const__ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Duration* PROTOBUF_NULLABLE DurationRules::unsafe_arena_release_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.DurationRules.const)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.const__;
  _impl_.const__ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::_internal_mutable_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.const__ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.const__ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.const__;
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::mutable_const_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Duration* _msg = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.const)
  return _msg;
}
inline void DurationRules::set_allocated_const_(::google::protobuf::Duration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.const__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.const__ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.const)
}

// optional .google.protobuf.Duration lt = 3;
inline bool DurationRules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lt_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& DurationRules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Duration* p = _impl_.lt_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::lt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.DurationRules.lt)
  return _internal_lt();
}
inline void DurationRules::unsafe_arena_set_allocated_lt(
    ::google::protobuf::Duration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lt_);
  }
  _impl_.lt_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.DurationRules.lt)
}
inline ::google::protobuf::Duration* PROTOBUF_NULLABLE DurationRules::release_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* released = _impl_.lt_;
  _impl_.lt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Duration* PROTOBUF_NULLABLE DurationRules::unsafe_arena_release_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.DurationRules.lt)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* temp = _impl_.lt_;
  _impl_.lt_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::_internal_mutable_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.lt_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.lt_;
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::mutable_lt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Duration* _msg = _internal_mutable_lt();
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.lt)
  return _msg;
}
inline void DurationRules::set_allocated_lt(::google::protobuf::Duration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lt_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.lt)
}

// optional .google.protobuf.Duration lte = 4;
inline bool DurationRules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lte_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& DurationRules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Duration* p = _impl_.lte_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::lte() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.DurationRules.lte)
  return _internal_lte();
}
inline void DurationRules::unsafe_arena_set_allocated_lte(
    ::google::protobuf::Duration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lte_);
  }
  _impl_.lte_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.DurationRules.lte)
}
inline ::google::protobuf::Duration* PROTOBUF_NULLABLE DurationRules::release_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* released = _impl_.lte_;
  _impl_.lte_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Duration* PROTOBUF_NULLABLE DurationRules::unsafe_arena_release_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.DurationRules.lte)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* temp = _impl_.lte_;
  _impl_.lte_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::_internal_mutable_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lte_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.lte_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.lte_;
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::mutable_lte()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Duration* _msg = _internal_mutable_lte();
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.lte)
  return _msg;
}
inline void DurationRules::set_allocated_lte(::google::protobuf::Duration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lte_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.lte_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.lte)
}

// optional .google.protobuf.Duration gt = 5;
inline bool DurationRules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gt_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& DurationRules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Duration* p = _impl_.gt_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::gt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.DurationRules.gt)
  return _internal_gt();
}
inline void DurationRules::unsafe_arena_set_allocated_gt(
    ::google::protobuf::Duration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gt_);
  }
  _impl_.gt_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.DurationRules.gt)
}
inline ::google::protobuf::Duration* PROTOBUF_NULLABLE DurationRules::release_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* released = _impl_.gt_;
  _impl_.gt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Duration* PROTOBUF_NULLABLE DurationRules::unsafe_arena_release_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.DurationRules.gt)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* temp = _impl_.gt_;
  _impl_.gt_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::_internal_mutable_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.gt_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.gt_;
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::mutable_gt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::Duration* _msg = _internal_mutable_gt();
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.gt)
  return _msg;
}
inline void DurationRules::set_allocated_gt(::google::protobuf::Duration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.gt_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.gt)
}

// optional .google.protobuf.Duration gte = 6;
inline bool DurationRules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gte_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& DurationRules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Duration* p = _impl_.gte_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::gte() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.DurationRules.gte)
  return _internal_gte();
}
inline void DurationRules::unsafe_arena_set_allocated_gte(
    ::google::protobuf::Duration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gte_);
  }
  _impl_.gte_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.DurationRules.gte)
}
inline ::google::protobuf::Duration* PROTOBUF_NULLABLE DurationRules::release_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Duration* released = _impl_.gte_;
  _impl_.gte_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Duration* PROTOBUF_NULLABLE DurationRules::unsafe_arena_release_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.DurationRules.gte)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Duration* temp = _impl_.gte_;
  _impl_.gte_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::_internal_mutable_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gte_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.gte_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.gte_;
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::mutable_gte()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::google::protobuf::Duration* _msg = _internal_mutable_gte();
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.gte)
  return _msg;
}
inline void DurationRules::set_allocated_gte(::google::protobuf::Duration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gte_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.gte_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.DurationRules.gte)
}

// repeated .google.protobuf.Duration in = 7;
inline int DurationRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int DurationRules::in_size() const {
  return _internal_in_size();
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::mutable_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.in)
  return _internal_mutable_in()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* PROTOBUF_NONNULL DurationRules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.DurationRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::Duration& DurationRules::in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.DurationRules.in)
  return _internal_in().Get(index);
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::add_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Duration* _add = _internal_mutable_in()->Add();
  // @@protoc_insertion_point(field_add:validate.DurationRules.in)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& DurationRules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.DurationRules.in)
  return _internal_in();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>&
DurationRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* PROTOBUF_NONNULL
DurationRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated .google.protobuf.Duration not_in = 8;
inline int DurationRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int DurationRules::not_in_size() const {
  return _internal_not_in_size();
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::mutable_not_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:validate.DurationRules.not_in)
  return _internal_mutable_not_in()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* PROTOBUF_NONNULL DurationRules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:validate.DurationRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::Duration& DurationRules::not_in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.DurationRules.not_in)
  return _internal_not_in().Get(index);
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL DurationRules::add_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Duration* _add = _internal_mutable_not_in()->Add();
  // @@protoc_insertion_point(field_add:validate.DurationRules.not_in)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& DurationRules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:validate.DurationRules.not_in)
  return _internal_not_in();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>&
DurationRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* PROTOBUF_NONNULL
DurationRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// -------------------------------------------------------------------

// TimestampRules

// optional bool required = 1;
inline bool TimestampRules::has_required() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void TimestampRules::clear_required() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool TimestampRules::required() const {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.required)
  return _internal_required();
}
inline void TimestampRules::set_required(bool value) {
  _internal_set_required(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:validate.TimestampRules.required)
}
inline bool TimestampRules::_internal_required() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.required_;
}
inline void TimestampRules::_internal_set_required(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_ = value;
}

// optional .google.protobuf.Timestamp const = 2;
inline bool TimestampRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.const__ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.const__;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::const_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.const)
  return _internal_const_();
}
inline void TimestampRules::unsafe_arena_set_allocated_const_(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.const__);
  }
  _impl_.const__ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.TimestampRules.const)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE TimestampRules::release_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.const__;
  _impl_.const__ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE TimestampRules::unsafe_arena_release_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.TimestampRules.const)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.const__;
  _impl_.const__ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL TimestampRules::_internal_mutable_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.const__ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.const__ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.const__;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL TimestampRules::mutable_const_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.const)
  return _msg;
}
inline void TimestampRules::set_allocated_const_(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.const__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.const__ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.const)
}

// optional .google.protobuf.Timestamp lt = 3;
inline bool TimestampRules::has_lt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lt_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_lt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.lt_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::lt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.lt)
  return _internal_lt();
}
inline void TimestampRules::unsafe_arena_set_allocated_lt(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lt_);
  }
  _impl_.lt_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.TimestampRules.lt)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE TimestampRules::release_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.lt_;
  _impl_.lt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE TimestampRules::unsafe_arena_release_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.TimestampRules.lt)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.lt_;
  _impl_.lt_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL TimestampRules::_internal_mutable_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.lt_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.lt_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL TimestampRules::mutable_lt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_lt();
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.lt)
  return _msg;
}
inline void TimestampRules::set_allocated_lt(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lt_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.lt)
}

// optional .google.protobuf.Timestamp lte = 4;
inline bool TimestampRules::has_lte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lte_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_lte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.lte_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::lte() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.lte)
  return _internal_lte();
}
inline void TimestampRules::unsafe_arena_set_allocated_lte(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lte_);
  }
  _impl_.lte_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.TimestampRules.lte)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE TimestampRules::release_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.lte_;
  _impl_.lte_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE TimestampRules::unsafe_arena_release_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.TimestampRules.lte)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.lte_;
  _impl_.lte_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL TimestampRules::_internal_mutable_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lte_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.lte_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.lte_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL TimestampRules::mutable_lte()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_lte();
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.lte)
  return _msg;
}
inline void TimestampRules::set_allocated_lte(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lte_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.lte_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.lte)
}

// optional .google.protobuf.Timestamp gt = 5;
inline bool TimestampRules::has_gt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gt_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_gt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.gt_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::gt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.gt)
  return _internal_gt();
}
inline void TimestampRules::unsafe_arena_set_allocated_gt(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gt_);
  }
  _impl_.gt_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.TimestampRules.gt)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE TimestampRules::release_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Timestamp* released = _impl_.gt_;
  _impl_.gt_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE TimestampRules::unsafe_arena_release_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.TimestampRules.gt)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Timestamp* temp = _impl_.gt_;
  _impl_.gt_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL TimestampRules::_internal_mutable_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gt_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.gt_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.gt_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL TimestampRules::mutable_gt()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_gt();
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.gt)
  return _msg;
}
inline void TimestampRules::set_allocated_gt(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.gt_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.gt)
}

// optional .google.protobuf.Timestamp gte = 6;
inline bool TimestampRules::has_gte() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gte_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_gte() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.gte_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::gte() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.gte)
  return _internal_gte();
}
inline void TimestampRules::unsafe_arena_set_allocated_gte(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gte_);
  }
  _impl_.gte_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.TimestampRules.gte)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE TimestampRules::release_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Timestamp* released = _impl_.gte_;
  _impl_.gte_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE TimestampRules::unsafe_arena_release_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.TimestampRules.gte)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::Timestamp* temp = _impl_.gte_;
  _impl_.gte_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL TimestampRules::_internal_mutable_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gte_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.gte_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.gte_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL TimestampRules::mutable_gte()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_gte();
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.gte)
  return _msg;
}
inline void TimestampRules::set_allocated_gte(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gte_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.gte_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.gte)
}

// optional bool lt_now = 7;
inline bool TimestampRules::has_lt_now() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void TimestampRules::clear_lt_now() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_now_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool TimestampRules::lt_now() const {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.lt_now)
  return _internal_lt_now();
}
inline void TimestampRules::set_lt_now(bool value) {
  _internal_set_lt_now(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:validate.TimestampRules.lt_now)
}
inline bool TimestampRules::_internal_lt_now() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lt_now_;
}
inline void TimestampRules::_internal_set_lt_now(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lt_now_ = value;
}

// optional bool gt_now = 8;
inline bool TimestampRules::has_gt_now() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void TimestampRules::clear_gt_now() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_now_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool TimestampRules::gt_now() const {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.gt_now)
  return _internal_gt_now();
}
inline void TimestampRules::set_gt_now(bool value) {
  _internal_set_gt_now(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:validate.TimestampRules.gt_now)
}
inline bool TimestampRules::_internal_gt_now() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gt_now_;
}
inline void TimestampRules::_internal_set_gt_now(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gt_now_ = value;
}

// optional .google.protobuf.Duration within = 9;
inline bool TimestampRules::has_within() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.within_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& TimestampRules::_internal_within() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Duration* p = _impl_.within_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& TimestampRules::within() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:validate.TimestampRules.within)
  return _internal_within();
}
inline void TimestampRules::unsafe_arena_set_allocated_within(
    ::google::protobuf::Duration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.within_);
  }
  _impl_.within_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:validate.TimestampRules.within)
}
inline ::google::protobuf::Duration* PROTOBUF_NULLABLE TimestampRules::release_within() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::Duration* released = _impl_.within_;
  _impl_.within_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Duration* PROTOBUF_NULLABLE TimestampRules::unsafe_arena_release_within() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:validate.TimestampRules.within)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::google::protobuf::Duration* temp = _impl_.within_;
  _impl_.within_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL TimestampRules::_internal_mutable_within() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.within_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.within_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.within_;
}
inline ::google::protobuf::Duration* PROTOBUF_NONNULL TimestampRules::mutable_within()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::google::protobuf::Duration* _msg = _internal_mutable_within();
  // @@protoc_insertion_point(field_mutable:validate.TimestampRules.within)
  return _msg;
}
inline void TimestampRules::set_allocated_within(::google::protobuf::Duration* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.within_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.within_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:validate.TimestampRules.within)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace validate


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::validate::KnownRegex> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::validate::KnownRegex>() {
  return ::validate::KnownRegex_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // validate_2fvalidate_2eproto_2epb_2eh
