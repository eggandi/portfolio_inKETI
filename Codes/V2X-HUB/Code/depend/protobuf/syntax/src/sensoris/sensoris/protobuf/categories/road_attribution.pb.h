// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: sensoris/protobuf/categories/road_attribution.proto
// Protobuf C++ Version: 6.31.1

#ifndef sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto_2epb_2eh
#define sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/wrappers.pb.h"
#include "sensoris/protobuf/types/base.pb.h"
#include "sensoris/protobuf/types/spatial.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
}  // extern "C"
namespace sensoris {
namespace protobuf {
namespace categories {
namespace roadattribution {
enum LaneBoundaryMergeSplit_TypeAndConfidence_Type : int;
extern const uint32_t LaneBoundaryMergeSplit_TypeAndConfidence_Type_internal_data_[];
enum LaneBoundary_MarkingOffsets_TypeAndOffset_Type : int;
extern const uint32_t LaneBoundary_MarkingOffsets_TypeAndOffset_Type_internal_data_[];
enum LaneBoundary_PositionReference : int;
extern const uint32_t LaneBoundary_PositionReference_internal_data_[];
enum LaneBoundary_TypeAndConfidence_Type : int;
extern const uint32_t LaneBoundary_TypeAndConfidence_Type_internal_data_[];
enum LaneCountAndConfidence_Type : int;
extern const uint32_t LaneCountAndConfidence_Type_internal_data_[];
enum MarkingColorAndConfidence_Type : int;
extern const uint32_t MarkingColorAndConfidence_Type_internal_data_[];
enum MarkingMaterialAndConfidence_Type : int;
extern const uint32_t MarkingMaterialAndConfidence_Type_internal_data_[];
enum RoadAttribution_ChangeTypeAndConfidence_Type : int;
extern const uint32_t RoadAttribution_ChangeTypeAndConfidence_Type_internal_data_[];
enum RoadAttribution_TypeAndConfidence_Type : int;
extern const uint32_t RoadAttribution_TypeAndConfidence_Type_internal_data_[];
enum SurfaceMarking_TypeAndConfidence_Type : int;
extern const uint32_t SurfaceMarking_TypeAndConfidence_Type_internal_data_[];
enum SurfaceMaterialAndConfidence_Type : int;
extern const uint32_t SurfaceMaterialAndConfidence_Type_internal_data_[];
class InclinationAndCurvature;
struct InclinationAndCurvatureDefaultTypeInternal;
extern InclinationAndCurvatureDefaultTypeInternal _InclinationAndCurvature_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InclinationAndCurvature_class_data_;
class Lane;
struct LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Lane_class_data_;
class LaneBoundary;
struct LaneBoundaryDefaultTypeInternal;
extern LaneBoundaryDefaultTypeInternal _LaneBoundary_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LaneBoundary_class_data_;
class LaneBoundaryMergeSplit;
struct LaneBoundaryMergeSplitDefaultTypeInternal;
extern LaneBoundaryMergeSplitDefaultTypeInternal _LaneBoundaryMergeSplit_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LaneBoundaryMergeSplit_class_data_;
class LaneBoundaryMergeSplit_TypeAndConfidence;
struct LaneBoundaryMergeSplit_TypeAndConfidenceDefaultTypeInternal;
extern LaneBoundaryMergeSplit_TypeAndConfidenceDefaultTypeInternal _LaneBoundaryMergeSplit_TypeAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LaneBoundaryMergeSplit_TypeAndConfidence_class_data_;
class LaneBoundary_DashStatistics;
struct LaneBoundary_DashStatisticsDefaultTypeInternal;
extern LaneBoundary_DashStatisticsDefaultTypeInternal _LaneBoundary_DashStatistics_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LaneBoundary_DashStatistics_class_data_;
class LaneBoundary_MarkingOffsets;
struct LaneBoundary_MarkingOffsetsDefaultTypeInternal;
extern LaneBoundary_MarkingOffsetsDefaultTypeInternal _LaneBoundary_MarkingOffsets_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LaneBoundary_MarkingOffsets_class_data_;
class LaneBoundary_MarkingOffsets_TypeAndOffset;
struct LaneBoundary_MarkingOffsets_TypeAndOffsetDefaultTypeInternal;
extern LaneBoundary_MarkingOffsets_TypeAndOffsetDefaultTypeInternal _LaneBoundary_MarkingOffsets_TypeAndOffset_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LaneBoundary_MarkingOffsets_TypeAndOffset_class_data_;
class LaneBoundary_TypeAndConfidence;
struct LaneBoundary_TypeAndConfidenceDefaultTypeInternal;
extern LaneBoundary_TypeAndConfidenceDefaultTypeInternal _LaneBoundary_TypeAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LaneBoundary_TypeAndConfidence_class_data_;
class LaneCountAndConfidence;
struct LaneCountAndConfidenceDefaultTypeInternal;
extern LaneCountAndConfidenceDefaultTypeInternal _LaneCountAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LaneCountAndConfidence_class_data_;
class MarkingColorAndConfidence;
struct MarkingColorAndConfidenceDefaultTypeInternal;
extern MarkingColorAndConfidenceDefaultTypeInternal _MarkingColorAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MarkingColorAndConfidence_class_data_;
class MarkingMaterialAndConfidence;
struct MarkingMaterialAndConfidenceDefaultTypeInternal;
extern MarkingMaterialAndConfidenceDefaultTypeInternal _MarkingMaterialAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MarkingMaterialAndConfidence_class_data_;
class Road;
struct RoadDefaultTypeInternal;
extern RoadDefaultTypeInternal _Road_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Road_class_data_;
class RoadAttribution;
struct RoadAttributionDefaultTypeInternal;
extern RoadAttributionDefaultTypeInternal _RoadAttribution_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadAttribution_class_data_;
class RoadAttributionCategory;
struct RoadAttributionCategoryDefaultTypeInternal;
extern RoadAttributionCategoryDefaultTypeInternal _RoadAttributionCategory_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadAttributionCategory_class_data_;
class RoadAttribution_ChangeTypeAndConfidence;
struct RoadAttribution_ChangeTypeAndConfidenceDefaultTypeInternal;
extern RoadAttribution_ChangeTypeAndConfidenceDefaultTypeInternal _RoadAttribution_ChangeTypeAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadAttribution_ChangeTypeAndConfidence_class_data_;
class RoadAttribution_TypeAndConfidence;
struct RoadAttribution_TypeAndConfidenceDefaultTypeInternal;
extern RoadAttribution_TypeAndConfidenceDefaultTypeInternal _RoadAttribution_TypeAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadAttribution_TypeAndConfidence_class_data_;
class SurfaceAttribution;
struct SurfaceAttributionDefaultTypeInternal;
extern SurfaceAttributionDefaultTypeInternal _SurfaceAttribution_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SurfaceAttribution_class_data_;
class SurfaceMarking;
struct SurfaceMarkingDefaultTypeInternal;
extern SurfaceMarkingDefaultTypeInternal _SurfaceMarking_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SurfaceMarking_class_data_;
class SurfaceMarking_TypeAndConfidence;
struct SurfaceMarking_TypeAndConfidenceDefaultTypeInternal;
extern SurfaceMarking_TypeAndConfidenceDefaultTypeInternal _SurfaceMarking_TypeAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SurfaceMarking_TypeAndConfidence_class_data_;
class SurfaceMaterialAndConfidence;
struct SurfaceMaterialAndConfidenceDefaultTypeInternal;
extern SurfaceMaterialAndConfidenceDefaultTypeInternal _SurfaceMaterialAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SurfaceMaterialAndConfidence_class_data_;
}  // namespace roadattribution
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type>;
}  // namespace protobuf
}  // namespace google

namespace sensoris {
namespace protobuf {
namespace categories {
namespace roadattribution {
enum MarkingColorAndConfidence_Type : int {
  MarkingColorAndConfidence_Type_UNKNOWN_TYPE = 0,
  MarkingColorAndConfidence_Type_WHITE = 1,
  MarkingColorAndConfidence_Type_GRAY = 2,
  MarkingColorAndConfidence_Type_GRAY_LIGHT = 3,
  MarkingColorAndConfidence_Type_GRAY_DARK = 4,
  MarkingColorAndConfidence_Type_BLACK = 5,
  MarkingColorAndConfidence_Type_RED = 6,
  MarkingColorAndConfidence_Type_YELLOW = 7,
  MarkingColorAndConfidence_Type_GREEN = 8,
  MarkingColorAndConfidence_Type_CYAN = 9,
  MarkingColorAndConfidence_Type_BLUE = 10,
  MarkingColorAndConfidence_Type_ORANGE = 11,
  MarkingColorAndConfidence_Type_PINK = 12,
  MarkingColorAndConfidence_Type_PURPLE = 13,
  MarkingColorAndConfidence_Type_MarkingColorAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MarkingColorAndConfidence_Type_MarkingColorAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MarkingColorAndConfidence_Type_internal_data_[];
inline constexpr MarkingColorAndConfidence_Type MarkingColorAndConfidence_Type_Type_MIN =
    static_cast<MarkingColorAndConfidence_Type>(0);
inline constexpr MarkingColorAndConfidence_Type MarkingColorAndConfidence_Type_Type_MAX =
    static_cast<MarkingColorAndConfidence_Type>(13);
inline bool MarkingColorAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 13;
}
inline constexpr int MarkingColorAndConfidence_Type_Type_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MarkingColorAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& MarkingColorAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, MarkingColorAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return MarkingColorAndConfidence_Type_Name(static_cast<MarkingColorAndConfidence_Type>(value));
}
template <>
inline const ::std::string& MarkingColorAndConfidence_Type_Name(MarkingColorAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MarkingColorAndConfidence_Type_descriptor, 0, 13>(
      static_cast<int>(value));
}
inline bool MarkingColorAndConfidence_Type_Parse(
    ::absl::string_view name, MarkingColorAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarkingColorAndConfidence_Type>(MarkingColorAndConfidence_Type_descriptor(), name,
                                           value);
}
enum MarkingMaterialAndConfidence_Type : int {
  MarkingMaterialAndConfidence_Type_UNKNOWN_TYPE = 0,
  MarkingMaterialAndConfidence_Type_METAL = 1,
  MarkingMaterialAndConfidence_Type_CONCRETE = 2,
  MarkingMaterialAndConfidence_Type_STONE = 3,
  MarkingMaterialAndConfidence_Type_WOOD = 4,
  MarkingMaterialAndConfidence_Type_PLASTIC = 5,
  MarkingMaterialAndConfidence_Type_TRANSPARENT = 6,
  MarkingMaterialAndConfidence_Type_VIBRATION_MARKINGS = 7,
  MarkingMaterialAndConfidence_Type_PAINT = 8,
  MarkingMaterialAndConfidence_Type_ASPHALT = 9,
  MarkingMaterialAndConfidence_Type_GRAVEL = 10,
  MarkingMaterialAndConfidence_Type_COBBLESTONE = 11,
  MarkingMaterialAndConfidence_Type_MarkingMaterialAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  MarkingMaterialAndConfidence_Type_MarkingMaterialAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t MarkingMaterialAndConfidence_Type_internal_data_[];
inline constexpr MarkingMaterialAndConfidence_Type MarkingMaterialAndConfidence_Type_Type_MIN =
    static_cast<MarkingMaterialAndConfidence_Type>(0);
inline constexpr MarkingMaterialAndConfidence_Type MarkingMaterialAndConfidence_Type_Type_MAX =
    static_cast<MarkingMaterialAndConfidence_Type>(11);
inline bool MarkingMaterialAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 11;
}
inline constexpr int MarkingMaterialAndConfidence_Type_Type_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MarkingMaterialAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& MarkingMaterialAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, MarkingMaterialAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return MarkingMaterialAndConfidence_Type_Name(static_cast<MarkingMaterialAndConfidence_Type>(value));
}
template <>
inline const ::std::string& MarkingMaterialAndConfidence_Type_Name(MarkingMaterialAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MarkingMaterialAndConfidence_Type_descriptor, 0, 11>(
      static_cast<int>(value));
}
inline bool MarkingMaterialAndConfidence_Type_Parse(
    ::absl::string_view name, MarkingMaterialAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarkingMaterialAndConfidence_Type>(MarkingMaterialAndConfidence_Type_descriptor(), name,
                                           value);
}
enum SurfaceMaterialAndConfidence_Type : int {
  SurfaceMaterialAndConfidence_Type_UNKNOWN_TYPE = 0,
  SurfaceMaterialAndConfidence_Type_ASPHALT = 1,
  SurfaceMaterialAndConfidence_Type_CONCRETE = 2,
  SurfaceMaterialAndConfidence_Type_COMPOSITE_PAVEMENT = 3,
  SurfaceMaterialAndConfidence_Type_RECYCLING = 4,
  SurfaceMaterialAndConfidence_Type_GRAVEL = 5,
  SurfaceMaterialAndConfidence_Type_COBBLESTONE = 6,
  SurfaceMaterialAndConfidence_Type_SurfaceMaterialAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SurfaceMaterialAndConfidence_Type_SurfaceMaterialAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SurfaceMaterialAndConfidence_Type_internal_data_[];
inline constexpr SurfaceMaterialAndConfidence_Type SurfaceMaterialAndConfidence_Type_Type_MIN =
    static_cast<SurfaceMaterialAndConfidence_Type>(0);
inline constexpr SurfaceMaterialAndConfidence_Type SurfaceMaterialAndConfidence_Type_Type_MAX =
    static_cast<SurfaceMaterialAndConfidence_Type>(6);
inline bool SurfaceMaterialAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int SurfaceMaterialAndConfidence_Type_Type_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SurfaceMaterialAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& SurfaceMaterialAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, SurfaceMaterialAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return SurfaceMaterialAndConfidence_Type_Name(static_cast<SurfaceMaterialAndConfidence_Type>(value));
}
template <>
inline const ::std::string& SurfaceMaterialAndConfidence_Type_Name(SurfaceMaterialAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SurfaceMaterialAndConfidence_Type_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool SurfaceMaterialAndConfidence_Type_Parse(
    ::absl::string_view name, SurfaceMaterialAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SurfaceMaterialAndConfidence_Type>(SurfaceMaterialAndConfidence_Type_descriptor(), name,
                                           value);
}
enum LaneBoundary_TypeAndConfidence_Type : int {
  LaneBoundary_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  LaneBoundary_TypeAndConfidence_Type_LINE = 1,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE = 2,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_SOLID = 3,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED = 4,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED_SHORT = 5,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED_LONG = 6,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE = 7,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID = 8,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED = 9,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_DASHED = 10,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_SOLID = 11,
  LaneBoundary_TypeAndConfidence_Type_SHADED_AREA_MARKING = 12,
  LaneBoundary_TypeAndConfidence_Type_BLOCKS_DASHED = 13,
  LaneBoundary_TypeAndConfidence_Type_CROSSING_ALERT = 14,
  LaneBoundary_TypeAndConfidence_Type_CURB = 15,
  LaneBoundary_TypeAndConfidence_Type_CURB_TRAVERSABLE = 16,
  LaneBoundary_TypeAndConfidence_Type_CURB_NON_TRAVERSABLE = 17,
  LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER = 18,
  LaneBoundary_TypeAndConfidence_Type_WALL = 19,
  LaneBoundary_TypeAndConfidence_Type_WALL_FLAT = 20,
  LaneBoundary_TypeAndConfidence_Type_WALL_CURVED = 21,
  LaneBoundary_TypeAndConfidence_Type_BARRIER = 22,
  LaneBoundary_TypeAndConfidence_Type_BARRIER_JERSEY = 23,
  LaneBoundary_TypeAndConfidence_Type_BARRIER_SOUND = 24,
  LaneBoundary_TypeAndConfidence_Type_BARRIER_CABLE = 25,
  LaneBoundary_TypeAndConfidence_Type_GUARDRAIL = 26,
  LaneBoundary_TypeAndConfidence_Type_FENCE = 27,
  LaneBoundary_TypeAndConfidence_Type_ROAD_EDGE = 28,
  LaneBoundary_TypeAndConfidence_Type_CLIFF = 29,
  LaneBoundary_TypeAndConfidence_Type_DITCH = 30,
  LaneBoundary_TypeAndConfidence_Type_ASPHALT_JOINT = 31,
  LaneBoundary_TypeAndConfidence_Type_LINE_MULTIPLE = 32,
  LaneBoundary_TypeAndConfidence_Type_LINE_MULTIPLE_ALL_DASHED = 33,
  LaneBoundary_TypeAndConfidence_Type_LINE_MULTIPLE_ANY_SOLID = 34,
  LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER_CONTINUOUS = 35,
  LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER_DISCONTINUOUS = 36,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_OR_DOUBLE_SOLID_DASHED = 37,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_OR_DOUBLE_DASHED_SOLID = 38,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_OR_DOUBLE_SOLID_DASHED = 39,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_OR_DOUBLE_DASHED_SOLID = 40,
  LaneBoundary_TypeAndConfidence_Type_LaneBoundary_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  LaneBoundary_TypeAndConfidence_Type_LaneBoundary_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t LaneBoundary_TypeAndConfidence_Type_internal_data_[];
inline constexpr LaneBoundary_TypeAndConfidence_Type LaneBoundary_TypeAndConfidence_Type_Type_MIN =
    static_cast<LaneBoundary_TypeAndConfidence_Type>(0);
inline constexpr LaneBoundary_TypeAndConfidence_Type LaneBoundary_TypeAndConfidence_Type_Type_MAX =
    static_cast<LaneBoundary_TypeAndConfidence_Type>(40);
inline bool LaneBoundary_TypeAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 40;
}
inline constexpr int LaneBoundary_TypeAndConfidence_Type_Type_ARRAYSIZE = 40 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LaneBoundary_TypeAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& LaneBoundary_TypeAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, LaneBoundary_TypeAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return LaneBoundary_TypeAndConfidence_Type_Name(static_cast<LaneBoundary_TypeAndConfidence_Type>(value));
}
template <>
inline const ::std::string& LaneBoundary_TypeAndConfidence_Type_Name(LaneBoundary_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LaneBoundary_TypeAndConfidence_Type_descriptor, 0, 40>(
      static_cast<int>(value));
}
inline bool LaneBoundary_TypeAndConfidence_Type_Parse(
    ::absl::string_view name, LaneBoundary_TypeAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundary_TypeAndConfidence_Type>(LaneBoundary_TypeAndConfidence_Type_descriptor(), name,
                                           value);
}
enum LaneBoundary_MarkingOffsets_TypeAndOffset_Type : int {
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_UNKNOWN_TYPE = 0,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_START_OF_MARKING = 1,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_END_OF_MARKING = 2,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_ON_MARKING = 3,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_NO_MARKING = 4,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_LaneBoundary_MarkingOffsets_TypeAndOffset_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_LaneBoundary_MarkingOffsets_TypeAndOffset_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t LaneBoundary_MarkingOffsets_TypeAndOffset_Type_internal_data_[];
inline constexpr LaneBoundary_MarkingOffsets_TypeAndOffset_Type LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MIN =
    static_cast<LaneBoundary_MarkingOffsets_TypeAndOffset_Type>(0);
inline constexpr LaneBoundary_MarkingOffsets_TypeAndOffset_Type LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MAX =
    static_cast<LaneBoundary_MarkingOffsets_TypeAndOffset_Type>(4);
inline bool LaneBoundary_MarkingOffsets_TypeAndOffset_Type_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor();
template <typename T>
const ::std::string& LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Name(T value) {
  static_assert(::std::is_same<T, LaneBoundary_MarkingOffsets_TypeAndOffset_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Name(static_cast<LaneBoundary_MarkingOffsets_TypeAndOffset_Type>(value));
}
template <>
inline const ::std::string& LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Name(LaneBoundary_MarkingOffsets_TypeAndOffset_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Parse(
    ::absl::string_view name, LaneBoundary_MarkingOffsets_TypeAndOffset_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundary_MarkingOffsets_TypeAndOffset_Type>(LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor(), name,
                                           value);
}
enum LaneBoundary_PositionReference : int {
  LaneBoundary_PositionReference_UNKNOWN_POSITION_REFERENCE = 0,
  LaneBoundary_PositionReference_LEFT_MARKING_BOUNDARY = 1,
  LaneBoundary_PositionReference_CENTER_LINE = 2,
  LaneBoundary_PositionReference_RIGHT_MARKING_BOUNDARY = 3,
  LaneBoundary_PositionReference_LaneBoundary_PositionReference_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  LaneBoundary_PositionReference_LaneBoundary_PositionReference_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t LaneBoundary_PositionReference_internal_data_[];
inline constexpr LaneBoundary_PositionReference LaneBoundary_PositionReference_PositionReference_MIN =
    static_cast<LaneBoundary_PositionReference>(0);
inline constexpr LaneBoundary_PositionReference LaneBoundary_PositionReference_PositionReference_MAX =
    static_cast<LaneBoundary_PositionReference>(3);
inline bool LaneBoundary_PositionReference_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int LaneBoundary_PositionReference_PositionReference_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LaneBoundary_PositionReference_descriptor();
template <typename T>
const ::std::string& LaneBoundary_PositionReference_Name(T value) {
  static_assert(::std::is_same<T, LaneBoundary_PositionReference>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PositionReference_Name().");
  return LaneBoundary_PositionReference_Name(static_cast<LaneBoundary_PositionReference>(value));
}
template <>
inline const ::std::string& LaneBoundary_PositionReference_Name(LaneBoundary_PositionReference value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LaneBoundary_PositionReference_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool LaneBoundary_PositionReference_Parse(
    ::absl::string_view name, LaneBoundary_PositionReference* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundary_PositionReference>(LaneBoundary_PositionReference_descriptor(), name,
                                           value);
}
enum LaneBoundaryMergeSplit_TypeAndConfidence_Type : int {
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_MERGE = 1,
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_SPLIT = 2,
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_LaneBoundaryMergeSplit_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_LaneBoundaryMergeSplit_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t LaneBoundaryMergeSplit_TypeAndConfidence_Type_internal_data_[];
inline constexpr LaneBoundaryMergeSplit_TypeAndConfidence_Type LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MIN =
    static_cast<LaneBoundaryMergeSplit_TypeAndConfidence_Type>(0);
inline constexpr LaneBoundaryMergeSplit_TypeAndConfidence_Type LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MAX =
    static_cast<LaneBoundaryMergeSplit_TypeAndConfidence_Type>(2);
inline bool LaneBoundaryMergeSplit_TypeAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& LaneBoundaryMergeSplit_TypeAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, LaneBoundaryMergeSplit_TypeAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return LaneBoundaryMergeSplit_TypeAndConfidence_Type_Name(static_cast<LaneBoundaryMergeSplit_TypeAndConfidence_Type>(value));
}
template <>
inline const ::std::string& LaneBoundaryMergeSplit_TypeAndConfidence_Type_Name(LaneBoundaryMergeSplit_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool LaneBoundaryMergeSplit_TypeAndConfidence_Type_Parse(
    ::absl::string_view name, LaneBoundaryMergeSplit_TypeAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundaryMergeSplit_TypeAndConfidence_Type>(LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor(), name,
                                           value);
}
enum SurfaceMarking_TypeAndConfidence_Type : int {
  SurfaceMarking_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  SurfaceMarking_TypeAndConfidence_Type_SIGN = 1,
  SurfaceMarking_TypeAndConfidence_Type_TEXT = 2,
  SurfaceMarking_TypeAndConfidence_Type_ICON = 3,
  SurfaceMarking_TypeAndConfidence_Type_PATTERN = 4,
  SurfaceMarking_TypeAndConfidence_Type_PATTERN_CROSSWALK = 5,
  SurfaceMarking_TypeAndConfidence_Type_LINE_ELEMENT = 6,
  SurfaceMarking_TypeAndConfidence_Type_STOP_LINE = 7,
  SurfaceMarking_TypeAndConfidence_Type_SurfaceMarking_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SurfaceMarking_TypeAndConfidence_Type_SurfaceMarking_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SurfaceMarking_TypeAndConfidence_Type_internal_data_[];
inline constexpr SurfaceMarking_TypeAndConfidence_Type SurfaceMarking_TypeAndConfidence_Type_Type_MIN =
    static_cast<SurfaceMarking_TypeAndConfidence_Type>(0);
inline constexpr SurfaceMarking_TypeAndConfidence_Type SurfaceMarking_TypeAndConfidence_Type_Type_MAX =
    static_cast<SurfaceMarking_TypeAndConfidence_Type>(7);
inline bool SurfaceMarking_TypeAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int SurfaceMarking_TypeAndConfidence_Type_Type_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SurfaceMarking_TypeAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& SurfaceMarking_TypeAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, SurfaceMarking_TypeAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return SurfaceMarking_TypeAndConfidence_Type_Name(static_cast<SurfaceMarking_TypeAndConfidence_Type>(value));
}
template <>
inline const ::std::string& SurfaceMarking_TypeAndConfidence_Type_Name(SurfaceMarking_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SurfaceMarking_TypeAndConfidence_Type_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool SurfaceMarking_TypeAndConfidence_Type_Parse(
    ::absl::string_view name, SurfaceMarking_TypeAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SurfaceMarking_TypeAndConfidence_Type>(SurfaceMarking_TypeAndConfidence_Type_descriptor(), name,
                                           value);
}
enum RoadAttribution_TypeAndConfidence_Type : int {
  RoadAttribution_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadAttribution_TypeAndConfidence_Type_MOTORWAY = 1,
  RoadAttribution_TypeAndConfidence_Type_ONE_WAY_TRAFFIC = 2,
  RoadAttribution_TypeAndConfidence_Type_TWO_WAY_TRAFFIC = 3,
  RoadAttribution_TypeAndConfidence_Type_OFFROAD = 4,
  RoadAttribution_TypeAndConfidence_Type_TUNNEL = 5,
  RoadAttribution_TypeAndConfidence_Type_BRIDGE = 6,
  RoadAttribution_TypeAndConfidence_Type_ARTIFICIAL_ILLUMINATION = 7,
  RoadAttribution_TypeAndConfidence_Type_ROAD_WORKS_NARROW_LANES = 8,
  RoadAttribution_TypeAndConfidence_Type_LANE_RIGHT = 9,
  RoadAttribution_TypeAndConfidence_Type_LANE_LEFT = 10,
  RoadAttribution_TypeAndConfidence_Type_LANE_SPLIT_MIDDLE = 11,
  RoadAttribution_TypeAndConfidence_Type_LANE_MERGE_MIDDLE = 12,
  RoadAttribution_TypeAndConfidence_Type_CROSSWALK = 13,
  RoadAttribution_TypeAndConfidence_Type_CENTER_TURN_LANE = 14,
  RoadAttribution_TypeAndConfidence_Type_RoadAttribution_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RoadAttribution_TypeAndConfidence_Type_RoadAttribution_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RoadAttribution_TypeAndConfidence_Type_internal_data_[];
inline constexpr RoadAttribution_TypeAndConfidence_Type RoadAttribution_TypeAndConfidence_Type_Type_MIN =
    static_cast<RoadAttribution_TypeAndConfidence_Type>(0);
inline constexpr RoadAttribution_TypeAndConfidence_Type RoadAttribution_TypeAndConfidence_Type_Type_MAX =
    static_cast<RoadAttribution_TypeAndConfidence_Type>(14);
inline bool RoadAttribution_TypeAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 14;
}
inline constexpr int RoadAttribution_TypeAndConfidence_Type_Type_ARRAYSIZE = 14 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RoadAttribution_TypeAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& RoadAttribution_TypeAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, RoadAttribution_TypeAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadAttribution_TypeAndConfidence_Type_Name(static_cast<RoadAttribution_TypeAndConfidence_Type>(value));
}
template <>
inline const ::std::string& RoadAttribution_TypeAndConfidence_Type_Name(RoadAttribution_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadAttribution_TypeAndConfidence_Type_descriptor, 0, 14>(
      static_cast<int>(value));
}
inline bool RoadAttribution_TypeAndConfidence_Type_Parse(
    ::absl::string_view name, RoadAttribution_TypeAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadAttribution_TypeAndConfidence_Type>(RoadAttribution_TypeAndConfidence_Type_descriptor(), name,
                                           value);
}
enum RoadAttribution_ChangeTypeAndConfidence_Type : int {
  RoadAttribution_ChangeTypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadAttribution_ChangeTypeAndConfidence_Type_DETECTED = 1,
  RoadAttribution_ChangeTypeAndConfidence_Type_START = 2,
  RoadAttribution_ChangeTypeAndConfidence_Type_END = 3,
  RoadAttribution_ChangeTypeAndConfidence_Type_RoadAttribution_ChangeTypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RoadAttribution_ChangeTypeAndConfidence_Type_RoadAttribution_ChangeTypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RoadAttribution_ChangeTypeAndConfidence_Type_internal_data_[];
inline constexpr RoadAttribution_ChangeTypeAndConfidence_Type RoadAttribution_ChangeTypeAndConfidence_Type_Type_MIN =
    static_cast<RoadAttribution_ChangeTypeAndConfidence_Type>(0);
inline constexpr RoadAttribution_ChangeTypeAndConfidence_Type RoadAttribution_ChangeTypeAndConfidence_Type_Type_MAX =
    static_cast<RoadAttribution_ChangeTypeAndConfidence_Type>(3);
inline bool RoadAttribution_ChangeTypeAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int RoadAttribution_ChangeTypeAndConfidence_Type_Type_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RoadAttribution_ChangeTypeAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& RoadAttribution_ChangeTypeAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, RoadAttribution_ChangeTypeAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadAttribution_ChangeTypeAndConfidence_Type_Name(static_cast<RoadAttribution_ChangeTypeAndConfidence_Type>(value));
}
template <>
inline const ::std::string& RoadAttribution_ChangeTypeAndConfidence_Type_Name(RoadAttribution_ChangeTypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadAttribution_ChangeTypeAndConfidence_Type_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool RoadAttribution_ChangeTypeAndConfidence_Type_Parse(
    ::absl::string_view name, RoadAttribution_ChangeTypeAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadAttribution_ChangeTypeAndConfidence_Type>(RoadAttribution_ChangeTypeAndConfidence_Type_descriptor(), name,
                                           value);
}
enum LaneCountAndConfidence_Type : int {
  LaneCountAndConfidence_Type_UNKNOWN_TYPE = 0,
  LaneCountAndConfidence_Type_TOTAL = 1,
  LaneCountAndConfidence_Type_LEFT_INCLUDING_EGO_LANE = 2,
  LaneCountAndConfidence_Type_RIGHT = 3,
  LaneCountAndConfidence_Type_LaneCountAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  LaneCountAndConfidence_Type_LaneCountAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t LaneCountAndConfidence_Type_internal_data_[];
inline constexpr LaneCountAndConfidence_Type LaneCountAndConfidence_Type_Type_MIN =
    static_cast<LaneCountAndConfidence_Type>(0);
inline constexpr LaneCountAndConfidence_Type LaneCountAndConfidence_Type_Type_MAX =
    static_cast<LaneCountAndConfidence_Type>(3);
inline bool LaneCountAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int LaneCountAndConfidence_Type_Type_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LaneCountAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& LaneCountAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, LaneCountAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return LaneCountAndConfidence_Type_Name(static_cast<LaneCountAndConfidence_Type>(value));
}
template <>
inline const ::std::string& LaneCountAndConfidence_Type_Name(LaneCountAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LaneCountAndConfidence_Type_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool LaneCountAndConfidence_Type_Parse(
    ::absl::string_view name, LaneCountAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneCountAndConfidence_Type>(LaneCountAndConfidence_Type_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class SurfaceMaterialAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence) */ {
 public:
  inline SurfaceMaterialAndConfidence() : SurfaceMaterialAndConfidence(nullptr) {}
  ~SurfaceMaterialAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SurfaceMaterialAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SurfaceMaterialAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SurfaceMaterialAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline SurfaceMaterialAndConfidence(const SurfaceMaterialAndConfidence& from) : SurfaceMaterialAndConfidence(nullptr, from) {}
  inline SurfaceMaterialAndConfidence(SurfaceMaterialAndConfidence&& from) noexcept
      : SurfaceMaterialAndConfidence(nullptr, ::std::move(from)) {}
  inline SurfaceMaterialAndConfidence& operator=(const SurfaceMaterialAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline SurfaceMaterialAndConfidence& operator=(SurfaceMaterialAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SurfaceMaterialAndConfidence& default_instance() {
    return *reinterpret_cast<const SurfaceMaterialAndConfidence*>(
        &_SurfaceMaterialAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(SurfaceMaterialAndConfidence& a, SurfaceMaterialAndConfidence& b) { a.Swap(&b); }
  inline void Swap(SurfaceMaterialAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SurfaceMaterialAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SurfaceMaterialAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SurfaceMaterialAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SurfaceMaterialAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SurfaceMaterialAndConfidence& from) { SurfaceMaterialAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SurfaceMaterialAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence"; }

 protected:
  explicit SurfaceMaterialAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SurfaceMaterialAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SurfaceMaterialAndConfidence& from);
  SurfaceMaterialAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SurfaceMaterialAndConfidence&& from) noexcept
      : SurfaceMaterialAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = SurfaceMaterialAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = SurfaceMaterialAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type ASPHALT = SurfaceMaterialAndConfidence_Type_ASPHALT;
  static constexpr Type CONCRETE = SurfaceMaterialAndConfidence_Type_CONCRETE;
  static constexpr Type COMPOSITE_PAVEMENT = SurfaceMaterialAndConfidence_Type_COMPOSITE_PAVEMENT;
  static constexpr Type RECYCLING = SurfaceMaterialAndConfidence_Type_RECYCLING;
  static constexpr Type GRAVEL = SurfaceMaterialAndConfidence_Type_GRAVEL;
  static constexpr Type COBBLESTONE = SurfaceMaterialAndConfidence_Type_COBBLESTONE;
  static inline bool Type_IsValid(int value) {
    return SurfaceMaterialAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = SurfaceMaterialAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = SurfaceMaterialAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = SurfaceMaterialAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return SurfaceMaterialAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return SurfaceMaterialAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return SurfaceMaterialAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SurfaceMaterialAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SurfaceMaterialAndConfidence_class_data_;
// -------------------------------------------------------------------

class SurfaceMarking_TypeAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence) */ {
 public:
  inline SurfaceMarking_TypeAndConfidence() : SurfaceMarking_TypeAndConfidence(nullptr) {}
  ~SurfaceMarking_TypeAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SurfaceMarking_TypeAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SurfaceMarking_TypeAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SurfaceMarking_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline SurfaceMarking_TypeAndConfidence(const SurfaceMarking_TypeAndConfidence& from) : SurfaceMarking_TypeAndConfidence(nullptr, from) {}
  inline SurfaceMarking_TypeAndConfidence(SurfaceMarking_TypeAndConfidence&& from) noexcept
      : SurfaceMarking_TypeAndConfidence(nullptr, ::std::move(from)) {}
  inline SurfaceMarking_TypeAndConfidence& operator=(const SurfaceMarking_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline SurfaceMarking_TypeAndConfidence& operator=(SurfaceMarking_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SurfaceMarking_TypeAndConfidence& default_instance() {
    return *reinterpret_cast<const SurfaceMarking_TypeAndConfidence*>(
        &_SurfaceMarking_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SurfaceMarking_TypeAndConfidence& a, SurfaceMarking_TypeAndConfidence& b) { a.Swap(&b); }
  inline void Swap(SurfaceMarking_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SurfaceMarking_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SurfaceMarking_TypeAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SurfaceMarking_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SurfaceMarking_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SurfaceMarking_TypeAndConfidence& from) { SurfaceMarking_TypeAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SurfaceMarking_TypeAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence"; }

 protected:
  explicit SurfaceMarking_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SurfaceMarking_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SurfaceMarking_TypeAndConfidence& from);
  SurfaceMarking_TypeAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SurfaceMarking_TypeAndConfidence&& from) noexcept
      : SurfaceMarking_TypeAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = SurfaceMarking_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = SurfaceMarking_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type SIGN = SurfaceMarking_TypeAndConfidence_Type_SIGN;
  static constexpr Type TEXT = SurfaceMarking_TypeAndConfidence_Type_TEXT;
  static constexpr Type ICON = SurfaceMarking_TypeAndConfidence_Type_ICON;
  static constexpr Type PATTERN = SurfaceMarking_TypeAndConfidence_Type_PATTERN;
  static constexpr Type PATTERN_CROSSWALK = SurfaceMarking_TypeAndConfidence_Type_PATTERN_CROSSWALK;
  static constexpr Type LINE_ELEMENT = SurfaceMarking_TypeAndConfidence_Type_LINE_ELEMENT;
  static constexpr Type STOP_LINE = SurfaceMarking_TypeAndConfidence_Type_STOP_LINE;
  static inline bool Type_IsValid(int value) {
    return SurfaceMarking_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = SurfaceMarking_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = SurfaceMarking_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = SurfaceMarking_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return SurfaceMarking_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return SurfaceMarking_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return SurfaceMarking_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SurfaceMarking_TypeAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SurfaceMarking_TypeAndConfidence_class_data_;
// -------------------------------------------------------------------

class RoadAttribution_TypeAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence) */ {
 public:
  inline RoadAttribution_TypeAndConfidence() : RoadAttribution_TypeAndConfidence(nullptr) {}
  ~RoadAttribution_TypeAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadAttribution_TypeAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadAttribution_TypeAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadAttribution_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadAttribution_TypeAndConfidence(const RoadAttribution_TypeAndConfidence& from) : RoadAttribution_TypeAndConfidence(nullptr, from) {}
  inline RoadAttribution_TypeAndConfidence(RoadAttribution_TypeAndConfidence&& from) noexcept
      : RoadAttribution_TypeAndConfidence(nullptr, ::std::move(from)) {}
  inline RoadAttribution_TypeAndConfidence& operator=(const RoadAttribution_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadAttribution_TypeAndConfidence& operator=(RoadAttribution_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadAttribution_TypeAndConfidence& default_instance() {
    return *reinterpret_cast<const RoadAttribution_TypeAndConfidence*>(
        &_RoadAttribution_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(RoadAttribution_TypeAndConfidence& a, RoadAttribution_TypeAndConfidence& b) { a.Swap(&b); }
  inline void Swap(RoadAttribution_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadAttribution_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadAttribution_TypeAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadAttribution_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadAttribution_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadAttribution_TypeAndConfidence& from) { RoadAttribution_TypeAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadAttribution_TypeAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence"; }

 protected:
  explicit RoadAttribution_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadAttribution_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadAttribution_TypeAndConfidence& from);
  RoadAttribution_TypeAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadAttribution_TypeAndConfidence&& from) noexcept
      : RoadAttribution_TypeAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = RoadAttribution_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadAttribution_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type MOTORWAY = RoadAttribution_TypeAndConfidence_Type_MOTORWAY;
  static constexpr Type ONE_WAY_TRAFFIC = RoadAttribution_TypeAndConfidence_Type_ONE_WAY_TRAFFIC;
  static constexpr Type TWO_WAY_TRAFFIC = RoadAttribution_TypeAndConfidence_Type_TWO_WAY_TRAFFIC;
  static constexpr Type OFFROAD = RoadAttribution_TypeAndConfidence_Type_OFFROAD;
  static constexpr Type TUNNEL = RoadAttribution_TypeAndConfidence_Type_TUNNEL;
  static constexpr Type BRIDGE = RoadAttribution_TypeAndConfidence_Type_BRIDGE;
  static constexpr Type ARTIFICIAL_ILLUMINATION = RoadAttribution_TypeAndConfidence_Type_ARTIFICIAL_ILLUMINATION;
  static constexpr Type ROAD_WORKS_NARROW_LANES = RoadAttribution_TypeAndConfidence_Type_ROAD_WORKS_NARROW_LANES;
  static constexpr Type LANE_RIGHT = RoadAttribution_TypeAndConfidence_Type_LANE_RIGHT;
  static constexpr Type LANE_LEFT = RoadAttribution_TypeAndConfidence_Type_LANE_LEFT;
  static constexpr Type LANE_SPLIT_MIDDLE = RoadAttribution_TypeAndConfidence_Type_LANE_SPLIT_MIDDLE;
  static constexpr Type LANE_MERGE_MIDDLE = RoadAttribution_TypeAndConfidence_Type_LANE_MERGE_MIDDLE;
  static constexpr Type CROSSWALK = RoadAttribution_TypeAndConfidence_Type_CROSSWALK;
  static constexpr Type CENTER_TURN_LANE = RoadAttribution_TypeAndConfidence_Type_CENTER_TURN_LANE;
  static inline bool Type_IsValid(int value) {
    return RoadAttribution_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadAttribution_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadAttribution_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadAttribution_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return RoadAttribution_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return RoadAttribution_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return RoadAttribution_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadAttribution_TypeAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadAttribution_TypeAndConfidence_class_data_;
// -------------------------------------------------------------------

class RoadAttribution_ChangeTypeAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence) */ {
 public:
  inline RoadAttribution_ChangeTypeAndConfidence() : RoadAttribution_ChangeTypeAndConfidence(nullptr) {}
  ~RoadAttribution_ChangeTypeAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadAttribution_ChangeTypeAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadAttribution_ChangeTypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadAttribution_ChangeTypeAndConfidence(const RoadAttribution_ChangeTypeAndConfidence& from) : RoadAttribution_ChangeTypeAndConfidence(nullptr, from) {}
  inline RoadAttribution_ChangeTypeAndConfidence(RoadAttribution_ChangeTypeAndConfidence&& from) noexcept
      : RoadAttribution_ChangeTypeAndConfidence(nullptr, ::std::move(from)) {}
  inline RoadAttribution_ChangeTypeAndConfidence& operator=(const RoadAttribution_ChangeTypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadAttribution_ChangeTypeAndConfidence& operator=(RoadAttribution_ChangeTypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadAttribution_ChangeTypeAndConfidence& default_instance() {
    return *reinterpret_cast<const RoadAttribution_ChangeTypeAndConfidence*>(
        &_RoadAttribution_ChangeTypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(RoadAttribution_ChangeTypeAndConfidence& a, RoadAttribution_ChangeTypeAndConfidence& b) { a.Swap(&b); }
  inline void Swap(RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadAttribution_ChangeTypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadAttribution_ChangeTypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadAttribution_ChangeTypeAndConfidence& from) { RoadAttribution_ChangeTypeAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence"; }

 protected:
  explicit RoadAttribution_ChangeTypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadAttribution_ChangeTypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadAttribution_ChangeTypeAndConfidence& from);
  RoadAttribution_ChangeTypeAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadAttribution_ChangeTypeAndConfidence&& from) noexcept
      : RoadAttribution_ChangeTypeAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = RoadAttribution_ChangeTypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadAttribution_ChangeTypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type DETECTED = RoadAttribution_ChangeTypeAndConfidence_Type_DETECTED;
  static constexpr Type START = RoadAttribution_ChangeTypeAndConfidence_Type_START;
  static constexpr Type END = RoadAttribution_ChangeTypeAndConfidence_Type_END;
  static inline bool Type_IsValid(int value) {
    return RoadAttribution_ChangeTypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadAttribution_ChangeTypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadAttribution_ChangeTypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadAttribution_ChangeTypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return RoadAttribution_ChangeTypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return RoadAttribution_ChangeTypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return RoadAttribution_ChangeTypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadAttribution_ChangeTypeAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadAttribution_ChangeTypeAndConfidence_class_data_;
// -------------------------------------------------------------------

class MarkingMaterialAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence) */ {
 public:
  inline MarkingMaterialAndConfidence() : MarkingMaterialAndConfidence(nullptr) {}
  ~MarkingMaterialAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MarkingMaterialAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MarkingMaterialAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MarkingMaterialAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline MarkingMaterialAndConfidence(const MarkingMaterialAndConfidence& from) : MarkingMaterialAndConfidence(nullptr, from) {}
  inline MarkingMaterialAndConfidence(MarkingMaterialAndConfidence&& from) noexcept
      : MarkingMaterialAndConfidence(nullptr, ::std::move(from)) {}
  inline MarkingMaterialAndConfidence& operator=(const MarkingMaterialAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkingMaterialAndConfidence& operator=(MarkingMaterialAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkingMaterialAndConfidence& default_instance() {
    return *reinterpret_cast<const MarkingMaterialAndConfidence*>(
        &_MarkingMaterialAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(MarkingMaterialAndConfidence& a, MarkingMaterialAndConfidence& b) { a.Swap(&b); }
  inline void Swap(MarkingMaterialAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkingMaterialAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkingMaterialAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MarkingMaterialAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MarkingMaterialAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MarkingMaterialAndConfidence& from) { MarkingMaterialAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MarkingMaterialAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence"; }

 protected:
  explicit MarkingMaterialAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MarkingMaterialAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MarkingMaterialAndConfidence& from);
  MarkingMaterialAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MarkingMaterialAndConfidence&& from) noexcept
      : MarkingMaterialAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = MarkingMaterialAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = MarkingMaterialAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type METAL = MarkingMaterialAndConfidence_Type_METAL;
  static constexpr Type CONCRETE = MarkingMaterialAndConfidence_Type_CONCRETE;
  static constexpr Type STONE = MarkingMaterialAndConfidence_Type_STONE;
  static constexpr Type WOOD = MarkingMaterialAndConfidence_Type_WOOD;
  static constexpr Type PLASTIC = MarkingMaterialAndConfidence_Type_PLASTIC;
  static constexpr Type TRANSPARENT = MarkingMaterialAndConfidence_Type_TRANSPARENT;
  static constexpr Type VIBRATION_MARKINGS = MarkingMaterialAndConfidence_Type_VIBRATION_MARKINGS;
  static constexpr Type PAINT = MarkingMaterialAndConfidence_Type_PAINT;
  static constexpr Type ASPHALT = MarkingMaterialAndConfidence_Type_ASPHALT;
  static constexpr Type GRAVEL = MarkingMaterialAndConfidence_Type_GRAVEL;
  static constexpr Type COBBLESTONE = MarkingMaterialAndConfidence_Type_COBBLESTONE;
  static inline bool Type_IsValid(int value) {
    return MarkingMaterialAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = MarkingMaterialAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = MarkingMaterialAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = MarkingMaterialAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return MarkingMaterialAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return MarkingMaterialAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return MarkingMaterialAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MarkingMaterialAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MarkingMaterialAndConfidence_class_data_;
// -------------------------------------------------------------------

class MarkingColorAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence) */ {
 public:
  inline MarkingColorAndConfidence() : MarkingColorAndConfidence(nullptr) {}
  ~MarkingColorAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MarkingColorAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MarkingColorAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MarkingColorAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline MarkingColorAndConfidence(const MarkingColorAndConfidence& from) : MarkingColorAndConfidence(nullptr, from) {}
  inline MarkingColorAndConfidence(MarkingColorAndConfidence&& from) noexcept
      : MarkingColorAndConfidence(nullptr, ::std::move(from)) {}
  inline MarkingColorAndConfidence& operator=(const MarkingColorAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkingColorAndConfidence& operator=(MarkingColorAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkingColorAndConfidence& default_instance() {
    return *reinterpret_cast<const MarkingColorAndConfidence*>(
        &_MarkingColorAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(MarkingColorAndConfidence& a, MarkingColorAndConfidence& b) { a.Swap(&b); }
  inline void Swap(MarkingColorAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkingColorAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkingColorAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MarkingColorAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MarkingColorAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MarkingColorAndConfidence& from) { MarkingColorAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MarkingColorAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence"; }

 protected:
  explicit MarkingColorAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MarkingColorAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MarkingColorAndConfidence& from);
  MarkingColorAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MarkingColorAndConfidence&& from) noexcept
      : MarkingColorAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = MarkingColorAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = MarkingColorAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type WHITE = MarkingColorAndConfidence_Type_WHITE;
  static constexpr Type GRAY = MarkingColorAndConfidence_Type_GRAY;
  static constexpr Type GRAY_LIGHT = MarkingColorAndConfidence_Type_GRAY_LIGHT;
  static constexpr Type GRAY_DARK = MarkingColorAndConfidence_Type_GRAY_DARK;
  static constexpr Type BLACK = MarkingColorAndConfidence_Type_BLACK;
  static constexpr Type RED = MarkingColorAndConfidence_Type_RED;
  static constexpr Type YELLOW = MarkingColorAndConfidence_Type_YELLOW;
  static constexpr Type GREEN = MarkingColorAndConfidence_Type_GREEN;
  static constexpr Type CYAN = MarkingColorAndConfidence_Type_CYAN;
  static constexpr Type BLUE = MarkingColorAndConfidence_Type_BLUE;
  static constexpr Type ORANGE = MarkingColorAndConfidence_Type_ORANGE;
  static constexpr Type PINK = MarkingColorAndConfidence_Type_PINK;
  static constexpr Type PURPLE = MarkingColorAndConfidence_Type_PURPLE;
  static inline bool Type_IsValid(int value) {
    return MarkingColorAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = MarkingColorAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = MarkingColorAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = MarkingColorAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return MarkingColorAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return MarkingColorAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return MarkingColorAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MarkingColorAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MarkingColorAndConfidence_class_data_;
// -------------------------------------------------------------------

class LaneBoundaryMergeSplit_TypeAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence) */ {
 public:
  inline LaneBoundaryMergeSplit_TypeAndConfidence() : LaneBoundaryMergeSplit_TypeAndConfidence(nullptr) {}
  ~LaneBoundaryMergeSplit_TypeAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LaneBoundaryMergeSplit_TypeAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundaryMergeSplit_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundaryMergeSplit_TypeAndConfidence(const LaneBoundaryMergeSplit_TypeAndConfidence& from) : LaneBoundaryMergeSplit_TypeAndConfidence(nullptr, from) {}
  inline LaneBoundaryMergeSplit_TypeAndConfidence(LaneBoundaryMergeSplit_TypeAndConfidence&& from) noexcept
      : LaneBoundaryMergeSplit_TypeAndConfidence(nullptr, ::std::move(from)) {}
  inline LaneBoundaryMergeSplit_TypeAndConfidence& operator=(const LaneBoundaryMergeSplit_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundaryMergeSplit_TypeAndConfidence& operator=(LaneBoundaryMergeSplit_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundaryMergeSplit_TypeAndConfidence& default_instance() {
    return *reinterpret_cast<const LaneBoundaryMergeSplit_TypeAndConfidence*>(
        &_LaneBoundaryMergeSplit_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(LaneBoundaryMergeSplit_TypeAndConfidence& a, LaneBoundaryMergeSplit_TypeAndConfidence& b) { a.Swap(&b); }
  inline void Swap(LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LaneBoundaryMergeSplit_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundaryMergeSplit_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LaneBoundaryMergeSplit_TypeAndConfidence& from) { LaneBoundaryMergeSplit_TypeAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence"; }

 protected:
  explicit LaneBoundaryMergeSplit_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LaneBoundaryMergeSplit_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LaneBoundaryMergeSplit_TypeAndConfidence& from);
  LaneBoundaryMergeSplit_TypeAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LaneBoundaryMergeSplit_TypeAndConfidence&& from) noexcept
      : LaneBoundaryMergeSplit_TypeAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = LaneBoundaryMergeSplit_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = LaneBoundaryMergeSplit_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type MERGE = LaneBoundaryMergeSplit_TypeAndConfidence_Type_MERGE;
  static constexpr Type SPLIT = LaneBoundaryMergeSplit_TypeAndConfidence_Type_SPLIT;
  static inline bool Type_IsValid(int value) {
    return LaneBoundaryMergeSplit_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return LaneBoundaryMergeSplit_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return LaneBoundaryMergeSplit_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LaneBoundaryMergeSplit_TypeAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LaneBoundaryMergeSplit_TypeAndConfidence_class_data_;
// -------------------------------------------------------------------

class LaneBoundary_TypeAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence) */ {
 public:
  inline LaneBoundary_TypeAndConfidence() : LaneBoundary_TypeAndConfidence(nullptr) {}
  ~LaneBoundary_TypeAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LaneBoundary_TypeAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LaneBoundary_TypeAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundary_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundary_TypeAndConfidence(const LaneBoundary_TypeAndConfidence& from) : LaneBoundary_TypeAndConfidence(nullptr, from) {}
  inline LaneBoundary_TypeAndConfidence(LaneBoundary_TypeAndConfidence&& from) noexcept
      : LaneBoundary_TypeAndConfidence(nullptr, ::std::move(from)) {}
  inline LaneBoundary_TypeAndConfidence& operator=(const LaneBoundary_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundary_TypeAndConfidence& operator=(LaneBoundary_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundary_TypeAndConfidence& default_instance() {
    return *reinterpret_cast<const LaneBoundary_TypeAndConfidence*>(
        &_LaneBoundary_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(LaneBoundary_TypeAndConfidence& a, LaneBoundary_TypeAndConfidence& b) { a.Swap(&b); }
  inline void Swap(LaneBoundary_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundary_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundary_TypeAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LaneBoundary_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundary_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LaneBoundary_TypeAndConfidence& from) { LaneBoundary_TypeAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LaneBoundary_TypeAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence"; }

 protected:
  explicit LaneBoundary_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LaneBoundary_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LaneBoundary_TypeAndConfidence& from);
  LaneBoundary_TypeAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LaneBoundary_TypeAndConfidence&& from) noexcept
      : LaneBoundary_TypeAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = LaneBoundary_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = LaneBoundary_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type LINE = LaneBoundary_TypeAndConfidence_Type_LINE;
  static constexpr Type LINE_SINGLE = LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE;
  static constexpr Type LINE_SINGLE_SOLID = LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_SOLID;
  static constexpr Type LINE_SINGLE_DASHED = LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED;
  static constexpr Type LINE_SINGLE_DASHED_SHORT = LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED_SHORT;
  static constexpr Type LINE_SINGLE_DASHED_LONG = LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED_LONG;
  static constexpr Type LINE_DOUBLE = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE;
  static constexpr Type LINE_DOUBLE_SOLID = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID;
  static constexpr Type LINE_DOUBLE_DASHED = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED;
  static constexpr Type LINE_DOUBLE_SOLID_DASHED = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_DASHED;
  static constexpr Type LINE_DOUBLE_DASHED_SOLID = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_SOLID;
  static constexpr Type SHADED_AREA_MARKING = LaneBoundary_TypeAndConfidence_Type_SHADED_AREA_MARKING;
  static constexpr Type BLOCKS_DASHED = LaneBoundary_TypeAndConfidence_Type_BLOCKS_DASHED;
  static constexpr Type CROSSING_ALERT = LaneBoundary_TypeAndConfidence_Type_CROSSING_ALERT;
  static constexpr Type CURB = LaneBoundary_TypeAndConfidence_Type_CURB;
  static constexpr Type CURB_TRAVERSABLE = LaneBoundary_TypeAndConfidence_Type_CURB_TRAVERSABLE;
  static constexpr Type CURB_NON_TRAVERSABLE = LaneBoundary_TypeAndConfidence_Type_CURB_NON_TRAVERSABLE;
  static constexpr Type PHYSICAL_DIVIDER = LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER;
  static constexpr Type WALL = LaneBoundary_TypeAndConfidence_Type_WALL;
  static constexpr Type WALL_FLAT = LaneBoundary_TypeAndConfidence_Type_WALL_FLAT;
  static constexpr Type WALL_CURVED = LaneBoundary_TypeAndConfidence_Type_WALL_CURVED;
  static constexpr Type BARRIER = LaneBoundary_TypeAndConfidence_Type_BARRIER;
  static constexpr Type BARRIER_JERSEY = LaneBoundary_TypeAndConfidence_Type_BARRIER_JERSEY;
  static constexpr Type BARRIER_SOUND = LaneBoundary_TypeAndConfidence_Type_BARRIER_SOUND;
  static constexpr Type BARRIER_CABLE = LaneBoundary_TypeAndConfidence_Type_BARRIER_CABLE;
  static constexpr Type GUARDRAIL = LaneBoundary_TypeAndConfidence_Type_GUARDRAIL;
  static constexpr Type FENCE = LaneBoundary_TypeAndConfidence_Type_FENCE;
  static constexpr Type ROAD_EDGE = LaneBoundary_TypeAndConfidence_Type_ROAD_EDGE;
  static constexpr Type CLIFF = LaneBoundary_TypeAndConfidence_Type_CLIFF;
  static constexpr Type DITCH = LaneBoundary_TypeAndConfidence_Type_DITCH;
  static constexpr Type ASPHALT_JOINT = LaneBoundary_TypeAndConfidence_Type_ASPHALT_JOINT;
  static constexpr Type LINE_MULTIPLE = LaneBoundary_TypeAndConfidence_Type_LINE_MULTIPLE;
  static constexpr Type LINE_MULTIPLE_ALL_DASHED = LaneBoundary_TypeAndConfidence_Type_LINE_MULTIPLE_ALL_DASHED;
  static constexpr Type LINE_MULTIPLE_ANY_SOLID = LaneBoundary_TypeAndConfidence_Type_LINE_MULTIPLE_ANY_SOLID;
  static constexpr Type PHYSICAL_DIVIDER_CONTINUOUS = LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER_CONTINUOUS;
  static constexpr Type PHYSICAL_DIVIDER_DISCONTINUOUS = LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER_DISCONTINUOUS;
  static constexpr Type LINE_DOUBLE_DASHED_OR_DOUBLE_SOLID_DASHED = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_OR_DOUBLE_SOLID_DASHED;
  static constexpr Type LINE_DOUBLE_DASHED_OR_DOUBLE_DASHED_SOLID = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_OR_DOUBLE_DASHED_SOLID;
  static constexpr Type LINE_DOUBLE_SOLID_OR_DOUBLE_SOLID_DASHED = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_OR_DOUBLE_SOLID_DASHED;
  static constexpr Type LINE_DOUBLE_SOLID_OR_DOUBLE_DASHED_SOLID = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_OR_DOUBLE_DASHED_SOLID;
  static inline bool Type_IsValid(int value) {
    return LaneBoundary_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = LaneBoundary_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = LaneBoundary_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = LaneBoundary_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return LaneBoundary_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return LaneBoundary_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return LaneBoundary_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LaneBoundary_TypeAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LaneBoundary_TypeAndConfidence_class_data_;
// -------------------------------------------------------------------

class LaneBoundary_MarkingOffsets_TypeAndOffset final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset) */ {
 public:
  inline LaneBoundary_MarkingOffsets_TypeAndOffset() : LaneBoundary_MarkingOffsets_TypeAndOffset(nullptr) {}
  ~LaneBoundary_MarkingOffsets_TypeAndOffset() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LaneBoundary_MarkingOffsets_TypeAndOffset* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LaneBoundary_MarkingOffsets_TypeAndOffset));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundary_MarkingOffsets_TypeAndOffset(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundary_MarkingOffsets_TypeAndOffset(const LaneBoundary_MarkingOffsets_TypeAndOffset& from) : LaneBoundary_MarkingOffsets_TypeAndOffset(nullptr, from) {}
  inline LaneBoundary_MarkingOffsets_TypeAndOffset(LaneBoundary_MarkingOffsets_TypeAndOffset&& from) noexcept
      : LaneBoundary_MarkingOffsets_TypeAndOffset(nullptr, ::std::move(from)) {}
  inline LaneBoundary_MarkingOffsets_TypeAndOffset& operator=(const LaneBoundary_MarkingOffsets_TypeAndOffset& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundary_MarkingOffsets_TypeAndOffset& operator=(LaneBoundary_MarkingOffsets_TypeAndOffset&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundary_MarkingOffsets_TypeAndOffset& default_instance() {
    return *reinterpret_cast<const LaneBoundary_MarkingOffsets_TypeAndOffset*>(
        &_LaneBoundary_MarkingOffsets_TypeAndOffset_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(LaneBoundary_MarkingOffsets_TypeAndOffset& a, LaneBoundary_MarkingOffsets_TypeAndOffset& b) { a.Swap(&b); }
  inline void Swap(LaneBoundary_MarkingOffsets_TypeAndOffset* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundary_MarkingOffsets_TypeAndOffset* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundary_MarkingOffsets_TypeAndOffset* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LaneBoundary_MarkingOffsets_TypeAndOffset>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundary_MarkingOffsets_TypeAndOffset& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LaneBoundary_MarkingOffsets_TypeAndOffset& from) { LaneBoundary_MarkingOffsets_TypeAndOffset::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LaneBoundary_MarkingOffsets_TypeAndOffset* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset"; }

 protected:
  explicit LaneBoundary_MarkingOffsets_TypeAndOffset(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LaneBoundary_MarkingOffsets_TypeAndOffset(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LaneBoundary_MarkingOffsets_TypeAndOffset& from);
  LaneBoundary_MarkingOffsets_TypeAndOffset(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LaneBoundary_MarkingOffsets_TypeAndOffset&& from) noexcept
      : LaneBoundary_MarkingOffsets_TypeAndOffset(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = LaneBoundary_MarkingOffsets_TypeAndOffset_Type;
  static constexpr Type UNKNOWN_TYPE = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_UNKNOWN_TYPE;
  static constexpr Type START_OF_MARKING = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_START_OF_MARKING;
  static constexpr Type END_OF_MARKING = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_END_OF_MARKING;
  static constexpr Type ON_MARKING = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_ON_MARKING;
  static constexpr Type NO_MARKING = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_NO_MARKING;
  static inline bool Type_IsValid(int value) {
    return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MIN;
  static constexpr Type Type_MAX = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kOffsetAndAccuracyFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy offset_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_offset_and_accuracy() const;
  void clear_offset_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& offset_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_offset_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_offset_and_accuracy();
  void set_allocated_offset_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_offset_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_offset_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_offset_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_offset_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LaneBoundary_MarkingOffsets_TypeAndOffset& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE offset_and_accuracy_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LaneBoundary_MarkingOffsets_TypeAndOffset_class_data_;
// -------------------------------------------------------------------

class LaneBoundary_DashStatistics final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics) */ {
 public:
  inline LaneBoundary_DashStatistics() : LaneBoundary_DashStatistics(nullptr) {}
  ~LaneBoundary_DashStatistics() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LaneBoundary_DashStatistics* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LaneBoundary_DashStatistics));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundary_DashStatistics(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundary_DashStatistics(const LaneBoundary_DashStatistics& from) : LaneBoundary_DashStatistics(nullptr, from) {}
  inline LaneBoundary_DashStatistics(LaneBoundary_DashStatistics&& from) noexcept
      : LaneBoundary_DashStatistics(nullptr, ::std::move(from)) {}
  inline LaneBoundary_DashStatistics& operator=(const LaneBoundary_DashStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundary_DashStatistics& operator=(LaneBoundary_DashStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundary_DashStatistics& default_instance() {
    return *reinterpret_cast<const LaneBoundary_DashStatistics*>(
        &_LaneBoundary_DashStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(LaneBoundary_DashStatistics& a, LaneBoundary_DashStatistics& b) { a.Swap(&b); }
  inline void Swap(LaneBoundary_DashStatistics* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundary_DashStatistics* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundary_DashStatistics* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LaneBoundary_DashStatistics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundary_DashStatistics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LaneBoundary_DashStatistics& from) { LaneBoundary_DashStatistics::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LaneBoundary_DashStatistics* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics"; }

 protected:
  explicit LaneBoundary_DashStatistics(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LaneBoundary_DashStatistics(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LaneBoundary_DashStatistics& from);
  LaneBoundary_DashStatistics(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LaneBoundary_DashStatistics&& from) noexcept
      : LaneBoundary_DashStatistics(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLengthAndAccuracyFieldNumber = 2,
    kDistanceAndAccuracyFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy length_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_length_and_accuracy() const;
  void clear_length_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& length_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_length_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_length_and_accuracy();
  void set_allocated_length_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_length_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_length_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_length_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_length_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy distance_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_distance_and_accuracy() const;
  void clear_distance_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& distance_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_distance_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_distance_and_accuracy();
  void set_allocated_distance_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_distance_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_distance_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_distance_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_distance_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LaneBoundary_DashStatistics& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE length_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE distance_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LaneBoundary_DashStatistics_class_data_;
// -------------------------------------------------------------------

class InclinationAndCurvature final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature) */ {
 public:
  inline InclinationAndCurvature() : InclinationAndCurvature(nullptr) {}
  ~InclinationAndCurvature() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InclinationAndCurvature* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InclinationAndCurvature));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InclinationAndCurvature(::google::protobuf::internal::ConstantInitialized);

  inline InclinationAndCurvature(const InclinationAndCurvature& from) : InclinationAndCurvature(nullptr, from) {}
  inline InclinationAndCurvature(InclinationAndCurvature&& from) noexcept
      : InclinationAndCurvature(nullptr, ::std::move(from)) {}
  inline InclinationAndCurvature& operator=(const InclinationAndCurvature& from) {
    CopyFrom(from);
    return *this;
  }
  inline InclinationAndCurvature& operator=(InclinationAndCurvature&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InclinationAndCurvature& default_instance() {
    return *reinterpret_cast<const InclinationAndCurvature*>(
        &_InclinationAndCurvature_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(InclinationAndCurvature& a, InclinationAndCurvature& b) { a.Swap(&b); }
  inline void Swap(InclinationAndCurvature* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InclinationAndCurvature* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InclinationAndCurvature* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InclinationAndCurvature>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InclinationAndCurvature& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InclinationAndCurvature& from) { InclinationAndCurvature::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InclinationAndCurvature* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.InclinationAndCurvature"; }

 protected:
  explicit InclinationAndCurvature(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InclinationAndCurvature(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InclinationAndCurvature& from);
  InclinationAndCurvature(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InclinationAndCurvature&& from) noexcept
      : InclinationAndCurvature(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLongitudinalInclinationAndAccuracyFieldNumber = 1,
    kLateralInclinationAndAccuracyFieldNumber = 2,
    kHorizontalCurvatureAndAccuracyFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy longitudinal_inclination_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_longitudinal_inclination_and_accuracy() const;
  void clear_longitudinal_inclination_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& longitudinal_inclination_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_longitudinal_inclination_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_longitudinal_inclination_and_accuracy();
  void set_allocated_longitudinal_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_longitudinal_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_longitudinal_inclination_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_longitudinal_inclination_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_longitudinal_inclination_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy lateral_inclination_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_lateral_inclination_and_accuracy() const;
  void clear_lateral_inclination_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& lateral_inclination_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_lateral_inclination_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_lateral_inclination_and_accuracy();
  void set_allocated_lateral_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lateral_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_lateral_inclination_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_lateral_inclination_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_lateral_inclination_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy horizontal_curvature_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_horizontal_curvature_and_accuracy() const;
  void clear_horizontal_curvature_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& horizontal_curvature_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_horizontal_curvature_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_horizontal_curvature_and_accuracy();
  void set_allocated_horizontal_curvature_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_horizontal_curvature_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_horizontal_curvature_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_horizontal_curvature_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_horizontal_curvature_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InclinationAndCurvature& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE longitudinal_inclination_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE lateral_inclination_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE horizontal_curvature_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InclinationAndCurvature_class_data_;
// -------------------------------------------------------------------

class Road final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.Road) */ {
 public:
  inline Road() : Road(nullptr) {}
  ~Road() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Road* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Road));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Road(::google::protobuf::internal::ConstantInitialized);

  inline Road(const Road& from) : Road(nullptr, from) {}
  inline Road(Road&& from) noexcept
      : Road(nullptr, ::std::move(from)) {}
  inline Road& operator=(const Road& from) {
    CopyFrom(from);
    return *this;
  }
  inline Road& operator=(Road&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Road& default_instance() {
    return *reinterpret_cast<const Road*>(
        &_Road_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Road& a, Road& b) { a.Swap(&b); }
  inline void Swap(Road* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Road* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Road* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Road>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Road& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Road& from) { Road::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Road* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.Road"; }

 protected:
  explicit Road(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Road(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Road& from);
  Road(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Road&& from) noexcept
      : Road(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kWidthAndAccuracyFieldNumber = 2,
    kInclinationAndCurvatureFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 2;
  bool has_width_and_accuracy() const;
  void clear_width_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& width_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_width_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_width_and_accuracy();
  void set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_width_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_width_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_width_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 3;
  bool has_inclination_and_curvature() const;
  void clear_inclination_and_curvature() ;
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& inclination_and_curvature() const;
  [[nodiscard]] ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE release_inclination_and_curvature();
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NONNULL mutable_inclination_and_curvature();
  void set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE unsafe_arena_release_inclination_and_curvature();

  private:
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& _internal_inclination_and_curvature() const;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NONNULL _internal_mutable_inclination_and_curvature();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.Road)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Road& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE width_and_accuracy_;
    ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE inclination_and_curvature_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Road_class_data_;
// -------------------------------------------------------------------

class LaneBoundary_MarkingOffsets final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets) */ {
 public:
  inline LaneBoundary_MarkingOffsets() : LaneBoundary_MarkingOffsets(nullptr) {}
  ~LaneBoundary_MarkingOffsets() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LaneBoundary_MarkingOffsets* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LaneBoundary_MarkingOffsets));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundary_MarkingOffsets(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundary_MarkingOffsets(const LaneBoundary_MarkingOffsets& from) : LaneBoundary_MarkingOffsets(nullptr, from) {}
  inline LaneBoundary_MarkingOffsets(LaneBoundary_MarkingOffsets&& from) noexcept
      : LaneBoundary_MarkingOffsets(nullptr, ::std::move(from)) {}
  inline LaneBoundary_MarkingOffsets& operator=(const LaneBoundary_MarkingOffsets& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundary_MarkingOffsets& operator=(LaneBoundary_MarkingOffsets&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundary_MarkingOffsets& default_instance() {
    return *reinterpret_cast<const LaneBoundary_MarkingOffsets*>(
        &_LaneBoundary_MarkingOffsets_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(LaneBoundary_MarkingOffsets& a, LaneBoundary_MarkingOffsets& b) { a.Swap(&b); }
  inline void Swap(LaneBoundary_MarkingOffsets* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundary_MarkingOffsets* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundary_MarkingOffsets* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LaneBoundary_MarkingOffsets>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundary_MarkingOffsets& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LaneBoundary_MarkingOffsets& from) { LaneBoundary_MarkingOffsets::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LaneBoundary_MarkingOffsets* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets"; }

 protected:
  explicit LaneBoundary_MarkingOffsets(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LaneBoundary_MarkingOffsets(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LaneBoundary_MarkingOffsets& from);
  LaneBoundary_MarkingOffsets(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LaneBoundary_MarkingOffsets&& from) noexcept
      : LaneBoundary_MarkingOffsets(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeAndOffset = LaneBoundary_MarkingOffsets_TypeAndOffset;

  // accessors -------------------------------------------------------
  enum : int {
    kTypeAndOffsetFieldNumber = 2,
  };
  // repeated .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset type_and_offset = 2;
  int type_and_offset_size() const;
  private:
  int _internal_type_and_offset_size() const;

  public:
  void clear_type_and_offset() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* PROTOBUF_NONNULL mutable_type_and_offset(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>* PROTOBUF_NONNULL mutable_type_and_offset();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>& _internal_type_and_offset() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>* PROTOBUF_NONNULL _internal_mutable_type_and_offset();
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset& type_and_offset(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* PROTOBUF_NONNULL add_type_and_offset();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>& type_and_offset() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LaneBoundary_MarkingOffsets& from_msg);
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset > type_and_offset_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LaneBoundary_MarkingOffsets_class_data_;
// -------------------------------------------------------------------

class Lane final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.Lane) */ {
 public:
  inline Lane() : Lane(nullptr) {}
  ~Lane() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Lane* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Lane));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Lane(::google::protobuf::internal::ConstantInitialized);

  inline Lane(const Lane& from) : Lane(nullptr, from) {}
  inline Lane(Lane&& from) noexcept
      : Lane(nullptr, ::std::move(from)) {}
  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lane& operator=(Lane&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lane& default_instance() {
    return *reinterpret_cast<const Lane*>(
        &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Lane& a, Lane& b) { a.Swap(&b); }
  inline void Swap(Lane* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lane* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lane* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Lane>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Lane& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Lane& from) { Lane::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Lane* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.Lane"; }

 protected:
  explicit Lane(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Lane(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Lane& from);
  Lane(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Lane&& from) noexcept
      : Lane(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kRelativeLaneIdFieldNumber = 2,
    kWidthAndAccuracyFieldNumber = 3,
    kInclinationAndCurvatureFieldNumber = 4,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .google.protobuf.Int64Value relative_lane_id = 2;
  bool has_relative_lane_id() const;
  void clear_relative_lane_id() ;
  const ::google::protobuf::Int64Value& relative_lane_id() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_relative_lane_id();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_relative_lane_id();
  void set_allocated_relative_lane_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_relative_lane_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_relative_lane_id();

  private:
  const ::google::protobuf::Int64Value& _internal_relative_lane_id() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_relative_lane_id();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_width_and_accuracy() const;
  void clear_width_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& width_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_width_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_width_and_accuracy();
  void set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_width_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_width_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_width_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 4;
  bool has_inclination_and_curvature() const;
  void clear_inclination_and_curvature() ;
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& inclination_and_curvature() const;
  [[nodiscard]] ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE release_inclination_and_curvature();
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NONNULL mutable_inclination_and_curvature();
  void set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE unsafe_arena_release_inclination_and_curvature();

  private:
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& _internal_inclination_and_curvature() const;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NONNULL _internal_mutable_inclination_and_curvature();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.Lane)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Lane& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE relative_lane_id_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE width_and_accuracy_;
    ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE inclination_and_curvature_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Lane_class_data_;
// -------------------------------------------------------------------

class SurfaceAttribution final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.SurfaceAttribution) */ {
 public:
  inline SurfaceAttribution() : SurfaceAttribution(nullptr) {}
  ~SurfaceAttribution() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SurfaceAttribution* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SurfaceAttribution));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SurfaceAttribution(::google::protobuf::internal::ConstantInitialized);

  inline SurfaceAttribution(const SurfaceAttribution& from) : SurfaceAttribution(nullptr, from) {}
  inline SurfaceAttribution(SurfaceAttribution&& from) noexcept
      : SurfaceAttribution(nullptr, ::std::move(from)) {}
  inline SurfaceAttribution& operator=(const SurfaceAttribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline SurfaceAttribution& operator=(SurfaceAttribution&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SurfaceAttribution& default_instance() {
    return *reinterpret_cast<const SurfaceAttribution*>(
        &_SurfaceAttribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(SurfaceAttribution& a, SurfaceAttribution& b) { a.Swap(&b); }
  inline void Swap(SurfaceAttribution* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SurfaceAttribution* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SurfaceAttribution* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SurfaceAttribution>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SurfaceAttribution& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SurfaceAttribution& from) { SurfaceAttribution::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SurfaceAttribution* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.SurfaceAttribution"; }

 protected:
  explicit SurfaceAttribution(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SurfaceAttribution(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SurfaceAttribution& from);
  SurfaceAttribution(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SurfaceAttribution&& from) noexcept
      : SurfaceAttribution(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaterialAndConfidenceFieldNumber = 4,
    kEnvelopeFieldNumber = 1,
    kPositionAndAccuracyFieldNumber = 2,
    kInclinationAndCurvatureFieldNumber = 3,
    kRoadRoughnessAndAccuracyFieldNumber = 5,
  };
  // repeated .sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence material_and_confidence = 4;
  int material_and_confidence_size() const;
  private:
  int _internal_material_and_confidence_size() const;

  public:
  void clear_material_and_confidence() ;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* PROTOBUF_NONNULL mutable_material_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>* PROTOBUF_NONNULL mutable_material_and_confidence();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>& _internal_material_and_confidence() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>* PROTOBUF_NONNULL _internal_mutable_material_and_confidence();
  public:
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence& material_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* PROTOBUF_NONNULL add_material_and_confidence();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>& material_and_confidence() const;
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL _internal_mutable_position_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 3;
  bool has_inclination_and_curvature() const;
  void clear_inclination_and_curvature() ;
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& inclination_and_curvature() const;
  [[nodiscard]] ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE release_inclination_and_curvature();
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NONNULL mutable_inclination_and_curvature();
  void set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE unsafe_arena_release_inclination_and_curvature();

  private:
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& _internal_inclination_and_curvature() const;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NONNULL _internal_mutable_inclination_and_curvature();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy road_roughness_and_accuracy = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_road_roughness_and_accuracy() const;
  void clear_road_roughness_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& road_roughness_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_road_roughness_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_road_roughness_and_accuracy();
  void set_allocated_road_roughness_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_road_roughness_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_road_roughness_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_road_roughness_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_road_roughness_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.SurfaceAttribution)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   5, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SurfaceAttribution& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence > material_and_confidence_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE position_and_accuracy_;
    ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE inclination_and_curvature_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE road_roughness_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SurfaceAttribution_class_data_;
// -------------------------------------------------------------------

class RoadAttribution final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.RoadAttribution) */ {
 public:
  inline RoadAttribution() : RoadAttribution(nullptr) {}
  ~RoadAttribution() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadAttribution* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadAttribution));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadAttribution(::google::protobuf::internal::ConstantInitialized);

  inline RoadAttribution(const RoadAttribution& from) : RoadAttribution(nullptr, from) {}
  inline RoadAttribution(RoadAttribution&& from) noexcept
      : RoadAttribution(nullptr, ::std::move(from)) {}
  inline RoadAttribution& operator=(const RoadAttribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadAttribution& operator=(RoadAttribution&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadAttribution& default_instance() {
    return *reinterpret_cast<const RoadAttribution*>(
        &_RoadAttribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(RoadAttribution& a, RoadAttribution& b) { a.Swap(&b); }
  inline void Swap(RoadAttribution* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadAttribution* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadAttribution* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadAttribution>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadAttribution& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadAttribution& from) { RoadAttribution::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadAttribution* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.RoadAttribution"; }

 protected:
  explicit RoadAttribution(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadAttribution(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadAttribution& from);
  RoadAttribution(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadAttribution&& from) noexcept
      : RoadAttribution(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeAndConfidence = RoadAttribution_TypeAndConfidence;
  using ChangeTypeAndConfidence = RoadAttribution_ChangeTypeAndConfidence;

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kPositionAndAccuracyFieldNumber = 3,
    kTypeAndConfidenceFieldNumber = 4,
    kChangeTypeAndConfidenceFieldNumber = 5,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 3;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL _internal_mutable_position_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence type_and_confidence = 4;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence& type_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NULLABLE release_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NONNULL mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NONNULL _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence change_type_and_confidence = 5;
  bool has_change_type_and_confidence() const;
  void clear_change_type_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence& change_type_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NULLABLE release_change_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NONNULL mutable_change_type_and_confidence();
  void set_allocated_change_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_change_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_change_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence& _internal_change_type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NONNULL _internal_mutable_change_type_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.RoadAttribution)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   5, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadAttribution& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE detection_status_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE position_and_accuracy_;
    ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NULLABLE type_and_confidence_;
    ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NULLABLE change_type_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadAttribution_class_data_;
// -------------------------------------------------------------------

class LaneCountAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence) */ {
 public:
  inline LaneCountAndConfidence() : LaneCountAndConfidence(nullptr) {}
  ~LaneCountAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LaneCountAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LaneCountAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LaneCountAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline LaneCountAndConfidence(const LaneCountAndConfidence& from) : LaneCountAndConfidence(nullptr, from) {}
  inline LaneCountAndConfidence(LaneCountAndConfidence&& from) noexcept
      : LaneCountAndConfidence(nullptr, ::std::move(from)) {}
  inline LaneCountAndConfidence& operator=(const LaneCountAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneCountAndConfidence& operator=(LaneCountAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneCountAndConfidence& default_instance() {
    return *reinterpret_cast<const LaneCountAndConfidence*>(
        &_LaneCountAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(LaneCountAndConfidence& a, LaneCountAndConfidence& b) { a.Swap(&b); }
  inline void Swap(LaneCountAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneCountAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneCountAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LaneCountAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneCountAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LaneCountAndConfidence& from) { LaneCountAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LaneCountAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence"; }

 protected:
  explicit LaneCountAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LaneCountAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LaneCountAndConfidence& from);
  LaneCountAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LaneCountAndConfidence&& from) noexcept
      : LaneCountAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = LaneCountAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = LaneCountAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type TOTAL = LaneCountAndConfidence_Type_TOTAL;
  static constexpr Type LEFT_INCLUDING_EGO_LANE = LaneCountAndConfidence_Type_LEFT_INCLUDING_EGO_LANE;
  static constexpr Type RIGHT = LaneCountAndConfidence_Type_RIGHT;
  static inline bool Type_IsValid(int value) {
    return LaneCountAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = LaneCountAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = LaneCountAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = LaneCountAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return LaneCountAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return LaneCountAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return LaneCountAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kPositionAndAccuracyFieldNumber = 2,
    kCountAndConfidenceFieldNumber = 4,
    kTypeFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL _internal_mutable_position_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.CountAndConfidence count_and_confidence = 4;
  bool has_count_and_confidence() const;
  void clear_count_and_confidence() ;
  const ::sensoris::protobuf::types::base::CountAndConfidence& count_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE release_count_and_confidence();
  ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NONNULL mutable_count_and_confidence();
  void set_allocated_count_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_count_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_count_and_confidence();

  private:
  const ::sensoris::protobuf::types::base::CountAndConfidence& _internal_count_and_confidence() const;
  ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NONNULL _internal_mutable_count_and_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.Type type = 3;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LaneCountAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE position_and_accuracy_;
    ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE count_and_confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LaneCountAndConfidence_class_data_;
// -------------------------------------------------------------------

class LaneBoundaryMergeSplit final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit) */ {
 public:
  inline LaneBoundaryMergeSplit() : LaneBoundaryMergeSplit(nullptr) {}
  ~LaneBoundaryMergeSplit() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LaneBoundaryMergeSplit* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LaneBoundaryMergeSplit));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundaryMergeSplit(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundaryMergeSplit(const LaneBoundaryMergeSplit& from) : LaneBoundaryMergeSplit(nullptr, from) {}
  inline LaneBoundaryMergeSplit(LaneBoundaryMergeSplit&& from) noexcept
      : LaneBoundaryMergeSplit(nullptr, ::std::move(from)) {}
  inline LaneBoundaryMergeSplit& operator=(const LaneBoundaryMergeSplit& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundaryMergeSplit& operator=(LaneBoundaryMergeSplit&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundaryMergeSplit& default_instance() {
    return *reinterpret_cast<const LaneBoundaryMergeSplit*>(
        &_LaneBoundaryMergeSplit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(LaneBoundaryMergeSplit& a, LaneBoundaryMergeSplit& b) { a.Swap(&b); }
  inline void Swap(LaneBoundaryMergeSplit* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundaryMergeSplit* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundaryMergeSplit* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LaneBoundaryMergeSplit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundaryMergeSplit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LaneBoundaryMergeSplit& from) { LaneBoundaryMergeSplit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LaneBoundaryMergeSplit* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit"; }

 protected:
  explicit LaneBoundaryMergeSplit(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LaneBoundaryMergeSplit(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LaneBoundaryMergeSplit& from);
  LaneBoundaryMergeSplit(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LaneBoundaryMergeSplit&& from) noexcept
      : LaneBoundaryMergeSplit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeAndConfidence = LaneBoundaryMergeSplit_TypeAndConfidence;

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kExistenceConfidenceFieldNumber = 2,
    kDetectionStatusFieldNumber = 3,
    kTypeAndConfidenceFieldNumber = 4,
    kPositionAndAccuracyFieldNumber = 5,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  bool has_existence_confidence() const;
  void clear_existence_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_existence_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_existence_confidence();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence type_and_confidence = 4;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence& type_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NULLABLE release_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NONNULL mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NONNULL _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 5;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL _internal_mutable_position_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   5, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LaneBoundaryMergeSplit& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE existence_confidence_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE detection_status_;
    ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NULLABLE type_and_confidence_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE position_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LaneBoundaryMergeSplit_class_data_;
// -------------------------------------------------------------------

class LaneBoundary final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary) */ {
 public:
  inline LaneBoundary() : LaneBoundary(nullptr) {}
  ~LaneBoundary() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LaneBoundary* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LaneBoundary));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundary(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundary(const LaneBoundary& from) : LaneBoundary(nullptr, from) {}
  inline LaneBoundary(LaneBoundary&& from) noexcept
      : LaneBoundary(nullptr, ::std::move(from)) {}
  inline LaneBoundary& operator=(const LaneBoundary& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundary& operator=(LaneBoundary&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundary& default_instance() {
    return *reinterpret_cast<const LaneBoundary*>(
        &_LaneBoundary_default_instance_);
  }
  enum GeometryCase {
    kPolylineAndAccuracy = 9,
    GEOMETRY_NOT_SET = 0,
  };
  enum MarkingsCase {
    kDashStatistics = 13,
    kMarkingOffsets = 14,
    MARKINGS_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(LaneBoundary& a, LaneBoundary& b) { a.Swap(&b); }
  inline void Swap(LaneBoundary* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundary* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundary* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LaneBoundary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LaneBoundary& from) { LaneBoundary::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LaneBoundary* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.LaneBoundary"; }

 protected:
  explicit LaneBoundary(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LaneBoundary(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LaneBoundary& from);
  LaneBoundary(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LaneBoundary&& from) noexcept
      : LaneBoundary(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeAndConfidence = LaneBoundary_TypeAndConfidence;
  using DashStatistics = LaneBoundary_DashStatistics;
  using MarkingOffsets = LaneBoundary_MarkingOffsets;
  using PositionReference = LaneBoundary_PositionReference;
  static constexpr PositionReference UNKNOWN_POSITION_REFERENCE = LaneBoundary_PositionReference_UNKNOWN_POSITION_REFERENCE;
  static constexpr PositionReference LEFT_MARKING_BOUNDARY = LaneBoundary_PositionReference_LEFT_MARKING_BOUNDARY;
  static constexpr PositionReference CENTER_LINE = LaneBoundary_PositionReference_CENTER_LINE;
  static constexpr PositionReference RIGHT_MARKING_BOUNDARY = LaneBoundary_PositionReference_RIGHT_MARKING_BOUNDARY;
  static inline bool PositionReference_IsValid(int value) {
    return LaneBoundary_PositionReference_IsValid(value);
  }
  static constexpr PositionReference PositionReference_MIN = LaneBoundary_PositionReference_PositionReference_MIN;
  static constexpr PositionReference PositionReference_MAX = LaneBoundary_PositionReference_PositionReference_MAX;
  static constexpr int PositionReference_ARRAYSIZE = LaneBoundary_PositionReference_PositionReference_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PositionReference_descriptor() {
    return LaneBoundary_PositionReference_descriptor();
  }
  template <typename T>
  static inline const ::std::string& PositionReference_Name(T value) {
    return LaneBoundary_PositionReference_Name(value);
  }
  static inline bool PositionReference_Parse(
      ::absl::string_view name, PositionReference* PROTOBUF_NONNULL value) {
    return LaneBoundary_PositionReference_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kLaneBoundaryIdFieldNumber = 2,
    kExistenceConfidenceFieldNumber = 3,
    kDetectionStatusFieldNumber = 4,
    kTypeAndConfidenceFieldNumber = 5,
    kMaterialAndConfidenceFieldNumber = 6,
    kColorAndConfidenceFieldNumber = 7,
    kWidthAndAccuracyFieldNumber = 10,
    kHeightAndAccuracyFieldNumber = 11,
    kDistanceBetweenDoubleAndAccuracyFieldNumber = 12,
    kPositionReferenceFieldNumber = 8,
    kPolylineAndAccuracyFieldNumber = 9,
    kDashStatisticsFieldNumber = 13,
    kMarkingOffsetsFieldNumber = 14,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .google.protobuf.Int64Value lane_boundary_id = 2;
  bool has_lane_boundary_id() const;
  void clear_lane_boundary_id() ;
  const ::google::protobuf::Int64Value& lane_boundary_id() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_lane_boundary_id();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_lane_boundary_id();
  void set_allocated_lane_boundary_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lane_boundary_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_lane_boundary_id();

  private:
  const ::google::protobuf::Int64Value& _internal_lane_boundary_id() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_lane_boundary_id();

  public:
  // .sensoris.protobuf.types.base.Confidence existence_confidence = 3;
  bool has_existence_confidence() const;
  void clear_existence_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_existence_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_existence_confidence();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 4;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence type_and_confidence = 5;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence& type_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NULLABLE release_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NONNULL mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NONNULL _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence material_and_confidence = 6;
  bool has_material_and_confidence() const;
  void clear_material_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& material_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NULLABLE release_material_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NONNULL mutable_material_and_confidence();
  void set_allocated_material_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_material_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_material_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& _internal_material_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NONNULL _internal_mutable_material_and_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence color_and_confidence = 7;
  bool has_color_and_confidence() const;
  void clear_color_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& color_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NULLABLE release_color_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NONNULL mutable_color_and_confidence();
  void set_allocated_color_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_color_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_color_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& _internal_color_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NONNULL _internal_mutable_color_and_confidence();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 10 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_width_and_accuracy() const;
  void clear_width_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& width_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_width_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_width_and_accuracy();
  void set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_width_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_width_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_width_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy height_and_accuracy = 11 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_height_and_accuracy() const;
  void clear_height_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& height_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_height_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_height_and_accuracy();
  void set_allocated_height_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_height_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_height_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_height_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_height_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy distance_between_double_and_accuracy = 12 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_distance_between_double_and_accuracy() const;
  void clear_distance_between_double_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& distance_between_double_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_distance_between_double_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_distance_between_double_and_accuracy();
  void set_allocated_distance_between_double_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_distance_between_double_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_distance_between_double_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_distance_between_double_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_distance_between_double_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.PositionReference position_reference = 8;
  void clear_position_reference() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference position_reference() const;
  void set_position_reference(::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference value);

  private:
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference _internal_position_reference() const;
  void _internal_set_position_reference(::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference value);

  public:
  // .sensoris.protobuf.types.spatial.PolylineAndAccuracy polyline_and_accuracy = 9;
  bool has_polyline_and_accuracy() const;
  private:
  bool _internal_has_polyline_and_accuracy() const;

  public:
  void clear_polyline_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& polyline_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE release_polyline_and_accuracy();
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NONNULL mutable_polyline_and_accuracy();
  void set_allocated_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_polyline_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& _internal_polyline_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NONNULL _internal_mutable_polyline_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics dash_statistics = 13;
  bool has_dash_statistics() const;
  private:
  bool _internal_has_dash_statistics() const;

  public:
  void clear_dash_statistics() ;
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics& dash_statistics() const;
  [[nodiscard]] ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* PROTOBUF_NULLABLE release_dash_statistics();
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* PROTOBUF_NONNULL mutable_dash_statistics();
  void set_allocated_dash_statistics(::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dash_statistics(::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* PROTOBUF_NULLABLE unsafe_arena_release_dash_statistics();

  private:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics& _internal_dash_statistics() const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* PROTOBUF_NONNULL _internal_mutable_dash_statistics();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets marking_offsets = 14;
  bool has_marking_offsets() const;
  private:
  bool _internal_has_marking_offsets() const;

  public:
  void clear_marking_offsets() ;
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets& marking_offsets() const;
  [[nodiscard]] ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* PROTOBUF_NULLABLE release_marking_offsets();
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* PROTOBUF_NONNULL mutable_marking_offsets();
  void set_allocated_marking_offsets(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_marking_offsets(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* PROTOBUF_NULLABLE unsafe_arena_release_marking_offsets();

  private:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets& _internal_marking_offsets() const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* PROTOBUF_NONNULL _internal_mutable_marking_offsets();

  public:
  void clear_geometry();
  GeometryCase geometry_case() const;
  void clear_markings();
  MarkingsCase markings_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary)
 private:
  class _Internal;
  void set_has_polyline_and_accuracy();
  void set_has_dash_statistics();
  void set_has_marking_offsets();
  inline bool has_geometry() const;
  inline void clear_has_geometry();
  inline bool has_markings() const;
  inline void clear_has_markings();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 14,
                                   13, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LaneBoundary& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE lane_boundary_id_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE existence_confidence_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE detection_status_;
    ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NULLABLE type_and_confidence_;
    ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NULLABLE material_and_confidence_;
    ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NULLABLE color_and_confidence_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE width_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE height_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE distance_between_double_and_accuracy_;
    int position_reference_;
    union GeometryUnion {
      constexpr GeometryUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE polyline_and_accuracy_;
    } geometry_;
    union MarkingsUnion {
      constexpr MarkingsUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* PROTOBUF_NULLABLE dash_statistics_;
      ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* PROTOBUF_NULLABLE marking_offsets_;
    } markings_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LaneBoundary_class_data_;
// -------------------------------------------------------------------

class SurfaceMarking final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.SurfaceMarking) */ {
 public:
  inline SurfaceMarking() : SurfaceMarking(nullptr) {}
  ~SurfaceMarking() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SurfaceMarking* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SurfaceMarking));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SurfaceMarking(::google::protobuf::internal::ConstantInitialized);

  inline SurfaceMarking(const SurfaceMarking& from) : SurfaceMarking(nullptr, from) {}
  inline SurfaceMarking(SurfaceMarking&& from) noexcept
      : SurfaceMarking(nullptr, ::std::move(from)) {}
  inline SurfaceMarking& operator=(const SurfaceMarking& from) {
    CopyFrom(from);
    return *this;
  }
  inline SurfaceMarking& operator=(SurfaceMarking&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SurfaceMarking& default_instance() {
    return *reinterpret_cast<const SurfaceMarking*>(
        &_SurfaceMarking_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SurfaceMarking& a, SurfaceMarking& b) { a.Swap(&b); }
  inline void Swap(SurfaceMarking* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SurfaceMarking* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SurfaceMarking* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SurfaceMarking>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SurfaceMarking& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SurfaceMarking& from) { SurfaceMarking::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SurfaceMarking* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.SurfaceMarking"; }

 protected:
  explicit SurfaceMarking(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SurfaceMarking(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SurfaceMarking& from);
  SurfaceMarking(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SurfaceMarking&& from) noexcept
      : SurfaceMarking(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeAndConfidence = SurfaceMarking_TypeAndConfidence;

  // accessors -------------------------------------------------------
  enum : int {
    kColorAndConfidenceFieldNumber = 6,
    kMaterialAndConfidenceFieldNumber = 7,
    kEnvelopeFieldNumber = 1,
    kExistenceConfidenceFieldNumber = 2,
    kDetectionStatusFieldNumber = 3,
    kTypeAndConfidenceFieldNumber = 4,
    kTextFieldNumber = 5,
    kRectangularBoxAndAccuracyFieldNumber = 8,
  };
  // repeated .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence color_and_confidence = 6;
  int color_and_confidence_size() const;
  private:
  int _internal_color_and_confidence_size() const;

  public:
  void clear_color_and_confidence() ;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NONNULL mutable_color_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>* PROTOBUF_NONNULL mutable_color_and_confidence();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>& _internal_color_and_confidence() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>* PROTOBUF_NONNULL _internal_mutable_color_and_confidence();
  public:
  const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& color_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NONNULL add_color_and_confidence();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>& color_and_confidence() const;
  // repeated .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence material_and_confidence = 7;
  int material_and_confidence_size() const;
  private:
  int _internal_material_and_confidence_size() const;

  public:
  void clear_material_and_confidence() ;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NONNULL mutable_material_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>* PROTOBUF_NONNULL mutable_material_and_confidence();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>& _internal_material_and_confidence() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>* PROTOBUF_NONNULL _internal_mutable_material_and_confidence();
  public:
  const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& material_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NONNULL add_material_and_confidence();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>& material_and_confidence() const;
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  bool has_existence_confidence() const;
  void clear_existence_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_existence_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_existence_confidence();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence type_and_confidence = 4;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence& type_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NULLABLE release_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NONNULL mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NONNULL _internal_mutable_type_and_confidence();

  public:
  // .google.protobuf.StringValue text = 5;
  bool has_text() const;
  void clear_text() ;
  const ::google::protobuf::StringValue& text() const;
  [[nodiscard]] ::google::protobuf::StringValue* PROTOBUF_NULLABLE release_text();
  ::google::protobuf::StringValue* PROTOBUF_NONNULL mutable_text();
  void set_allocated_text(::google::protobuf::StringValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_text(::google::protobuf::StringValue* PROTOBUF_NULLABLE value);
  ::google::protobuf::StringValue* PROTOBUF_NULLABLE unsafe_arena_release_text();

  private:
  const ::google::protobuf::StringValue& _internal_text() const;
  ::google::protobuf::StringValue* PROTOBUF_NONNULL _internal_mutable_text();

  public:
  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 8;
  bool has_rectangular_box_and_accuracy() const;
  void clear_rectangular_box_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& rectangular_box_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NULLABLE release_rectangular_box_and_accuracy();
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NONNULL mutable_rectangular_box_and_accuracy();
  void set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_rectangular_box_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& _internal_rectangular_box_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NONNULL _internal_mutable_rectangular_box_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.SurfaceMarking)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   8, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SurfaceMarking& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence > color_and_confidence_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence > material_and_confidence_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE existence_confidence_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE detection_status_;
    ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NULLABLE type_and_confidence_;
    ::google::protobuf::StringValue* PROTOBUF_NULLABLE text_;
    ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NULLABLE rectangular_box_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SurfaceMarking_class_data_;
// -------------------------------------------------------------------

class RoadAttributionCategory final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory) */ {
 public:
  inline RoadAttributionCategory() : RoadAttributionCategory(nullptr) {}
  ~RoadAttributionCategory() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadAttributionCategory* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadAttributionCategory));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadAttributionCategory(::google::protobuf::internal::ConstantInitialized);

  inline RoadAttributionCategory(const RoadAttributionCategory& from) : RoadAttributionCategory(nullptr, from) {}
  inline RoadAttributionCategory(RoadAttributionCategory&& from) noexcept
      : RoadAttributionCategory(nullptr, ::std::move(from)) {}
  inline RoadAttributionCategory& operator=(const RoadAttributionCategory& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadAttributionCategory& operator=(RoadAttributionCategory&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadAttributionCategory& default_instance() {
    return *reinterpret_cast<const RoadAttributionCategory*>(
        &_RoadAttributionCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(RoadAttributionCategory& a, RoadAttributionCategory& b) { a.Swap(&b); }
  inline void Swap(RoadAttributionCategory* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadAttributionCategory* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadAttributionCategory* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadAttributionCategory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadAttributionCategory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadAttributionCategory& from) { RoadAttributionCategory::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadAttributionCategory* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.roadattribution.RoadAttributionCategory"; }

 protected:
  explicit RoadAttributionCategory(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadAttributionCategory(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadAttributionCategory& from);
  RoadAttributionCategory(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadAttributionCategory&& from) noexcept
      : RoadAttributionCategory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLaneBoundaryFieldNumber = 2,
    kLaneBoundaryMergeSplitFieldNumber = 3,
    kLaneFieldNumber = 4,
    kRoadFieldNumber = 5,
    kSurfaceMarkingFieldNumber = 6,
    kSurfaceAttributionFieldNumber = 7,
    kRoadAttributionFieldNumber = 8,
    kDetectedLaneCountAndConfidenceFieldNumber = 9,
    kEstimatedLaneCountAndConfidenceFieldNumber = 10,
    kEnvelopeFieldNumber = 1,
  };
  // repeated .sensoris.protobuf.categories.roadattribution.LaneBoundary lane_boundary = 2;
  int lane_boundary_size() const;
  private:
  int _internal_lane_boundary_size() const;

  public:
  void clear_lane_boundary() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary* PROTOBUF_NONNULL mutable_lane_boundary(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>* PROTOBUF_NONNULL mutable_lane_boundary();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>& _internal_lane_boundary() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>* PROTOBUF_NONNULL _internal_mutable_lane_boundary();
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary& lane_boundary(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary* PROTOBUF_NONNULL add_lane_boundary();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>& lane_boundary() const;
  // repeated .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit lane_boundary_merge_split = 3;
  int lane_boundary_merge_split_size() const;
  private:
  int _internal_lane_boundary_merge_split_size() const;

  public:
  void clear_lane_boundary_merge_split() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* PROTOBUF_NONNULL mutable_lane_boundary_merge_split(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>* PROTOBUF_NONNULL mutable_lane_boundary_merge_split();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>& _internal_lane_boundary_merge_split() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>* PROTOBUF_NONNULL _internal_mutable_lane_boundary_merge_split();
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit& lane_boundary_merge_split(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* PROTOBUF_NONNULL add_lane_boundary_merge_split();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>& lane_boundary_merge_split() const;
  // repeated .sensoris.protobuf.categories.roadattribution.Lane lane = 4;
  int lane_size() const;
  private:
  int _internal_lane_size() const;

  public:
  void clear_lane() ;
  ::sensoris::protobuf::categories::roadattribution::Lane* PROTOBUF_NONNULL mutable_lane(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>* PROTOBUF_NONNULL mutable_lane();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>& _internal_lane() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>* PROTOBUF_NONNULL _internal_mutable_lane();
  public:
  const ::sensoris::protobuf::categories::roadattribution::Lane& lane(int index) const;
  ::sensoris::protobuf::categories::roadattribution::Lane* PROTOBUF_NONNULL add_lane();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>& lane() const;
  // repeated .sensoris.protobuf.categories.roadattribution.Road road = 5;
  int road_size() const;
  private:
  int _internal_road_size() const;

  public:
  void clear_road() ;
  ::sensoris::protobuf::categories::roadattribution::Road* PROTOBUF_NONNULL mutable_road(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>* PROTOBUF_NONNULL mutable_road();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>& _internal_road() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>* PROTOBUF_NONNULL _internal_mutable_road();
  public:
  const ::sensoris::protobuf::categories::roadattribution::Road& road(int index) const;
  ::sensoris::protobuf::categories::roadattribution::Road* PROTOBUF_NONNULL add_road();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>& road() const;
  // repeated .sensoris.protobuf.categories.roadattribution.SurfaceMarking surface_marking = 6;
  int surface_marking_size() const;
  private:
  int _internal_surface_marking_size() const;

  public:
  void clear_surface_marking() ;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* PROTOBUF_NONNULL mutable_surface_marking(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>* PROTOBUF_NONNULL mutable_surface_marking();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>& _internal_surface_marking() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>* PROTOBUF_NONNULL _internal_mutable_surface_marking();
  public:
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking& surface_marking(int index) const;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* PROTOBUF_NONNULL add_surface_marking();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>& surface_marking() const;
  // repeated .sensoris.protobuf.categories.roadattribution.SurfaceAttribution surface_attribution = 7;
  int surface_attribution_size() const;
  private:
  int _internal_surface_attribution_size() const;

  public:
  void clear_surface_attribution() ;
  ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* PROTOBUF_NONNULL mutable_surface_attribution(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>* PROTOBUF_NONNULL mutable_surface_attribution();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>& _internal_surface_attribution() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>* PROTOBUF_NONNULL _internal_mutable_surface_attribution();
  public:
  const ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution& surface_attribution(int index) const;
  ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* PROTOBUF_NONNULL add_surface_attribution();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>& surface_attribution() const;
  // repeated .sensoris.protobuf.categories.roadattribution.RoadAttribution road_attribution = 8;
  int road_attribution_size() const;
  private:
  int _internal_road_attribution_size() const;

  public:
  void clear_road_attribution() ;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution* PROTOBUF_NONNULL mutable_road_attribution(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>* PROTOBUF_NONNULL mutable_road_attribution();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>& _internal_road_attribution() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>* PROTOBUF_NONNULL _internal_mutable_road_attribution();
  public:
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution& road_attribution(int index) const;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution* PROTOBUF_NONNULL add_road_attribution();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>& road_attribution() const;
  // repeated .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence detected_lane_count_and_confidence = 9;
  int detected_lane_count_and_confidence_size() const;
  private:
  int _internal_detected_lane_count_and_confidence_size() const;

  public:
  void clear_detected_lane_count_and_confidence() ;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* PROTOBUF_NONNULL mutable_detected_lane_count_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>* PROTOBUF_NONNULL mutable_detected_lane_count_and_confidence();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>& _internal_detected_lane_count_and_confidence() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>* PROTOBUF_NONNULL _internal_mutable_detected_lane_count_and_confidence();
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence& detected_lane_count_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* PROTOBUF_NONNULL add_detected_lane_count_and_confidence();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>& detected_lane_count_and_confidence() const;
  // repeated .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence estimated_lane_count_and_confidence = 10;
  int estimated_lane_count_and_confidence_size() const;
  private:
  int _internal_estimated_lane_count_and_confidence_size() const;

  public:
  void clear_estimated_lane_count_and_confidence() ;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* PROTOBUF_NONNULL mutable_estimated_lane_count_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>* PROTOBUF_NONNULL mutable_estimated_lane_count_and_confidence();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>& _internal_estimated_lane_count_and_confidence() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>* PROTOBUF_NONNULL _internal_mutable_estimated_lane_count_and_confidence();
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence& estimated_lane_count_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* PROTOBUF_NONNULL add_estimated_lane_count_and_confidence();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>& estimated_lane_count_and_confidence() const;
  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::CategoryEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 10,
                                   10, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadAttributionCategory& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary > lane_boundary_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit > lane_boundary_merge_split_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Lane > lane_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Road > road_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMarking > surface_marking_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution > surface_attribution_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::RoadAttribution > road_attribution_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence > detected_lane_count_and_confidence_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence > estimated_lane_count_and_confidence_;
    ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE envelope_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadAttributionCategory_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MarkingColorAndConfidence

// .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.Type type = 1;
inline void MarkingColorAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type MarkingColorAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.type)
  return _internal_type();
}
inline void MarkingColorAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type MarkingColorAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type>(_impl_.type_);
}
inline void MarkingColorAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool MarkingColorAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& MarkingColorAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& MarkingColorAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
  return _internal_confidence();
}
inline void MarkingColorAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE MarkingColorAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE MarkingColorAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL MarkingColorAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL MarkingColorAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
  return _msg;
}
inline void MarkingColorAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
}

// -------------------------------------------------------------------

// MarkingMaterialAndConfidence

// .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.Type type = 1;
inline void MarkingMaterialAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type MarkingMaterialAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.type)
  return _internal_type();
}
inline void MarkingMaterialAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type MarkingMaterialAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type>(_impl_.type_);
}
inline void MarkingMaterialAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool MarkingMaterialAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& MarkingMaterialAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& MarkingMaterialAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
  return _internal_confidence();
}
inline void MarkingMaterialAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE MarkingMaterialAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE MarkingMaterialAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL MarkingMaterialAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL MarkingMaterialAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
  return _msg;
}
inline void MarkingMaterialAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
}

// -------------------------------------------------------------------

// SurfaceMaterialAndConfidence

// .sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.Type type = 1;
inline void SurfaceMaterialAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type SurfaceMaterialAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.type)
  return _internal_type();
}
inline void SurfaceMaterialAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type SurfaceMaterialAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type>(_impl_.type_);
}
inline void SurfaceMaterialAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool SurfaceMaterialAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMaterialAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMaterialAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
  return _internal_confidence();
}
inline void SurfaceMaterialAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE SurfaceMaterialAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE SurfaceMaterialAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL SurfaceMaterialAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL SurfaceMaterialAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
  return _msg;
}
inline void SurfaceMaterialAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
}

// -------------------------------------------------------------------

// InclinationAndCurvature

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy longitudinal_inclination_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool InclinationAndCurvature::has_longitudinal_inclination_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.longitudinal_inclination_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::_internal_longitudinal_inclination_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.longitudinal_inclination_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::longitudinal_inclination_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
  return _internal_longitudinal_inclination_and_accuracy();
}
inline void InclinationAndCurvature::unsafe_arena_set_allocated_longitudinal_inclination_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.longitudinal_inclination_and_accuracy_);
  }
  _impl_.longitudinal_inclination_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE InclinationAndCurvature::release_longitudinal_inclination_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.longitudinal_inclination_and_accuracy_;
  _impl_.longitudinal_inclination_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE InclinationAndCurvature::unsafe_arena_release_longitudinal_inclination_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.longitudinal_inclination_and_accuracy_;
  _impl_.longitudinal_inclination_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL InclinationAndCurvature::_internal_mutable_longitudinal_inclination_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.longitudinal_inclination_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.longitudinal_inclination_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.longitudinal_inclination_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL InclinationAndCurvature::mutable_longitudinal_inclination_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_longitudinal_inclination_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
  return _msg;
}
inline void InclinationAndCurvature::set_allocated_longitudinal_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.longitudinal_inclination_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.longitudinal_inclination_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy lateral_inclination_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool InclinationAndCurvature::has_lateral_inclination_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lateral_inclination_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::_internal_lateral_inclination_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.lateral_inclination_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::lateral_inclination_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
  return _internal_lateral_inclination_and_accuracy();
}
inline void InclinationAndCurvature::unsafe_arena_set_allocated_lateral_inclination_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lateral_inclination_and_accuracy_);
  }
  _impl_.lateral_inclination_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE InclinationAndCurvature::release_lateral_inclination_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.lateral_inclination_and_accuracy_;
  _impl_.lateral_inclination_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE InclinationAndCurvature::unsafe_arena_release_lateral_inclination_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.lateral_inclination_and_accuracy_;
  _impl_.lateral_inclination_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL InclinationAndCurvature::_internal_mutable_lateral_inclination_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lateral_inclination_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.lateral_inclination_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.lateral_inclination_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL InclinationAndCurvature::mutable_lateral_inclination_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_lateral_inclination_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
  return _msg;
}
inline void InclinationAndCurvature::set_allocated_lateral_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lateral_inclination_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lateral_inclination_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy horizontal_curvature_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool InclinationAndCurvature::has_horizontal_curvature_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.horizontal_curvature_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::_internal_horizontal_curvature_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.horizontal_curvature_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::horizontal_curvature_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
  return _internal_horizontal_curvature_and_accuracy();
}
inline void InclinationAndCurvature::unsafe_arena_set_allocated_horizontal_curvature_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_curvature_and_accuracy_);
  }
  _impl_.horizontal_curvature_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE InclinationAndCurvature::release_horizontal_curvature_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.horizontal_curvature_and_accuracy_;
  _impl_.horizontal_curvature_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE InclinationAndCurvature::unsafe_arena_release_horizontal_curvature_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.horizontal_curvature_and_accuracy_;
  _impl_.horizontal_curvature_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL InclinationAndCurvature::_internal_mutable_horizontal_curvature_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.horizontal_curvature_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.horizontal_curvature_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.horizontal_curvature_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL InclinationAndCurvature::mutable_horizontal_curvature_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_horizontal_curvature_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
  return _msg;
}
inline void InclinationAndCurvature::set_allocated_horizontal_curvature_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_curvature_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.horizontal_curvature_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
}

// -------------------------------------------------------------------

// LaneBoundary_TypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.Type type = 1;
inline void LaneBoundary_TypeAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type LaneBoundary_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.type)
  return _internal_type();
}
inline void LaneBoundary_TypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type LaneBoundary_TypeAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type>(_impl_.type_);
}
inline void LaneBoundary_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool LaneBoundary_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundary_TypeAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundary_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void LaneBoundary_TypeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE LaneBoundary_TypeAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE LaneBoundary_TypeAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL LaneBoundary_TypeAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL LaneBoundary_TypeAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
  return _msg;
}
inline void LaneBoundary_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// LaneBoundary_DashStatistics

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy length_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary_DashStatistics::has_length_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.length_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_DashStatistics::_internal_length_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.length_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_DashStatistics::length_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
  return _internal_length_and_accuracy();
}
inline void LaneBoundary_DashStatistics::unsafe_arena_set_allocated_length_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.length_and_accuracy_);
  }
  _impl_.length_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE LaneBoundary_DashStatistics::release_length_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.length_and_accuracy_;
  _impl_.length_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE LaneBoundary_DashStatistics::unsafe_arena_release_length_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.length_and_accuracy_;
  _impl_.length_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL LaneBoundary_DashStatistics::_internal_mutable_length_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.length_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.length_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.length_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL LaneBoundary_DashStatistics::mutable_length_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_length_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
  return _msg;
}
inline void LaneBoundary_DashStatistics::set_allocated_length_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.length_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.length_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy distance_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary_DashStatistics::has_distance_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.distance_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_DashStatistics::_internal_distance_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.distance_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_DashStatistics::distance_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
  return _internal_distance_and_accuracy();
}
inline void LaneBoundary_DashStatistics::unsafe_arena_set_allocated_distance_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distance_and_accuracy_);
  }
  _impl_.distance_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE LaneBoundary_DashStatistics::release_distance_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.distance_and_accuracy_;
  _impl_.distance_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE LaneBoundary_DashStatistics::unsafe_arena_release_distance_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.distance_and_accuracy_;
  _impl_.distance_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL LaneBoundary_DashStatistics::_internal_mutable_distance_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.distance_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.distance_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.distance_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL LaneBoundary_DashStatistics::mutable_distance_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_distance_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
  return _msg;
}
inline void LaneBoundary_DashStatistics::set_allocated_distance_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distance_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.distance_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
}

// -------------------------------------------------------------------

// LaneBoundary_MarkingOffsets_TypeAndOffset

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.Type type = 1;
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type LaneBoundary_MarkingOffsets_TypeAndOffset::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.type)
  return _internal_type();
}
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.type)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type LaneBoundary_MarkingOffsets_TypeAndOffset::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type>(_impl_.type_);
}
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::_internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy offset_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary_MarkingOffsets_TypeAndOffset::has_offset_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.offset_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_MarkingOffsets_TypeAndOffset::_internal_offset_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.offset_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_MarkingOffsets_TypeAndOffset::offset_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
  return _internal_offset_and_accuracy();
}
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::unsafe_arena_set_allocated_offset_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offset_and_accuracy_);
  }
  _impl_.offset_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE LaneBoundary_MarkingOffsets_TypeAndOffset::release_offset_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.offset_and_accuracy_;
  _impl_.offset_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE LaneBoundary_MarkingOffsets_TypeAndOffset::unsafe_arena_release_offset_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.offset_and_accuracy_;
  _impl_.offset_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL LaneBoundary_MarkingOffsets_TypeAndOffset::_internal_mutable_offset_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.offset_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.offset_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.offset_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL LaneBoundary_MarkingOffsets_TypeAndOffset::mutable_offset_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_offset_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
  return _msg;
}
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::set_allocated_offset_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offset_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.offset_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
}

// -------------------------------------------------------------------

// LaneBoundary_MarkingOffsets

// repeated .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset type_and_offset = 2;
inline int LaneBoundary_MarkingOffsets::_internal_type_and_offset_size() const {
  return _internal_type_and_offset().size();
}
inline int LaneBoundary_MarkingOffsets::type_and_offset_size() const {
  return _internal_type_and_offset_size();
}
inline void LaneBoundary_MarkingOffsets::clear_type_and_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_and_offset_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* PROTOBUF_NONNULL LaneBoundary_MarkingOffsets::mutable_type_and_offset(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return _internal_mutable_type_and_offset()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>* PROTOBUF_NONNULL LaneBoundary_MarkingOffsets::mutable_type_and_offset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_type_and_offset();
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset& LaneBoundary_MarkingOffsets::type_and_offset(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return _internal_type_and_offset().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* PROTOBUF_NONNULL LaneBoundary_MarkingOffsets::add_type_and_offset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* _add = _internal_mutable_type_and_offset()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>& LaneBoundary_MarkingOffsets::type_and_offset() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return _internal_type_and_offset();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>&
LaneBoundary_MarkingOffsets::_internal_type_and_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_and_offset_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>* PROTOBUF_NONNULL
LaneBoundary_MarkingOffsets::_internal_mutable_type_and_offset() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.type_and_offset_;
}

// -------------------------------------------------------------------

// LaneBoundary

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool LaneBoundary::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneBoundary::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneBoundary::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
  return _internal_envelope();
}
inline void LaneBoundary::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE LaneBoundary::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL LaneBoundary::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
  return _msg;
}
inline void LaneBoundary::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
}

// .google.protobuf.Int64Value lane_boundary_id = 2;
inline bool LaneBoundary::has_lane_boundary_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lane_boundary_id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& LaneBoundary::_internal_lane_boundary_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.lane_boundary_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& LaneBoundary::lane_boundary_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
  return _internal_lane_boundary_id();
}
inline void LaneBoundary::unsafe_arena_set_allocated_lane_boundary_id(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lane_boundary_id_);
  }
  _impl_.lane_boundary_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE LaneBoundary::release_lane_boundary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.lane_boundary_id_;
  _impl_.lane_boundary_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_lane_boundary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.lane_boundary_id_;
  _impl_.lane_boundary_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_lane_boundary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lane_boundary_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.lane_boundary_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.lane_boundary_id_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL LaneBoundary::mutable_lane_boundary_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_lane_boundary_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
  return _msg;
}
inline void LaneBoundary::set_allocated_lane_boundary_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lane_boundary_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lane_boundary_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
}

// .sensoris.protobuf.types.base.Confidence existence_confidence = 3;
inline bool LaneBoundary::has_existence_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.existence_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundary::_internal_existence_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.existence_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundary::existence_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
  return _internal_existence_confidence();
}
inline void LaneBoundary::unsafe_arena_set_allocated_existence_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }
  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE LaneBoundary::release_existence_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_existence_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_existence_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.existence_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.existence_confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL LaneBoundary::mutable_existence_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_existence_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
  return _msg;
}
inline void LaneBoundary::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 4;
inline bool LaneBoundary::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& LaneBoundary::_internal_detection_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& LaneBoundary::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
  return _internal_detection_status();
}
inline void LaneBoundary::unsafe_arena_set_allocated_detection_status(
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE LaneBoundary::release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detection_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL LaneBoundary::mutable_detection_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
  return _msg;
}
inline void LaneBoundary::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence type_and_confidence = 5;
inline bool LaneBoundary::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void LaneBoundary::clear_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence& LaneBoundary::_internal_type_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_LaneBoundary_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence& LaneBoundary::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void LaneBoundary::unsafe_arena_set_allocated_type_and_confidence(
    ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NULLABLE LaneBoundary::release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NONNULL LaneBoundary::mutable_type_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
  return _msg;
}
inline void LaneBoundary::set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
}

// .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence material_and_confidence = 6;
inline bool LaneBoundary::has_material_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.material_and_confidence_ != nullptr);
  return value;
}
inline void LaneBoundary::clear_material_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.material_and_confidence_ != nullptr) _impl_.material_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& LaneBoundary::_internal_material_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* p = _impl_.material_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_MarkingMaterialAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& LaneBoundary::material_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
  return _internal_material_and_confidence();
}
inline void LaneBoundary::unsafe_arena_set_allocated_material_and_confidence(
    ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.material_and_confidence_);
  }
  _impl_.material_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NULLABLE LaneBoundary::release_material_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* released = _impl_.material_and_confidence_;
  _impl_.material_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_material_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* temp = _impl_.material_and_confidence_;
  _impl_.material_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_material_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.material_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>(GetArena());
    _impl_.material_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence*>(p);
  }
  return _impl_.material_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NONNULL LaneBoundary::mutable_material_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* _msg = _internal_mutable_material_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
  return _msg;
}
inline void LaneBoundary::set_allocated_material_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.material_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.material_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
}

// .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence color_and_confidence = 7;
inline bool LaneBoundary::has_color_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_and_confidence_ != nullptr);
  return value;
}
inline void LaneBoundary::clear_color_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_and_confidence_ != nullptr) _impl_.color_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& LaneBoundary::_internal_color_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* p = _impl_.color_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_MarkingColorAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& LaneBoundary::color_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
  return _internal_color_and_confidence();
}
inline void LaneBoundary::unsafe_arena_set_allocated_color_and_confidence(
    ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_and_confidence_);
  }
  _impl_.color_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NULLABLE LaneBoundary::release_color_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* released = _impl_.color_and_confidence_;
  _impl_.color_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_color_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* temp = _impl_.color_and_confidence_;
  _impl_.color_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_color_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>(GetArena());
    _impl_.color_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence*>(p);
  }
  return _impl_.color_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NONNULL LaneBoundary::mutable_color_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* _msg = _internal_mutable_color_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
  return _msg;
}
inline void LaneBoundary::set_allocated_color_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.color_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.PositionReference position_reference = 8;
inline void LaneBoundary::clear_position_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_reference_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference LaneBoundary::position_reference() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.position_reference)
  return _internal_position_reference();
}
inline void LaneBoundary::set_position_reference(::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference value) {
  _internal_set_position_reference(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneBoundary.position_reference)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference LaneBoundary::_internal_position_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference>(_impl_.position_reference_);
}
inline void LaneBoundary::_internal_set_position_reference(::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_reference_ = value;
}

// .sensoris.protobuf.types.spatial.PolylineAndAccuracy polyline_and_accuracy = 9;
inline bool LaneBoundary::has_polyline_and_accuracy() const {
  return geometry_case() == kPolylineAndAccuracy;
}
inline bool LaneBoundary::_internal_has_polyline_and_accuracy() const {
  return geometry_case() == kPolylineAndAccuracy;
}
inline void LaneBoundary::set_has_polyline_and_accuracy() {
  _impl_._oneof_case_[0] = kPolylineAndAccuracy;
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE LaneBoundary::release_polyline_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
  if (geometry_case() == kPolylineAndAccuracy) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.polyline_and_accuracy_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.polyline_and_accuracy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& LaneBoundary::_internal_polyline_and_accuracy() const {
  return geometry_case() == kPolylineAndAccuracy ? *_impl_.geometry_.polyline_and_accuracy_ : reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineAndAccuracy&>(::sensoris::protobuf::types::spatial::_PolylineAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& LaneBoundary::polyline_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
  return _internal_polyline_and_accuracy();
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_polyline_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
  if (geometry_case() == kPolylineAndAccuracy) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.polyline_and_accuracy_;
    _impl_.geometry_.polyline_and_accuracy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneBoundary::unsafe_arena_set_allocated_polyline_and_accuracy(
    ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geometry();
  if (value) {
    set_has_polyline_and_accuracy();
    _impl_.geometry_.polyline_and_accuracy_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_polyline_and_accuracy() {
  if (geometry_case() != kPolylineAndAccuracy) {
    clear_geometry();
    set_has_polyline_and_accuracy();
    _impl_.geometry_.polyline_and_accuracy_ = 
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PolylineAndAccuracy>(GetArena());
  }
  return _impl_.geometry_.polyline_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NONNULL LaneBoundary::mutable_polyline_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* _msg = _internal_mutable_polyline_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
  return _msg;
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 10 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary::has_width_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.width_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::_internal_width_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.width_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::width_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
  return _internal_width_and_accuracy();
}
inline void LaneBoundary::unsafe_arena_set_allocated_width_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.width_and_accuracy_);
  }
  _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE LaneBoundary::release_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.width_and_accuracy_;
  _impl_.width_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.width_and_accuracy_;
  _impl_.width_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.width_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.width_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL LaneBoundary::mutable_width_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_width_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
  return _msg;
}
inline void LaneBoundary::set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.width_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy height_and_accuracy = 11 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary::has_height_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.height_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::_internal_height_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.height_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::height_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
  return _internal_height_and_accuracy();
}
inline void LaneBoundary::unsafe_arena_set_allocated_height_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.height_and_accuracy_);
  }
  _impl_.height_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE LaneBoundary::release_height_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.height_and_accuracy_;
  _impl_.height_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_height_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.height_and_accuracy_;
  _impl_.height_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_height_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.height_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.height_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.height_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL LaneBoundary::mutable_height_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_height_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
  return _msg;
}
inline void LaneBoundary::set_allocated_height_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.height_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.height_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy distance_between_double_and_accuracy = 12 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary::has_distance_between_double_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.distance_between_double_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::_internal_distance_between_double_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.distance_between_double_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::distance_between_double_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
  return _internal_distance_between_double_and_accuracy();
}
inline void LaneBoundary::unsafe_arena_set_allocated_distance_between_double_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distance_between_double_and_accuracy_);
  }
  _impl_.distance_between_double_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE LaneBoundary::release_distance_between_double_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.distance_between_double_and_accuracy_;
  _impl_.distance_between_double_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_distance_between_double_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.distance_between_double_and_accuracy_;
  _impl_.distance_between_double_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_distance_between_double_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.distance_between_double_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.distance_between_double_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.distance_between_double_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL LaneBoundary::mutable_distance_between_double_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_distance_between_double_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
  return _msg;
}
inline void LaneBoundary::set_allocated_distance_between_double_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distance_between_double_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.distance_between_double_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics dash_statistics = 13;
inline bool LaneBoundary::has_dash_statistics() const {
  return markings_case() == kDashStatistics;
}
inline bool LaneBoundary::_internal_has_dash_statistics() const {
  return markings_case() == kDashStatistics;
}
inline void LaneBoundary::set_has_dash_statistics() {
  _impl_._oneof_case_[1] = kDashStatistics;
}
inline void LaneBoundary::clear_dash_statistics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (markings_case() == kDashStatistics) {
    if (GetArena() == nullptr) {
      delete _impl_.markings_.dash_statistics_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.markings_.dash_statistics_);
    }
    clear_has_markings();
  }
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* PROTOBUF_NULLABLE LaneBoundary::release_dash_statistics() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
  if (markings_case() == kDashStatistics) {
    clear_has_markings();
    auto* temp = _impl_.markings_.dash_statistics_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.markings_.dash_statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics& LaneBoundary::_internal_dash_statistics() const {
  return markings_case() == kDashStatistics ? *_impl_.markings_.dash_statistics_ : reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics&>(::sensoris::protobuf::categories::roadattribution::_LaneBoundary_DashStatistics_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics& LaneBoundary::dash_statistics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
  return _internal_dash_statistics();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_dash_statistics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
  if (markings_case() == kDashStatistics) {
    clear_has_markings();
    auto* temp = _impl_.markings_.dash_statistics_;
    _impl_.markings_.dash_statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneBoundary::unsafe_arena_set_allocated_dash_statistics(
    ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_markings();
  if (value) {
    set_has_dash_statistics();
    _impl_.markings_.dash_statistics_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_dash_statistics() {
  if (markings_case() != kDashStatistics) {
    clear_markings();
    set_has_dash_statistics();
    _impl_.markings_.dash_statistics_ = 
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics>(GetArena());
  }
  return _impl_.markings_.dash_statistics_;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* PROTOBUF_NONNULL LaneBoundary::mutable_dash_statistics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* _msg = _internal_mutable_dash_statistics();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
  return _msg;
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets marking_offsets = 14;
inline bool LaneBoundary::has_marking_offsets() const {
  return markings_case() == kMarkingOffsets;
}
inline bool LaneBoundary::_internal_has_marking_offsets() const {
  return markings_case() == kMarkingOffsets;
}
inline void LaneBoundary::set_has_marking_offsets() {
  _impl_._oneof_case_[1] = kMarkingOffsets;
}
inline void LaneBoundary::clear_marking_offsets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (markings_case() == kMarkingOffsets) {
    if (GetArena() == nullptr) {
      delete _impl_.markings_.marking_offsets_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.markings_.marking_offsets_);
    }
    clear_has_markings();
  }
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* PROTOBUF_NULLABLE LaneBoundary::release_marking_offsets() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
  if (markings_case() == kMarkingOffsets) {
    clear_has_markings();
    auto* temp = _impl_.markings_.marking_offsets_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.markings_.marking_offsets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets& LaneBoundary::_internal_marking_offsets() const {
  return markings_case() == kMarkingOffsets ? *_impl_.markings_.marking_offsets_ : reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets&>(::sensoris::protobuf::categories::roadattribution::_LaneBoundary_MarkingOffsets_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets& LaneBoundary::marking_offsets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
  return _internal_marking_offsets();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* PROTOBUF_NULLABLE LaneBoundary::unsafe_arena_release_marking_offsets() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
  if (markings_case() == kMarkingOffsets) {
    clear_has_markings();
    auto* temp = _impl_.markings_.marking_offsets_;
    _impl_.markings_.marking_offsets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneBoundary::unsafe_arena_set_allocated_marking_offsets(
    ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_markings();
  if (value) {
    set_has_marking_offsets();
    _impl_.markings_.marking_offsets_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* PROTOBUF_NONNULL LaneBoundary::_internal_mutable_marking_offsets() {
  if (markings_case() != kMarkingOffsets) {
    clear_markings();
    set_has_marking_offsets();
    _impl_.markings_.marking_offsets_ = 
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets>(GetArena());
  }
  return _impl_.markings_.marking_offsets_;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* PROTOBUF_NONNULL LaneBoundary::mutable_marking_offsets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* _msg = _internal_mutable_marking_offsets();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
  return _msg;
}

inline bool LaneBoundary::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void LaneBoundary::clear_has_geometry() {
  _impl_._oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline bool LaneBoundary::has_markings() const {
  return markings_case() != MARKINGS_NOT_SET;
}
inline void LaneBoundary::clear_has_markings() {
  _impl_._oneof_case_[1] = MARKINGS_NOT_SET;
}
inline LaneBoundary::GeometryCase LaneBoundary::geometry_case() const {
  return LaneBoundary::GeometryCase(_impl_._oneof_case_[0]);
}
inline LaneBoundary::MarkingsCase LaneBoundary::markings_case() const {
  return LaneBoundary::MarkingsCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// LaneBoundaryMergeSplit_TypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.Type type = 1;
inline void LaneBoundaryMergeSplit_TypeAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type LaneBoundaryMergeSplit_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.type)
  return _internal_type();
}
inline void LaneBoundaryMergeSplit_TypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type LaneBoundaryMergeSplit_TypeAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type>(_impl_.type_);
}
inline void LaneBoundaryMergeSplit_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool LaneBoundaryMergeSplit_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundaryMergeSplit_TypeAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundaryMergeSplit_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void LaneBoundaryMergeSplit_TypeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE LaneBoundaryMergeSplit_TypeAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE LaneBoundaryMergeSplit_TypeAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL LaneBoundaryMergeSplit_TypeAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL LaneBoundaryMergeSplit_TypeAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
  return _msg;
}
inline void LaneBoundaryMergeSplit_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// LaneBoundaryMergeSplit

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool LaneBoundaryMergeSplit::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneBoundaryMergeSplit::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneBoundaryMergeSplit::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
  return _internal_envelope();
}
inline void LaneBoundaryMergeSplit::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE LaneBoundaryMergeSplit::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE LaneBoundaryMergeSplit::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL LaneBoundaryMergeSplit::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL LaneBoundaryMergeSplit::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
  return _msg;
}
inline void LaneBoundaryMergeSplit::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
}

// .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
inline bool LaneBoundaryMergeSplit::has_existence_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.existence_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundaryMergeSplit::_internal_existence_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.existence_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundaryMergeSplit::existence_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
  return _internal_existence_confidence();
}
inline void LaneBoundaryMergeSplit::unsafe_arena_set_allocated_existence_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }
  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE LaneBoundaryMergeSplit::release_existence_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE LaneBoundaryMergeSplit::unsafe_arena_release_existence_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL LaneBoundaryMergeSplit::_internal_mutable_existence_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.existence_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.existence_confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL LaneBoundaryMergeSplit::mutable_existence_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_existence_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
  return _msg;
}
inline void LaneBoundaryMergeSplit::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
inline bool LaneBoundaryMergeSplit::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& LaneBoundaryMergeSplit::_internal_detection_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& LaneBoundaryMergeSplit::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
  return _internal_detection_status();
}
inline void LaneBoundaryMergeSplit::unsafe_arena_set_allocated_detection_status(
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE LaneBoundaryMergeSplit::release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE LaneBoundaryMergeSplit::unsafe_arena_release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL LaneBoundaryMergeSplit::_internal_mutable_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detection_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL LaneBoundaryMergeSplit::mutable_detection_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
  return _msg;
}
inline void LaneBoundaryMergeSplit::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence type_and_confidence = 4;
inline bool LaneBoundaryMergeSplit::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void LaneBoundaryMergeSplit::clear_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence& LaneBoundaryMergeSplit::_internal_type_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_LaneBoundaryMergeSplit_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence& LaneBoundaryMergeSplit::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void LaneBoundaryMergeSplit::unsafe_arena_set_allocated_type_and_confidence(
    ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NULLABLE LaneBoundaryMergeSplit::release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NULLABLE LaneBoundaryMergeSplit::unsafe_arena_release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NONNULL LaneBoundaryMergeSplit::_internal_mutable_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NONNULL LaneBoundaryMergeSplit::mutable_type_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
  return _msg;
}
inline void LaneBoundaryMergeSplit::set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 5;
inline bool LaneBoundaryMergeSplit::has_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& LaneBoundaryMergeSplit::_internal_position_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& LaneBoundaryMergeSplit::position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline void LaneBoundaryMergeSplit::unsafe_arena_set_allocated_position_and_accuracy(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }
  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE LaneBoundaryMergeSplit::release_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE LaneBoundaryMergeSplit::unsafe_arena_release_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL LaneBoundaryMergeSplit::_internal_mutable_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL LaneBoundaryMergeSplit::mutable_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
  return _msg;
}
inline void LaneBoundaryMergeSplit::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
}

// -------------------------------------------------------------------

// Lane

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool Lane::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Lane::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Lane::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Lane.envelope)
  return _internal_envelope();
}
inline void Lane::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE Lane::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE Lane::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Lane.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL Lane::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL Lane::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Lane.envelope)
  return _msg;
}
inline void Lane::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.envelope)
}

// .google.protobuf.Int64Value relative_lane_id = 2;
inline bool Lane::has_relative_lane_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relative_lane_id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& Lane::_internal_relative_lane_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.relative_lane_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& Lane::relative_lane_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
  return _internal_relative_lane_id();
}
inline void Lane::unsafe_arena_set_allocated_relative_lane_id(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relative_lane_id_);
  }
  _impl_.relative_lane_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE Lane::release_relative_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.relative_lane_id_;
  _impl_.relative_lane_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE Lane::unsafe_arena_release_relative_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.relative_lane_id_;
  _impl_.relative_lane_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL Lane::_internal_mutable_relative_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.relative_lane_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.relative_lane_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.relative_lane_id_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL Lane::mutable_relative_lane_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_relative_lane_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
  return _msg;
}
inline void Lane::set_allocated_relative_lane_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relative_lane_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.relative_lane_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool Lane::has_width_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.width_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& Lane::_internal_width_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.width_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& Lane::width_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
  return _internal_width_and_accuracy();
}
inline void Lane::unsafe_arena_set_allocated_width_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.width_and_accuracy_);
  }
  _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE Lane::release_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.width_and_accuracy_;
  _impl_.width_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE Lane::unsafe_arena_release_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.width_and_accuracy_;
  _impl_.width_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL Lane::_internal_mutable_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.width_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.width_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL Lane::mutable_width_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_width_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
  return _msg;
}
inline void Lane::set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.width_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 4;
inline bool Lane::has_inclination_and_curvature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inclination_and_curvature_ != nullptr);
  return value;
}
inline void Lane::clear_inclination_and_curvature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.inclination_and_curvature_ != nullptr) _impl_.inclination_and_curvature_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& Lane::_internal_inclination_and_curvature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* p = _impl_.inclination_and_curvature_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature&>(::sensoris::protobuf::categories::roadattribution::_InclinationAndCurvature_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& Lane::inclination_and_curvature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
  return _internal_inclination_and_curvature();
}
inline void Lane::unsafe_arena_set_allocated_inclination_and_curvature(
    ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inclination_and_curvature_);
  }
  _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE Lane::release_inclination_and_curvature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* released = _impl_.inclination_and_curvature_;
  _impl_.inclination_and_curvature_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE Lane::unsafe_arena_release_inclination_and_curvature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* temp = _impl_.inclination_and_curvature_;
  _impl_.inclination_and_curvature_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NONNULL Lane::_internal_mutable_inclination_and_curvature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.inclination_and_curvature_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature>(GetArena());
    _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(p);
  }
  return _impl_.inclination_and_curvature_;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NONNULL Lane::mutable_inclination_and_curvature()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* _msg = _internal_mutable_inclination_and_curvature();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
  return _msg;
}
inline void Lane::set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inclination_and_curvature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
}

// -------------------------------------------------------------------

// Road

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool Road::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Road::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Road::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Road.envelope)
  return _internal_envelope();
}
inline void Road::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Road.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE Road::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE Road::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Road.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL Road::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL Road::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Road.envelope)
  return _msg;
}
inline void Road::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Road.envelope)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 2;
inline bool Road::has_width_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.width_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& Road::_internal_width_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.width_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& Road::width_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
  return _internal_width_and_accuracy();
}
inline void Road::unsafe_arena_set_allocated_width_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.width_and_accuracy_);
  }
  _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE Road::release_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.width_and_accuracy_;
  _impl_.width_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE Road::unsafe_arena_release_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.width_and_accuracy_;
  _impl_.width_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL Road::_internal_mutable_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.width_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.width_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL Road::mutable_width_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_width_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
  return _msg;
}
inline void Road::set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.width_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 3;
inline bool Road::has_inclination_and_curvature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inclination_and_curvature_ != nullptr);
  return value;
}
inline void Road::clear_inclination_and_curvature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.inclination_and_curvature_ != nullptr) _impl_.inclination_and_curvature_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& Road::_internal_inclination_and_curvature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* p = _impl_.inclination_and_curvature_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature&>(::sensoris::protobuf::categories::roadattribution::_InclinationAndCurvature_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& Road::inclination_and_curvature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
  return _internal_inclination_and_curvature();
}
inline void Road::unsafe_arena_set_allocated_inclination_and_curvature(
    ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inclination_and_curvature_);
  }
  _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE Road::release_inclination_and_curvature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* released = _impl_.inclination_and_curvature_;
  _impl_.inclination_and_curvature_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE Road::unsafe_arena_release_inclination_and_curvature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* temp = _impl_.inclination_and_curvature_;
  _impl_.inclination_and_curvature_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NONNULL Road::_internal_mutable_inclination_and_curvature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.inclination_and_curvature_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature>(GetArena());
    _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(p);
  }
  return _impl_.inclination_and_curvature_;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NONNULL Road::mutable_inclination_and_curvature()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* _msg = _internal_mutable_inclination_and_curvature();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
  return _msg;
}
inline void Road::set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inclination_and_curvature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
}

// -------------------------------------------------------------------

// SurfaceMarking_TypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.Type type = 1;
inline void SurfaceMarking_TypeAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type SurfaceMarking_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.type)
  return _internal_type();
}
inline void SurfaceMarking_TypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type SurfaceMarking_TypeAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type>(_impl_.type_);
}
inline void SurfaceMarking_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool SurfaceMarking_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMarking_TypeAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMarking_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void SurfaceMarking_TypeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE SurfaceMarking_TypeAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE SurfaceMarking_TypeAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL SurfaceMarking_TypeAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL SurfaceMarking_TypeAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
  return _msg;
}
inline void SurfaceMarking_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// SurfaceMarking

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool SurfaceMarking::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& SurfaceMarking::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& SurfaceMarking::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
  return _internal_envelope();
}
inline void SurfaceMarking::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE SurfaceMarking::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE SurfaceMarking::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL SurfaceMarking::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL SurfaceMarking::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
  return _msg;
}
inline void SurfaceMarking::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
}

// .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
inline bool SurfaceMarking::has_existence_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.existence_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMarking::_internal_existence_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.existence_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMarking::existence_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
  return _internal_existence_confidence();
}
inline void SurfaceMarking::unsafe_arena_set_allocated_existence_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }
  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE SurfaceMarking::release_existence_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE SurfaceMarking::unsafe_arena_release_existence_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL SurfaceMarking::_internal_mutable_existence_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.existence_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.existence_confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL SurfaceMarking::mutable_existence_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_existence_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
  return _msg;
}
inline void SurfaceMarking::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
inline bool SurfaceMarking::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& SurfaceMarking::_internal_detection_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& SurfaceMarking::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
  return _internal_detection_status();
}
inline void SurfaceMarking::unsafe_arena_set_allocated_detection_status(
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE SurfaceMarking::release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE SurfaceMarking::unsafe_arena_release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL SurfaceMarking::_internal_mutable_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detection_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL SurfaceMarking::mutable_detection_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
  return _msg;
}
inline void SurfaceMarking::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
}

// .sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence type_and_confidence = 4;
inline bool SurfaceMarking::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void SurfaceMarking::clear_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence& SurfaceMarking::_internal_type_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_SurfaceMarking_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence& SurfaceMarking::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void SurfaceMarking::unsafe_arena_set_allocated_type_and_confidence(
    ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NULLABLE SurfaceMarking::release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NULLABLE SurfaceMarking::unsafe_arena_release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NONNULL SurfaceMarking::_internal_mutable_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NONNULL SurfaceMarking::mutable_type_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
  return _msg;
}
inline void SurfaceMarking::set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
}

// .google.protobuf.StringValue text = 5;
inline bool SurfaceMarking::has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.text_ != nullptr);
  return value;
}
inline const ::google::protobuf::StringValue& SurfaceMarking::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::StringValue* p = _impl_.text_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::StringValue&>(::google::protobuf::_StringValue_default_instance_);
}
inline const ::google::protobuf::StringValue& SurfaceMarking::text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
  return _internal_text();
}
inline void SurfaceMarking::unsafe_arena_set_allocated_text(
    ::google::protobuf::StringValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.text_);
  }
  _impl_.text_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
}
inline ::google::protobuf::StringValue* PROTOBUF_NULLABLE SurfaceMarking::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::StringValue* released = _impl_.text_;
  _impl_.text_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::StringValue* PROTOBUF_NULLABLE SurfaceMarking::unsafe_arena_release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::StringValue* temp = _impl_.text_;
  _impl_.text_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* PROTOBUF_NONNULL SurfaceMarking::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.text_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::StringValue>(GetArena());
    _impl_.text_ = reinterpret_cast<::google::protobuf::StringValue*>(p);
  }
  return _impl_.text_;
}
inline ::google::protobuf::StringValue* PROTOBUF_NONNULL SurfaceMarking::mutable_text()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::google::protobuf::StringValue* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
  return _msg;
}
inline void SurfaceMarking::set_allocated_text(::google::protobuf::StringValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.text_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.text_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
}

// repeated .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence color_and_confidence = 6;
inline int SurfaceMarking::_internal_color_and_confidence_size() const {
  return _internal_color_and_confidence().size();
}
inline int SurfaceMarking::color_and_confidence_size() const {
  return _internal_color_and_confidence_size();
}
inline void SurfaceMarking::clear_color_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NONNULL SurfaceMarking::mutable_color_and_confidence(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return _internal_mutable_color_and_confidence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>* PROTOBUF_NONNULL SurfaceMarking::mutable_color_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_color_and_confidence();
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& SurfaceMarking::color_and_confidence(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return _internal_color_and_confidence().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* PROTOBUF_NONNULL SurfaceMarking::add_color_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* _add = _internal_mutable_color_and_confidence()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>& SurfaceMarking::color_and_confidence() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return _internal_color_and_confidence();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>&
SurfaceMarking::_internal_color_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.color_and_confidence_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>* PROTOBUF_NONNULL
SurfaceMarking::_internal_mutable_color_and_confidence() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.color_and_confidence_;
}

// repeated .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence material_and_confidence = 7;
inline int SurfaceMarking::_internal_material_and_confidence_size() const {
  return _internal_material_and_confidence().size();
}
inline int SurfaceMarking::material_and_confidence_size() const {
  return _internal_material_and_confidence_size();
}
inline void SurfaceMarking::clear_material_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.material_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NONNULL SurfaceMarking::mutable_material_and_confidence(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return _internal_mutable_material_and_confidence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>* PROTOBUF_NONNULL SurfaceMarking::mutable_material_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_material_and_confidence();
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& SurfaceMarking::material_and_confidence(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return _internal_material_and_confidence().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* PROTOBUF_NONNULL SurfaceMarking::add_material_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* _add = _internal_mutable_material_and_confidence()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>& SurfaceMarking::material_and_confidence() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return _internal_material_and_confidence();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>&
SurfaceMarking::_internal_material_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.material_and_confidence_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>* PROTOBUF_NONNULL
SurfaceMarking::_internal_mutable_material_and_confidence() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.material_and_confidence_;
}

// .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 8;
inline bool SurfaceMarking::has_rectangular_box_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rectangular_box_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& SurfaceMarking::_internal_rectangular_box_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* p = _impl_.rectangular_box_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy&>(::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& SurfaceMarking::rectangular_box_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
  return _internal_rectangular_box_and_accuracy();
}
inline void SurfaceMarking::unsafe_arena_set_allocated_rectangular_box_and_accuracy(
    ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rectangular_box_and_accuracy_);
  }
  _impl_.rectangular_box_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NULLABLE SurfaceMarking::release_rectangular_box_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* released = _impl_.rectangular_box_and_accuracy_;
  _impl_.rectangular_box_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NULLABLE SurfaceMarking::unsafe_arena_release_rectangular_box_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* temp = _impl_.rectangular_box_and_accuracy_;
  _impl_.rectangular_box_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NONNULL SurfaceMarking::_internal_mutable_rectangular_box_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rectangular_box_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy>(GetArena());
    _impl_.rectangular_box_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy*>(p);
  }
  return _impl_.rectangular_box_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NONNULL SurfaceMarking::mutable_rectangular_box_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* _msg = _internal_mutable_rectangular_box_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
  return _msg;
}
inline void SurfaceMarking::set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rectangular_box_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.rectangular_box_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
}

// -------------------------------------------------------------------

// SurfaceAttribution

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool SurfaceAttribution::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& SurfaceAttribution::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& SurfaceAttribution::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
  return _internal_envelope();
}
inline void SurfaceAttribution::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE SurfaceAttribution::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE SurfaceAttribution::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL SurfaceAttribution::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL SurfaceAttribution::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
  return _msg;
}
inline void SurfaceAttribution::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
inline bool SurfaceAttribution::has_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& SurfaceAttribution::_internal_position_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& SurfaceAttribution::position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline void SurfaceAttribution::unsafe_arena_set_allocated_position_and_accuracy(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }
  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE SurfaceAttribution::release_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE SurfaceAttribution::unsafe_arena_release_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL SurfaceAttribution::_internal_mutable_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL SurfaceAttribution::mutable_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
  return _msg;
}
inline void SurfaceAttribution::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 3;
inline bool SurfaceAttribution::has_inclination_and_curvature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inclination_and_curvature_ != nullptr);
  return value;
}
inline void SurfaceAttribution::clear_inclination_and_curvature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.inclination_and_curvature_ != nullptr) _impl_.inclination_and_curvature_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& SurfaceAttribution::_internal_inclination_and_curvature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* p = _impl_.inclination_and_curvature_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature&>(::sensoris::protobuf::categories::roadattribution::_InclinationAndCurvature_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& SurfaceAttribution::inclination_and_curvature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
  return _internal_inclination_and_curvature();
}
inline void SurfaceAttribution::unsafe_arena_set_allocated_inclination_and_curvature(
    ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inclination_and_curvature_);
  }
  _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE SurfaceAttribution::release_inclination_and_curvature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* released = _impl_.inclination_and_curvature_;
  _impl_.inclination_and_curvature_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE SurfaceAttribution::unsafe_arena_release_inclination_and_curvature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* temp = _impl_.inclination_and_curvature_;
  _impl_.inclination_and_curvature_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NONNULL SurfaceAttribution::_internal_mutable_inclination_and_curvature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.inclination_and_curvature_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature>(GetArena());
    _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(p);
  }
  return _impl_.inclination_and_curvature_;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NONNULL SurfaceAttribution::mutable_inclination_and_curvature()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* _msg = _internal_mutable_inclination_and_curvature();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
  return _msg;
}
inline void SurfaceAttribution::set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inclination_and_curvature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
}

// repeated .sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence material_and_confidence = 4;
inline int SurfaceAttribution::_internal_material_and_confidence_size() const {
  return _internal_material_and_confidence().size();
}
inline int SurfaceAttribution::material_and_confidence_size() const {
  return _internal_material_and_confidence_size();
}
inline void SurfaceAttribution::clear_material_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.material_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* PROTOBUF_NONNULL SurfaceAttribution::mutable_material_and_confidence(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return _internal_mutable_material_and_confidence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>* PROTOBUF_NONNULL SurfaceAttribution::mutable_material_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_material_and_confidence();
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence& SurfaceAttribution::material_and_confidence(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return _internal_material_and_confidence().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* PROTOBUF_NONNULL SurfaceAttribution::add_material_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* _add = _internal_mutable_material_and_confidence()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>& SurfaceAttribution::material_and_confidence() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return _internal_material_and_confidence();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>&
SurfaceAttribution::_internal_material_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.material_and_confidence_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>* PROTOBUF_NONNULL
SurfaceAttribution::_internal_mutable_material_and_confidence() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.material_and_confidence_;
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy road_roughness_and_accuracy = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool SurfaceAttribution::has_road_roughness_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.road_roughness_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& SurfaceAttribution::_internal_road_roughness_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.road_roughness_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& SurfaceAttribution::road_roughness_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
  return _internal_road_roughness_and_accuracy();
}
inline void SurfaceAttribution::unsafe_arena_set_allocated_road_roughness_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.road_roughness_and_accuracy_);
  }
  _impl_.road_roughness_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE SurfaceAttribution::release_road_roughness_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.road_roughness_and_accuracy_;
  _impl_.road_roughness_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE SurfaceAttribution::unsafe_arena_release_road_roughness_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.road_roughness_and_accuracy_;
  _impl_.road_roughness_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL SurfaceAttribution::_internal_mutable_road_roughness_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.road_roughness_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.road_roughness_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.road_roughness_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL SurfaceAttribution::mutable_road_roughness_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_road_roughness_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
  return _msg;
}
inline void SurfaceAttribution::set_allocated_road_roughness_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.road_roughness_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.road_roughness_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
}

// -------------------------------------------------------------------

// RoadAttribution_TypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.Type type = 1;
inline void RoadAttribution_TypeAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type RoadAttribution_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.type)
  return _internal_type();
}
inline void RoadAttribution_TypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type RoadAttribution_TypeAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadAttribution_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadAttribution_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadAttribution_TypeAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadAttribution_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadAttribution_TypeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE RoadAttribution_TypeAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE RoadAttribution_TypeAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL RoadAttribution_TypeAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL RoadAttribution_TypeAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
  return _msg;
}
inline void RoadAttribution_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadAttribution_ChangeTypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.Type type = 1;
inline void RoadAttribution_ChangeTypeAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type RoadAttribution_ChangeTypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.type)
  return _internal_type();
}
inline void RoadAttribution_ChangeTypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type RoadAttribution_ChangeTypeAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadAttribution_ChangeTypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadAttribution_ChangeTypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadAttribution_ChangeTypeAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadAttribution_ChangeTypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadAttribution_ChangeTypeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE RoadAttribution_ChangeTypeAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE RoadAttribution_ChangeTypeAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL RoadAttribution_ChangeTypeAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL RoadAttribution_ChangeTypeAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
  return _msg;
}
inline void RoadAttribution_ChangeTypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadAttribution

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadAttribution::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadAttribution::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadAttribution::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
  return _internal_envelope();
}
inline void RoadAttribution::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE RoadAttribution::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE RoadAttribution::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL RoadAttribution::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL RoadAttribution::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
  return _msg;
}
inline void RoadAttribution::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadAttribution::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadAttribution::_internal_detection_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadAttribution::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
  return _internal_detection_status();
}
inline void RoadAttribution::unsafe_arena_set_allocated_detection_status(
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE RoadAttribution::release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE RoadAttribution::unsafe_arena_release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL RoadAttribution::_internal_mutable_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detection_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL RoadAttribution::mutable_detection_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
  return _msg;
}
inline void RoadAttribution::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 3;
inline bool RoadAttribution::has_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RoadAttribution::_internal_position_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RoadAttribution::position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline void RoadAttribution::unsafe_arena_set_allocated_position_and_accuracy(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }
  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE RoadAttribution::release_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE RoadAttribution::unsafe_arena_release_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL RoadAttribution::_internal_mutable_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL RoadAttribution::mutable_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
  return _msg;
}
inline void RoadAttribution::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence type_and_confidence = 4;
inline bool RoadAttribution::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void RoadAttribution::clear_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence& RoadAttribution::_internal_type_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_RoadAttribution_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence& RoadAttribution::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void RoadAttribution::unsafe_arena_set_allocated_type_and_confidence(
    ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NULLABLE RoadAttribution::release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NULLABLE RoadAttribution::unsafe_arena_release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NONNULL RoadAttribution::_internal_mutable_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NONNULL RoadAttribution::mutable_type_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
  return _msg;
}
inline void RoadAttribution::set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
}

// .sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence change_type_and_confidence = 5;
inline bool RoadAttribution::has_change_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.change_type_and_confidence_ != nullptr);
  return value;
}
inline void RoadAttribution::clear_change_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.change_type_and_confidence_ != nullptr) _impl_.change_type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence& RoadAttribution::_internal_change_type_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* p = _impl_.change_type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_RoadAttribution_ChangeTypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence& RoadAttribution::change_type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
  return _internal_change_type_and_confidence();
}
inline void RoadAttribution::unsafe_arena_set_allocated_change_type_and_confidence(
    ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.change_type_and_confidence_);
  }
  _impl_.change_type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NULLABLE RoadAttribution::release_change_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* released = _impl_.change_type_and_confidence_;
  _impl_.change_type_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NULLABLE RoadAttribution::unsafe_arena_release_change_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* temp = _impl_.change_type_and_confidence_;
  _impl_.change_type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NONNULL RoadAttribution::_internal_mutable_change_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.change_type_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence>(GetArena());
    _impl_.change_type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence*>(p);
  }
  return _impl_.change_type_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NONNULL RoadAttribution::mutable_change_type_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* _msg = _internal_mutable_change_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
  return _msg;
}
inline void RoadAttribution::set_allocated_change_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.change_type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.change_type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
}

// -------------------------------------------------------------------

// LaneCountAndConfidence

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool LaneCountAndConfidence::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneCountAndConfidence::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneCountAndConfidence::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
  return _internal_envelope();
}
inline void LaneCountAndConfidence::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE LaneCountAndConfidence::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE LaneCountAndConfidence::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL LaneCountAndConfidence::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL LaneCountAndConfidence::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
  return _msg;
}
inline void LaneCountAndConfidence::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
inline bool LaneCountAndConfidence::has_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& LaneCountAndConfidence::_internal_position_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& LaneCountAndConfidence::position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline void LaneCountAndConfidence::unsafe_arena_set_allocated_position_and_accuracy(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }
  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE LaneCountAndConfidence::release_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE LaneCountAndConfidence::unsafe_arena_release_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL LaneCountAndConfidence::_internal_mutable_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL LaneCountAndConfidence::mutable_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
  return _msg;
}
inline void LaneCountAndConfidence::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.Type type = 3;
inline void LaneCountAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type LaneCountAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.type)
  return _internal_type();
}
inline void LaneCountAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type LaneCountAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type>(_impl_.type_);
}
inline void LaneCountAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.CountAndConfidence count_and_confidence = 4;
inline bool LaneCountAndConfidence::has_count_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.count_and_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& LaneCountAndConfidence::_internal_count_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::CountAndConfidence* p = _impl_.count_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::CountAndConfidence&>(::sensoris::protobuf::types::base::_CountAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& LaneCountAndConfidence::count_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
  return _internal_count_and_confidence();
}
inline void LaneCountAndConfidence::unsafe_arena_set_allocated_count_and_confidence(
    ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.count_and_confidence_);
  }
  _impl_.count_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE LaneCountAndConfidence::release_count_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::CountAndConfidence* released = _impl_.count_and_confidence_;
  _impl_.count_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE LaneCountAndConfidence::unsafe_arena_release_count_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::CountAndConfidence* temp = _impl_.count_and_confidence_;
  _impl_.count_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NONNULL LaneCountAndConfidence::_internal_mutable_count_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.count_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::CountAndConfidence>(GetArena());
    _impl_.count_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(p);
  }
  return _impl_.count_and_confidence_;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NONNULL LaneCountAndConfidence::mutable_count_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::CountAndConfidence* _msg = _internal_mutable_count_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
  return _msg;
}
inline void LaneCountAndConfidence::set_allocated_count_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.count_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.count_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
}

// -------------------------------------------------------------------

// RoadAttributionCategory

// .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
inline bool RoadAttributionCategory::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& RoadAttributionCategory::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::CategoryEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::CategoryEnvelope&>(::sensoris::protobuf::types::base::_CategoryEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& RoadAttributionCategory::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
  return _internal_envelope();
}
inline void RoadAttributionCategory::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE RoadAttributionCategory::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE RoadAttributionCategory::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NONNULL RoadAttributionCategory::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::CategoryEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NONNULL RoadAttributionCategory::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
  return _msg;
}
inline void RoadAttributionCategory::set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
}

// repeated .sensoris.protobuf.categories.roadattribution.LaneBoundary lane_boundary = 2;
inline int RoadAttributionCategory::_internal_lane_boundary_size() const {
  return _internal_lane_boundary().size();
}
inline int RoadAttributionCategory::lane_boundary_size() const {
  return _internal_lane_boundary_size();
}
inline void RoadAttributionCategory::clear_lane_boundary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lane_boundary_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary* PROTOBUF_NONNULL RoadAttributionCategory::mutable_lane_boundary(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return _internal_mutable_lane_boundary()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>* PROTOBUF_NONNULL RoadAttributionCategory::mutable_lane_boundary()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_lane_boundary();
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary& RoadAttributionCategory::lane_boundary(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return _internal_lane_boundary().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary* PROTOBUF_NONNULL RoadAttributionCategory::add_lane_boundary()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary* _add = _internal_mutable_lane_boundary()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>& RoadAttributionCategory::lane_boundary() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return _internal_lane_boundary();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>&
RoadAttributionCategory::_internal_lane_boundary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lane_boundary_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>* PROTOBUF_NONNULL
RoadAttributionCategory::_internal_mutable_lane_boundary() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.lane_boundary_;
}

// repeated .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit lane_boundary_merge_split = 3;
inline int RoadAttributionCategory::_internal_lane_boundary_merge_split_size() const {
  return _internal_lane_boundary_merge_split().size();
}
inline int RoadAttributionCategory::lane_boundary_merge_split_size() const {
  return _internal_lane_boundary_merge_split_size();
}
inline void RoadAttributionCategory::clear_lane_boundary_merge_split() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lane_boundary_merge_split_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* PROTOBUF_NONNULL RoadAttributionCategory::mutable_lane_boundary_merge_split(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return _internal_mutable_lane_boundary_merge_split()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>* PROTOBUF_NONNULL RoadAttributionCategory::mutable_lane_boundary_merge_split()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_lane_boundary_merge_split();
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit& RoadAttributionCategory::lane_boundary_merge_split(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return _internal_lane_boundary_merge_split().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* PROTOBUF_NONNULL RoadAttributionCategory::add_lane_boundary_merge_split()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* _add = _internal_mutable_lane_boundary_merge_split()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>& RoadAttributionCategory::lane_boundary_merge_split() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return _internal_lane_boundary_merge_split();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>&
RoadAttributionCategory::_internal_lane_boundary_merge_split() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lane_boundary_merge_split_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>* PROTOBUF_NONNULL
RoadAttributionCategory::_internal_mutable_lane_boundary_merge_split() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.lane_boundary_merge_split_;
}

// repeated .sensoris.protobuf.categories.roadattribution.Lane lane = 4;
inline int RoadAttributionCategory::_internal_lane_size() const {
  return _internal_lane().size();
}
inline int RoadAttributionCategory::lane_size() const {
  return _internal_lane_size();
}
inline void RoadAttributionCategory::clear_lane() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lane_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::Lane* PROTOBUF_NONNULL RoadAttributionCategory::mutable_lane(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return _internal_mutable_lane()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>* PROTOBUF_NONNULL RoadAttributionCategory::mutable_lane()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_lane();
}
inline const ::sensoris::protobuf::categories::roadattribution::Lane& RoadAttributionCategory::lane(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return _internal_lane().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::Lane* PROTOBUF_NONNULL RoadAttributionCategory::add_lane()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::Lane* _add = _internal_mutable_lane()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>& RoadAttributionCategory::lane() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return _internal_lane();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>&
RoadAttributionCategory::_internal_lane() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lane_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>* PROTOBUF_NONNULL
RoadAttributionCategory::_internal_mutable_lane() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.lane_;
}

// repeated .sensoris.protobuf.categories.roadattribution.Road road = 5;
inline int RoadAttributionCategory::_internal_road_size() const {
  return _internal_road().size();
}
inline int RoadAttributionCategory::road_size() const {
  return _internal_road_size();
}
inline void RoadAttributionCategory::clear_road() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.road_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::Road* PROTOBUF_NONNULL RoadAttributionCategory::mutable_road(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return _internal_mutable_road()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>* PROTOBUF_NONNULL RoadAttributionCategory::mutable_road()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_road();
}
inline const ::sensoris::protobuf::categories::roadattribution::Road& RoadAttributionCategory::road(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return _internal_road().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::Road* PROTOBUF_NONNULL RoadAttributionCategory::add_road()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::Road* _add = _internal_mutable_road()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>& RoadAttributionCategory::road() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return _internal_road();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>&
RoadAttributionCategory::_internal_road() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.road_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>* PROTOBUF_NONNULL
RoadAttributionCategory::_internal_mutable_road() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.road_;
}

// repeated .sensoris.protobuf.categories.roadattribution.SurfaceMarking surface_marking = 6;
inline int RoadAttributionCategory::_internal_surface_marking_size() const {
  return _internal_surface_marking().size();
}
inline int RoadAttributionCategory::surface_marking_size() const {
  return _internal_surface_marking_size();
}
inline void RoadAttributionCategory::clear_surface_marking() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.surface_marking_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* PROTOBUF_NONNULL RoadAttributionCategory::mutable_surface_marking(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return _internal_mutable_surface_marking()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>* PROTOBUF_NONNULL RoadAttributionCategory::mutable_surface_marking()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_surface_marking();
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking& RoadAttributionCategory::surface_marking(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return _internal_surface_marking().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* PROTOBUF_NONNULL RoadAttributionCategory::add_surface_marking()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* _add = _internal_mutable_surface_marking()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>& RoadAttributionCategory::surface_marking() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return _internal_surface_marking();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>&
RoadAttributionCategory::_internal_surface_marking() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.surface_marking_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>* PROTOBUF_NONNULL
RoadAttributionCategory::_internal_mutable_surface_marking() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.surface_marking_;
}

// repeated .sensoris.protobuf.categories.roadattribution.SurfaceAttribution surface_attribution = 7;
inline int RoadAttributionCategory::_internal_surface_attribution_size() const {
  return _internal_surface_attribution().size();
}
inline int RoadAttributionCategory::surface_attribution_size() const {
  return _internal_surface_attribution_size();
}
inline void RoadAttributionCategory::clear_surface_attribution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.surface_attribution_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* PROTOBUF_NONNULL RoadAttributionCategory::mutable_surface_attribution(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return _internal_mutable_surface_attribution()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>* PROTOBUF_NONNULL RoadAttributionCategory::mutable_surface_attribution()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_surface_attribution();
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution& RoadAttributionCategory::surface_attribution(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return _internal_surface_attribution().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* PROTOBUF_NONNULL RoadAttributionCategory::add_surface_attribution()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* _add = _internal_mutable_surface_attribution()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>& RoadAttributionCategory::surface_attribution() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return _internal_surface_attribution();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>&
RoadAttributionCategory::_internal_surface_attribution() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.surface_attribution_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>* PROTOBUF_NONNULL
RoadAttributionCategory::_internal_mutable_surface_attribution() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.surface_attribution_;
}

// repeated .sensoris.protobuf.categories.roadattribution.RoadAttribution road_attribution = 8;
inline int RoadAttributionCategory::_internal_road_attribution_size() const {
  return _internal_road_attribution().size();
}
inline int RoadAttributionCategory::road_attribution_size() const {
  return _internal_road_attribution_size();
}
inline void RoadAttributionCategory::clear_road_attribution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.road_attribution_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution* PROTOBUF_NONNULL RoadAttributionCategory::mutable_road_attribution(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return _internal_mutable_road_attribution()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>* PROTOBUF_NONNULL RoadAttributionCategory::mutable_road_attribution()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_road_attribution();
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution& RoadAttributionCategory::road_attribution(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return _internal_road_attribution().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution* PROTOBUF_NONNULL RoadAttributionCategory::add_road_attribution()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution* _add = _internal_mutable_road_attribution()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>& RoadAttributionCategory::road_attribution() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return _internal_road_attribution();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>&
RoadAttributionCategory::_internal_road_attribution() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.road_attribution_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>* PROTOBUF_NONNULL
RoadAttributionCategory::_internal_mutable_road_attribution() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.road_attribution_;
}

// repeated .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence detected_lane_count_and_confidence = 9;
inline int RoadAttributionCategory::_internal_detected_lane_count_and_confidence_size() const {
  return _internal_detected_lane_count_and_confidence().size();
}
inline int RoadAttributionCategory::detected_lane_count_and_confidence_size() const {
  return _internal_detected_lane_count_and_confidence_size();
}
inline void RoadAttributionCategory::clear_detected_lane_count_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detected_lane_count_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* PROTOBUF_NONNULL RoadAttributionCategory::mutable_detected_lane_count_and_confidence(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return _internal_mutable_detected_lane_count_and_confidence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>* PROTOBUF_NONNULL RoadAttributionCategory::mutable_detected_lane_count_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_detected_lane_count_and_confidence();
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence& RoadAttributionCategory::detected_lane_count_and_confidence(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return _internal_detected_lane_count_and_confidence().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* PROTOBUF_NONNULL RoadAttributionCategory::add_detected_lane_count_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* _add = _internal_mutable_detected_lane_count_and_confidence()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>& RoadAttributionCategory::detected_lane_count_and_confidence() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return _internal_detected_lane_count_and_confidence();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>&
RoadAttributionCategory::_internal_detected_lane_count_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.detected_lane_count_and_confidence_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>* PROTOBUF_NONNULL
RoadAttributionCategory::_internal_mutable_detected_lane_count_and_confidence() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.detected_lane_count_and_confidence_;
}

// repeated .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence estimated_lane_count_and_confidence = 10;
inline int RoadAttributionCategory::_internal_estimated_lane_count_and_confidence_size() const {
  return _internal_estimated_lane_count_and_confidence().size();
}
inline int RoadAttributionCategory::estimated_lane_count_and_confidence_size() const {
  return _internal_estimated_lane_count_and_confidence_size();
}
inline void RoadAttributionCategory::clear_estimated_lane_count_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.estimated_lane_count_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* PROTOBUF_NONNULL RoadAttributionCategory::mutable_estimated_lane_count_and_confidence(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return _internal_mutable_estimated_lane_count_and_confidence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>* PROTOBUF_NONNULL RoadAttributionCategory::mutable_estimated_lane_count_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_estimated_lane_count_and_confidence();
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence& RoadAttributionCategory::estimated_lane_count_and_confidence(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return _internal_estimated_lane_count_and_confidence().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* PROTOBUF_NONNULL RoadAttributionCategory::add_estimated_lane_count_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* _add = _internal_mutable_estimated_lane_count_and_confidence()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>& RoadAttributionCategory::estimated_lane_count_and_confidence() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return _internal_estimated_lane_count_and_confidence();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>&
RoadAttributionCategory::_internal_estimated_lane_count_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.estimated_lane_count_and_confidence_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>* PROTOBUF_NONNULL
RoadAttributionCategory::_internal_mutable_estimated_lane_count_and_confidence() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.estimated_lane_count_and_confidence_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace roadattribution
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto_2epb_2eh
