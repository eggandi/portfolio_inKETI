// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: sensoris/protobuf/types/spatial.proto
// Protobuf C++ Version: 6.31.1

#include "sensoris/protobuf/types/spatial.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace sensoris {
namespace protobuf {
namespace types {
namespace spatial {

inline constexpr XyzVectorAndAccuracy_StdDev::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        x_{nullptr},
        y_{nullptr},
        z_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR XyzVectorAndAccuracy_StdDev::XyzVectorAndAccuracy_StdDev(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(XyzVectorAndAccuracy_StdDev_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct XyzVectorAndAccuracy_StdDevDefaultTypeInternal {
  PROTOBUF_CONSTEXPR XyzVectorAndAccuracy_StdDevDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~XyzVectorAndAccuracy_StdDevDefaultTypeInternal() {}
  union {
    XyzVectorAndAccuracy_StdDev _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XyzVectorAndAccuracy_StdDevDefaultTypeInternal _XyzVectorAndAccuracy_StdDev_default_instance_;

inline constexpr RotationRateAndAccuracy_StdDev::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        yaw_{nullptr},
        pitch_{nullptr},
        roll_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RotationRateAndAccuracy_StdDev::RotationRateAndAccuracy_StdDev(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RotationRateAndAccuracy_StdDev_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RotationRateAndAccuracy_StdDevDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotationRateAndAccuracy_StdDevDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotationRateAndAccuracy_StdDevDefaultTypeInternal() {}
  union {
    RotationRateAndAccuracy_StdDev _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationRateAndAccuracy_StdDevDefaultTypeInternal _RotationRateAndAccuracy_StdDev_default_instance_;

inline constexpr RotationAndAccuracy_StdDev::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        yaw_{nullptr},
        pitch_{nullptr},
        roll_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RotationAndAccuracy_StdDev::RotationAndAccuracy_StdDev(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RotationAndAccuracy_StdDev_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RotationAndAccuracy_StdDevDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotationAndAccuracy_StdDevDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotationAndAccuracy_StdDevDefaultTypeInternal() {}
  union {
    RotationAndAccuracy_StdDev _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationAndAccuracy_StdDevDefaultTypeInternal _RotationAndAccuracy_StdDev_default_instance_;

inline constexpr PositionAndAccuracy_HorizontalVerticalStdDev::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        horizontal_{nullptr},
        vertical_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PositionAndAccuracy_HorizontalVerticalStdDev::PositionAndAccuracy_HorizontalVerticalStdDev(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PositionAndAccuracy_HorizontalVerticalStdDev_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal() {}
  union {
    PositionAndAccuracy_HorizontalVerticalStdDev _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal _PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_;

inline constexpr PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        horizontal_ellipse_major_{nullptr},
        horizontal_ellipse_minor_{nullptr},
        horizontal_ellipse_major_heading_{nullptr},
        vertical_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal() {}
  union {
    PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal _PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_;

inline constexpr MapLocationReference_TileIdObjectId::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        tile_id_{nullptr},
        object_id_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR MapLocationReference_TileIdObjectId::MapLocationReference_TileIdObjectId(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MapLocationReference_TileIdObjectId_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MapLocationReference_TileIdObjectIdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapLocationReference_TileIdObjectIdDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapLocationReference_TileIdObjectIdDefaultTypeInternal() {}
  union {
    MapLocationReference_TileIdObjectId _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapLocationReference_TileIdObjectIdDefaultTypeInternal _MapLocationReference_TileIdObjectId_default_instance_;

inline constexpr MapLocationReference_TileIdLinkIdOffset::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        tile_id_{nullptr},
        link_id_{nullptr},
        offset_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR MapLocationReference_TileIdLinkIdOffset::MapLocationReference_TileIdLinkIdOffset(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MapLocationReference_TileIdLinkIdOffset_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal() {}
  union {
    MapLocationReference_TileIdLinkIdOffset _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal _MapLocationReference_TileIdLinkIdOffset_default_instance_;

inline constexpr XyzVectorAndAccuracy_Metric::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        x_{nullptr},
        y_{nullptr},
        z_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR XyzVectorAndAccuracy_Metric::XyzVectorAndAccuracy_Metric(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(XyzVectorAndAccuracy_Metric_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct XyzVectorAndAccuracy_MetricDefaultTypeInternal {
  PROTOBUF_CONSTEXPR XyzVectorAndAccuracy_MetricDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~XyzVectorAndAccuracy_MetricDefaultTypeInternal() {}
  union {
    XyzVectorAndAccuracy_Metric _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XyzVectorAndAccuracy_MetricDefaultTypeInternal _XyzVectorAndAccuracy_Metric_default_instance_;

inline constexpr RotationRateAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        yaw_{nullptr},
        pitch_{nullptr},
        roll_{nullptr},
        accuracy_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR RotationRateAndAccuracy::RotationRateAndAccuracy(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RotationRateAndAccuracy_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RotationRateAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotationRateAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotationRateAndAccuracyDefaultTypeInternal() {}
  union {
    RotationRateAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationRateAndAccuracyDefaultTypeInternal _RotationRateAndAccuracy_default_instance_;

inline constexpr RotationAndAccuracy_Quaternion::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        x_{nullptr},
        y_{nullptr},
        z_{nullptr},
        w_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RotationAndAccuracy_Quaternion::RotationAndAccuracy_Quaternion(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RotationAndAccuracy_Quaternion_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RotationAndAccuracy_QuaternionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotationAndAccuracy_QuaternionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotationAndAccuracy_QuaternionDefaultTypeInternal() {}
  union {
    RotationAndAccuracy_Quaternion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationAndAccuracy_QuaternionDefaultTypeInternal _RotationAndAccuracy_Quaternion_default_instance_;

inline constexpr RotationAndAccuracy_Euler::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        yaw_{nullptr},
        pitch_{nullptr},
        roll_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RotationAndAccuracy_Euler::RotationAndAccuracy_Euler(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RotationAndAccuracy_Euler_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RotationAndAccuracy_EulerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotationAndAccuracy_EulerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotationAndAccuracy_EulerDefaultTypeInternal() {}
  union {
    RotationAndAccuracy_Euler _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationAndAccuracy_EulerDefaultTypeInternal _RotationAndAccuracy_Euler_default_instance_;

inline constexpr PositionAndAccuracy_Metric::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        x_{nullptr},
        y_{nullptr},
        z_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PositionAndAccuracy_Metric::PositionAndAccuracy_Metric(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PositionAndAccuracy_Metric_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PositionAndAccuracy_MetricDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionAndAccuracy_MetricDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionAndAccuracy_MetricDefaultTypeInternal() {}
  union {
    PositionAndAccuracy_Metric _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionAndAccuracy_MetricDefaultTypeInternal _PositionAndAccuracy_Metric_default_instance_;

inline constexpr PositionAndAccuracy_Geographic::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        longitude_{nullptr},
        latitude_{nullptr},
        altitude_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PositionAndAccuracy_Geographic::PositionAndAccuracy_Geographic(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PositionAndAccuracy_Geographic_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PositionAndAccuracy_GeographicDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionAndAccuracy_GeographicDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionAndAccuracy_GeographicDefaultTypeInternal() {}
  union {
    PositionAndAccuracy_Geographic _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionAndAccuracy_GeographicDefaultTypeInternal _PositionAndAccuracy_Geographic_default_instance_;

inline constexpr XyzVectorAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : extension_{},
        geometry_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR XyzVectorAndAccuracy::XyzVectorAndAccuracy(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(XyzVectorAndAccuracy_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct XyzVectorAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR XyzVectorAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~XyzVectorAndAccuracyDefaultTypeInternal() {}
  union {
    XyzVectorAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XyzVectorAndAccuracyDefaultTypeInternal _XyzVectorAndAccuracy_default_instance_;

inline constexpr RotationAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : extension_{},
        euler_quaternion_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR RotationAndAccuracy::RotationAndAccuracy(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RotationAndAccuracy_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RotationAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotationAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotationAndAccuracyDefaultTypeInternal() {}
  union {
    RotationAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationAndAccuracyDefaultTypeInternal _RotationAndAccuracy_default_instance_;

inline constexpr PositionAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : extension_{},
        geographic_metric_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR PositionAndAccuracy::PositionAndAccuracy(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PositionAndAccuracy_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PositionAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionAndAccuracyDefaultTypeInternal() {}
  union {
    PositionAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionAndAccuracyDefaultTypeInternal _PositionAndAccuracy_default_instance_;

inline constexpr RectangularBoxAndAccuracy_CornerVectors::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        first_and_accuracy_{nullptr},
        second_and_accuracy_{nullptr},
        third_and_accuracy_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy_CornerVectors::RectangularBoxAndAccuracy_CornerVectors(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RectangularBoxAndAccuracy_CornerVectors_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal() {}
  union {
    RectangularBoxAndAccuracy_CornerVectors _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal _RectangularBoxAndAccuracy_CornerVectors_default_instance_;

inline constexpr RectangularBoxAndAccuracy_CenterOrientationSize::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        center_position_and_accuracy_{nullptr},
        orientation_and_accuracy_{nullptr},
        size_and_accuracy_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy_CenterOrientationSize::RectangularBoxAndAccuracy_CenterOrientationSize(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RectangularBoxAndAccuracy_CenterOrientationSize_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal() {}
  union {
    RectangularBoxAndAccuracy_CenterOrientationSize _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal _RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_;

inline constexpr RectangleAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        minimum_position_and_accuracy_{nullptr},
        maximum_position_and_accuracy_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RectangleAndAccuracy::RectangleAndAccuracy(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RectangleAndAccuracy_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RectangleAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RectangleAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RectangleAndAccuracyDefaultTypeInternal() {}
  union {
    RectangleAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RectangleAndAccuracyDefaultTypeInternal _RectangleAndAccuracy_default_instance_;

inline constexpr PolylineAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : position_and_accuracy_{},
        extension_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR PolylineAndAccuracy::PolylineAndAccuracy(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PolylineAndAccuracy_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PolylineAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolylineAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolylineAndAccuracyDefaultTypeInternal() {}
  union {
    PolylineAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolylineAndAccuracyDefaultTypeInternal _PolylineAndAccuracy_default_instance_;

inline constexpr PolygonAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : position_and_accuracy_{},
        extension_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR PolygonAndAccuracy::PolygonAndAccuracy(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PolygonAndAccuracy_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PolygonAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolygonAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolygonAndAccuracyDefaultTypeInternal() {}
  union {
    PolygonAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolygonAndAccuracyDefaultTypeInternal _PolygonAndAccuracy_default_instance_;

inline constexpr MapLocationReference::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        position_and_accuracy_{nullptr},
        z_level_{nullptr},
        map_based_reference_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR MapLocationReference::MapLocationReference(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MapLocationReference_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MapLocationReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapLocationReferenceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapLocationReferenceDefaultTypeInternal() {}
  union {
    MapLocationReference _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapLocationReferenceDefaultTypeInternal _MapLocationReference_default_instance_;

inline constexpr CircleAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        center_position_and_accuracy_{nullptr},
        radius_and_accuracy_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR CircleAndAccuracy::CircleAndAccuracy(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CircleAndAccuracy_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CircleAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CircleAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CircleAndAccuracyDefaultTypeInternal() {}
  union {
    CircleAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CircleAndAccuracyDefaultTypeInternal _CircleAndAccuracy_default_instance_;

inline constexpr RectangularBoxAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : extension_{},
        geometry_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy::RectangularBoxAndAccuracy(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RectangularBoxAndAccuracy_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RectangularBoxAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RectangularBoxAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RectangularBoxAndAccuracyDefaultTypeInternal() {}
  union {
    RectangularBoxAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RectangularBoxAndAccuracyDefaultTypeInternal _RectangularBoxAndAccuracy_default_instance_;

inline constexpr PolylineCorridorAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        center_polyline_and_accuracy_{nullptr},
        total_width_and_accuracy_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PolylineCorridorAndAccuracy::PolylineCorridorAndAccuracy(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PolylineCorridorAndAccuracy_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PolylineCorridorAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolylineCorridorAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolylineCorridorAndAccuracyDefaultTypeInternal() {}
  union {
    PolylineCorridorAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolylineCorridorAndAccuracyDefaultTypeInternal _PolylineCorridorAndAccuracy_default_instance_;

inline constexpr DirectedPolylineCorridor::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        polyline_corridor_{nullptr},
        is_bidirectional_{nullptr},
        heading_deviation_from_center_line_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR DirectedPolylineCorridor::DirectedPolylineCorridor(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DirectedPolylineCorridor_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DirectedPolylineCorridorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DirectedPolylineCorridorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DirectedPolylineCorridorDefaultTypeInternal() {}
  union {
    DirectedPolylineCorridor _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DirectedPolylineCorridorDefaultTypeInternal _DirectedPolylineCorridor_default_instance_;
}  // namespace spatial
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris
static constexpr const ::_pb::EnumDescriptor *PROTOBUF_NONNULL *PROTOBUF_NULLABLE
    file_level_enum_descriptors_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor *PROTOBUF_NONNULL *PROTOBUF_NULLABLE
    file_level_service_descriptors_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto = nullptr;
const ::uint32_t
    TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic, _impl_.longitude_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic, _impl_.latitude_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic, _impl_.altitude_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric, _impl_.x_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric, _impl_.y_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric, _impl_.z_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.horizontal_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.vertical_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_minor_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_heading_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.vertical_),
        0,
        1,
        2,
        3,
        0x004, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy, _impl_._oneof_case_[0]),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy, _impl_.extension_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy, _impl_.geographic_metric_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy, _impl_.accuracy_),
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineAndAccuracy, _impl_.position_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineAndAccuracy, _impl_.extension_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy, _impl_.center_polyline_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy, _impl_.total_width_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy, _impl_.extension_),
        0,
        1,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor, _impl_.polyline_corridor_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor, _impl_.is_bidirectional_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor, _impl_.heading_deviation_from_center_line_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor, _impl_.extension_),
        0,
        1,
        2,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::CircleAndAccuracy, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::CircleAndAccuracy, _impl_.center_position_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::CircleAndAccuracy, _impl_.radius_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::CircleAndAccuracy, _impl_.extension_),
        0,
        1,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangleAndAccuracy, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangleAndAccuracy, _impl_.minimum_position_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangleAndAccuracy, _impl_.maximum_position_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangleAndAccuracy, _impl_.extension_),
        0,
        1,
        ~0u,
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolygonAndAccuracy, _impl_.position_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolygonAndAccuracy, _impl_.extension_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev, _impl_.x_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev, _impl_.y_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev, _impl_.z_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric, _impl_.x_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric, _impl_.y_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric, _impl_.z_),
        0,
        1,
        2,
        0x004, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy, _impl_._oneof_case_[0]),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy, _impl_.extension_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy, _impl_.geometry_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy, _impl_.accuracy_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors, _impl_.first_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors, _impl_.second_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors, _impl_.third_and_accuracy_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.center_position_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.orientation_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.size_and_accuracy_),
        0,
        1,
        2,
        0x004, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy, _impl_._oneof_case_[0]),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy, _impl_.extension_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy, _impl_.geometry_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler, _impl_.yaw_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler, _impl_.pitch_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler, _impl_.roll_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion, _impl_.x_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion, _impl_.y_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion, _impl_.z_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion, _impl_.w_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev, _impl_.yaw_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev, _impl_.pitch_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev, _impl_.roll_),
        0,
        1,
        2,
        0x004, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy, _impl_._oneof_case_[0]),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy, _impl_.extension_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy, _impl_.euler_quaternion_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy, _impl_.accuracy_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev, _impl_.yaw_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev, _impl_.pitch_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev, _impl_.roll_),
        0,
        1,
        2,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_._oneof_case_[0]),
        12, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_.yaw_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_.pitch_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_.roll_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_.extension_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_.accuracy_),
        0,
        1,
        2,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset, _impl_.tile_id_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset, _impl_.link_id_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset, _impl_.offset_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset, _impl_.extension_),
        0,
        1,
        2,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId, _impl_.tile_id_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId, _impl_.object_id_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId, _impl_.extension_),
        0,
        1,
        ~0u,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_._oneof_case_[0]),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_.position_and_accuracy_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_.z_level_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_.extension_),
        PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_.map_based_reference_),
        0,
        1,
        ~0u,
        ~0u,
        ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, sizeof(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic)},
        {9, sizeof(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric)},
        {18, sizeof(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev)},
        {25, sizeof(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev)},
        {36, sizeof(::sensoris::protobuf::types::spatial::PositionAndAccuracy)},
        {49, sizeof(::sensoris::protobuf::types::spatial::PolylineAndAccuracy)},
        {52, sizeof(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy)},
        {61, sizeof(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor)},
        {72, sizeof(::sensoris::protobuf::types::spatial::CircleAndAccuracy)},
        {81, sizeof(::sensoris::protobuf::types::spatial::RectangleAndAccuracy)},
        {90, sizeof(::sensoris::protobuf::types::spatial::PolygonAndAccuracy)},
        {93, sizeof(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev)},
        {102, sizeof(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric)},
        {111, sizeof(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy)},
        {122, sizeof(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors)},
        {131, sizeof(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize)},
        {140, sizeof(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy)},
        {146, sizeof(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler)},
        {155, sizeof(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion)},
        {166, sizeof(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev)},
        {175, sizeof(::sensoris::protobuf::types::spatial::RotationAndAccuracy)},
        {187, sizeof(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev)},
        {196, sizeof(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy)},
        {215, sizeof(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset)},
        {226, sizeof(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId)},
        {235, sizeof(::sensoris::protobuf::types::spatial::MapLocationReference)},
};
static const ::_pb::Message* PROTOBUF_NONNULL const file_default_instances[] = {
    &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Geographic_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Metric_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PolylineAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PolylineCorridorAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_DirectedPolylineCorridor_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_CircleAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RectangleAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PolygonAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_StdDev_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_Metric_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_CornerVectors_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Euler_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Quaternion_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RotationAndAccuracy_StdDev_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RotationAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RotationRateAndAccuracy_StdDev_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RotationRateAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_MapLocationReference_TileIdLinkIdOffset_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_MapLocationReference_TileIdObjectId_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_MapLocationReference_default_instance_._instance,
};
const char descriptor_table_protodef_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n%sensoris/protobuf/types/spatial.proto\022"
    "\037sensoris.protobuf.types.spatial\032\031google"
    "/protobuf/any.proto\032\036google/protobuf/wra"
    "ppers.proto\032\"sensoris/protobuf/types/bas"
    "e.proto\"\235\r\n\023PositionAndAccuracy\022[\n\020geogr"
    "aphic_wgs84\030\001 \001(\0132\?.sensoris.protobuf.ty"
    "pes.spatial.PositionAndAccuracy.Geograph"
    "icH\000\022U\n\016metric_vehicle\030\002 \001(\0132;.sensoris."
    "protobuf.types.spatial.PositionAndAccura"
    "cy.MetricH\000\022Y\n\022metric_event_group\030\003 \001(\0132"
    ";.sensoris.protobuf.types.spatial.Positi"
    "onAndAccuracy.MetricH\000\022R\n\013metric_ecef\030\004 "
    "\001(\0132;.sensoris.protobuf.types.spatial.Po"
    "sitionAndAccuracy.MetricH\000\022=\n\020combined_s"
    "td_dev\030\005 \001(\0132\033.google.protobuf.Int64Valu"
    "eB\004\210\265\030\000H\001\022`\n\007std_dev\030\006 \001(\0132M.sensoris.pr"
    "otobuf.types.spatial.PositionAndAccuracy"
    ".HorizontalVerticalStdDevH\001\022\230\001\n.horizont"
    "al_confidence_ellipse_vertical_std_dev\030\007"
    " \001(\0132^.sensoris.protobuf.types.spatial.P"
    "ositionAndAccuracy.HorizontalConfidenceE"
    "llipseVerticalStdDevH\001\022H\n\ncovariance\030\010 \001"
    "(\0132,.sensoris.protobuf.types.base.Int64M"
    "atrix3x3B\004\210\265\030\000H\001\022\'\n\textension\030\017 \003(\0132\024.go"
    "ogle.protobuf.Any\032\323\001\n\nGeographic\022A\n\tlong"
    "itude\030\001 \001(\0132(.sensoris.protobuf.types.ba"
    "se.Int64ValueB\004\210\265\030\010\022@\n\010latitude\030\002 \001(\0132(."
    "sensoris.protobuf.types.base.Int64ValueB"
    "\004\210\265\030\010\022@\n\010altitude\030\003 \001(\0132(.sensoris.proto"
    "buf.types.base.Int64ValueB\004\210\265\030\003\032\271\001\n\006Metr"
    "ic\0229\n\001x\030\001 \001(\0132(.sensoris.protobuf.types."
    "base.Int64ValueB\004\210\265\030\000\0229\n\001y\030\002 \001(\0132(.senso"
    "ris.protobuf.types.base.Int64ValueB\004\210\265\030\000"
    "\0229\n\001z\030\003 \001(\0132(.sensoris.protobuf.types.ba"
    "se.Int64ValueB\004\210\265\030\000\032\206\001\n\030HorizontalVertic"
    "alStdDev\0225\n\nhorizontal\030\001 \001(\0132\033.google.pr"
    "otobuf.Int64ValueB\004\210\265\030\000\0223\n\010vertical\030\002 \001("
    "\0132\033.google.protobuf.Int64ValueB\004\210\265\030\000\032\267\002\n"
    ")HorizontalConfidenceEllipseVerticalStdD"
    "ev\022C\n\030horizontal_ellipse_major\030\001 \001(\0132\033.g"
    "oogle.protobuf.Int64ValueB\004\210\265\030\000\022C\n\030horiz"
    "ontal_ellipse_minor\030\002 \001(\0132\033.google.proto"
    "buf.Int64ValueB\004\210\265\030\000\022K\n horizontal_ellip"
    "se_major_heading\030\003 \001(\0132\033.google.protobuf"
    ".Int64ValueB\004\210\265\030\002\0223\n\010vertical\030\004 \001(\0132\033.go"
    "ogle.protobuf.Int64ValueB\004\210\265\030\000B\023\n\021geogra"
    "phic_metricB\n\n\010accuracy\"\223\001\n\023PolylineAndA"
    "ccuracy\022S\n\025position_and_accuracy\030\001 \003(\01324"
    ".sensoris.protobuf.types.spatial.Positio"
    "nAndAccuracy\022\'\n\textension\030\017 \003(\0132\024.google"
    ".protobuf.Any\"\377\001\n\033PolylineCorridorAndAcc"
    "uracy\022Z\n\034center_polyline_and_accuracy\030\001 "
    "\001(\01324.sensoris.protobuf.types.spatial.Po"
    "lylineAndAccuracy\022[\n\030total_width_and_acc"
    "uracy\030\002 \001(\01323.sensoris.protobuf.types.ba"
    "se.Int64ValueAndAccuracyB\004\210\265\030\000\022\'\n\textens"
    "ion\030\017 \003(\0132\024.google.protobuf.Any\"\233\002\n\030Dire"
    "ctedPolylineCorridor\022W\n\021polyline_corrido"
    "r\030\001 \001(\0132<.sensoris.protobuf.types.spatia"
    "l.PolylineCorridorAndAccuracy\0224\n\020is_bidi"
    "rectional\030\002 \001(\0132\032.google.protobuf.BoolVa"
    "lue\022G\n\"heading_deviation_from_center_lin"
    "e\030\003 \001(\0132\033.google.protobuf.Int64Value\022\'\n\t"
    "extension\030\017 \003(\0132\024.google.protobuf.Any\"\360\001"
    "\n\021CircleAndAccuracy\022Z\n\034center_position_a"
    "nd_accuracy\030\001 \001(\01324.sensoris.protobuf.ty"
    "pes.spatial.PositionAndAccuracy\022V\n\023radiu"
    "s_and_accuracy\030\002 \001(\01323.sensoris.protobuf"
    ".types.base.Int64ValueAndAccuracyB\004\210\265\030\000\022"
    "\'\n\textension\030\017 \003(\0132\024.google.protobuf.Any"
    "\"\371\001\n\024RectangleAndAccuracy\022[\n\035minimum_pos"
    "ition_and_accuracy\030\001 \001(\01324.sensoris.prot"
    "obuf.types.spatial.PositionAndAccuracy\022["
    "\n\035maximum_position_and_accuracy\030\002 \001(\01324."
    "sensoris.protobuf.types.spatial.Position"
    "AndAccuracy\022\'\n\textension\030\017 \003(\0132\024.google."
    "protobuf.Any\"\222\001\n\022PolygonAndAccuracy\022S\n\025p"
    "osition_and_accuracy\030\001 \003(\01324.sensoris.pr"
    "otobuf.types.spatial.PositionAndAccuracy"
    "\022\'\n\textension\030\017 \003(\0132\024.google.protobuf.An"
    "y\"\335\006\n\024XyzVectorAndAccuracy\022V\n\016metric_veh"
    "icle\030\001 \001(\0132<.sensoris.protobuf.types.spa"
    "tial.XyzVectorAndAccuracy.MetricH\000\022Z\n\022me"
    "tric_event_group\030\002 \001(\0132<.sensoris.protob"
    "uf.types.spatial.XyzVectorAndAccuracy.Me"
    "tricH\000\022U\n\rmetric_origin\030\003 \001(\0132<.sensoris"
    ".protobuf.types.spatial.XyzVectorAndAccu"
    "racy.MetricH\000\0227\n\020combined_std_dev\030\004 \001(\0132"
    "\033.google.protobuf.Int64ValueH\001\022O\n\007std_de"
    "v\030\005 \001(\0132<.sensoris.protobuf.types.spatia"
    "l.XyzVectorAndAccuracy.StdDevH\001\022B\n\ncovar"
    "iance\030\006 \001(\0132,.sensoris.protobuf.types.ba"
    "se.Int64Matrix3x3H\001\022\'\n\textension\030\017 \003(\0132\024"
    ".google.protobuf.Any\032\200\001\n\006StdDev\022&\n\001x\030\001 \001"
    "(\0132\033.google.protobuf.Int64Value\022&\n\001y\030\002 \001"
    "(\0132\033.google.protobuf.Int64Value\022&\n\001z\030\003 \001"
    "(\0132\033.google.protobuf.Int64Value\032\247\001\n\006Metr"
    "ic\0223\n\001x\030\001 \001(\0132(.sensoris.protobuf.types."
    "base.Int64Value\0223\n\001y\030\002 \001(\0132(.sensoris.pr"
    "otobuf.types.base.Int64Value\0223\n\001z\030\003 \001(\0132"
    "(.sensoris.protobuf.types.base.Int64Valu"
    "eB\n\n\010geometryB\n\n\010accuracy\"\355\006\n\031Rectangula"
    "rBoxAndAccuracy\022b\n\016corner_vectors\030\001 \001(\0132"
    "H.sensoris.protobuf.types.spatial.Rectan"
    "gularBoxAndAccuracy.CornerVectorsH\000\022s\n\027c"
    "enter_orientation_size\030\002 \001(\0132P.sensoris."
    "protobuf.types.spatial.RectangularBoxAnd"
    "Accuracy.CenterOrientationSizeH\000\022\'\n\texte"
    "nsion\030\017 \003(\0132\024.google.protobuf.Any\032\233\002\n\rCo"
    "rnerVectors\022W\n\022first_and_accuracy\030\001 \001(\0132"
    "5.sensoris.protobuf.types.spatial.XyzVec"
    "torAndAccuracyB\004\210\265\030\000\022X\n\023second_and_accur"
    "acy\030\002 \001(\01325.sensoris.protobuf.types.spat"
    "ial.XyzVectorAndAccuracyB\004\210\265\030\000\022W\n\022third_"
    "and_accuracy\030\003 \001(\01325.sensoris.protobuf.t"
    "ypes.spatial.XyzVectorAndAccuracyB\004\210\265\030\000\032"
    "\243\002\n\025CenterOrientationSize\022Z\n\034center_posi"
    "tion_and_accuracy\030\001 \001(\01324.sensoris.proto"
    "buf.types.spatial.PositionAndAccuracy\022V\n"
    "\030orientation_and_accuracy\030\002 \001(\01324.sensor"
    "is.protobuf.types.spatial.RotationAndAcc"
    "uracy\022V\n\021size_and_accuracy\030\003 \001(\01325.senso"
    "ris.protobuf.types.spatial.XyzVectorAndA"
    "ccuracyB\004\210\265\030\000B\n\n\010geometry\"\204\n\n\023RotationAn"
    "dAccuracy\022S\n\reuler_vehicle\030\001 \001(\0132:.senso"
    "ris.protobuf.types.spatial.RotationAndAc"
    "curacy.EulerH\000\022W\n\021euler_event_group\030\002 \001("
    "\0132:.sensoris.protobuf.types.spatial.Rota"
    "tionAndAccuracy.EulerH\000\022]\n\022quaternion_ve"
    "hicle\030\003 \001(\0132\?.sensoris.protobuf.types.sp"
    "atial.RotationAndAccuracy.QuaternionH\000\022a"
    "\n\026quaternion_event_group\030\004 \001(\0132\?.sensori"
    "s.protobuf.types.spatial.RotationAndAccu"
    "racy.QuaternionH\000\022=\n\020combined_std_dev\030\005 "
    "\001(\0132\033.google.protobuf.Int64ValueB\004\210\265\030\002H\001"
    "\022N\n\007std_dev\030\006 \001(\0132;.sensoris.protobuf.ty"
    "pes.spatial.RotationAndAccuracy.StdDevH\001"
    "\022H\n\ncovariance\030\007 \001(\0132,.sensoris.protobuf"
    ".types.base.Int64Matrix3x3B\004\210\265\030\002H\001\022\'\n\tex"
    "tension\030\017 \003(\0132\024.google.protobuf.Any\032\301\001\n\005"
    "Euler\022;\n\003yaw\030\001 \001(\0132(.sensoris.protobuf.t"
    "ypes.base.Int64ValueB\004\210\265\030\002\022=\n\005pitch\030\002 \001("
    "\0132(.sensoris.protobuf.types.base.Int64Va"
    "lueB\004\210\265\030\002\022<\n\004roll\030\003 \001(\0132(.sensoris.proto"
    "buf.types.base.Int64ValueB\004\210\265\030\002\032\370\001\n\nQuat"
    "ernion\0229\n\001x\030\001 \001(\0132(.sensoris.protobuf.ty"
    "pes.base.Int64ValueB\004\210\265\030\003\0229\n\001y\030\002 \001(\0132(.s"
    "ensoris.protobuf.types.base.Int64ValueB\004"
    "\210\265\030\003\0229\n\001z\030\003 \001(\0132(.sensoris.protobuf.type"
    "s.base.Int64ValueB\004\210\265\030\003\0229\n\001w\030\004 \001(\0132(.sen"
    "soris.protobuf.types.base.Int64ValueB\004\210\265"
    "\030\003\032\233\001\n\006StdDev\022.\n\003yaw\030\001 \001(\0132\033.google.prot"
    "obuf.Int64ValueB\004\210\265\030\002\0220\n\005pitch\030\002 \001(\0132\033.g"
    "oogle.protobuf.Int64ValueB\004\210\265\030\002\022/\n\004roll\030"
    "\003 \001(\0132\033.google.protobuf.Int64ValueB\004\210\265\030\002"
    "B\022\n\020euler_quaternionB\n\n\010accuracy\"\203\005\n\027Rot"
    "ationRateAndAccuracy\022;\n\003yaw\030\001 \001(\0132(.sens"
    "oris.protobuf.types.base.Int64ValueB\004\210\265\030"
    "\002\022=\n\005pitch\030\002 \001(\0132(.sensoris.protobuf.typ"
    "es.base.Int64ValueB\004\210\265\030\002\022<\n\004roll\030\003 \001(\0132("
    ".sensoris.protobuf.types.base.Int64Value"
    "B\004\210\265\030\002\022=\n\020combined_std_dev\030\004 \001(\0132\033.googl"
    "e.protobuf.Int64ValueB\004\210\265\030\002H\000\022R\n\007std_dev"
    "\030\005 \001(\0132\?.sensoris.protobuf.types.spatial"
    ".RotationRateAndAccuracy.StdDevH\000\022H\n\ncov"
    "ariance\030\006 \001(\0132,.sensoris.protobuf.types."
    "base.Int64Matrix3x3B\004\210\265\030\002H\000\022\'\n\textension"
    "\030\017 \003(\0132\024.google.protobuf.Any\032\233\001\n\006StdDev\022"
    ".\n\003yaw\030\001 \001(\0132\033.google.protobuf.Int64Valu"
    "eB\004\210\265\030\002\0220\n\005pitch\030\002 \001(\0132\033.google.protobuf"
    ".Int64ValueB\004\210\265\030\002\022/\n\004roll\030\003 \001(\0132\033.google"
    ".protobuf.Int64ValueB\004\210\265\030\002B\n\n\010accuracy\"\221"
    "\006\n\024MapLocationReference\022S\n\025position_and_"
    "accuracy\030\001 \001(\01324.sensoris.protobuf.types"
    ".spatial.PositionAndAccuracy\022,\n\007z_level\030"
    "\002 \001(\0132\033.google.protobuf.Int64Value\022n\n\032ti"
    "le_link_offset_reference\030\003 \001(\0132H.sensori"
    "s.protobuf.types.spatial.MapLocationRefe"
    "rence.TileIdLinkIdOffsetH\000\022]\n\rmap_object"
    "_id\030\004 \001(\0132D.sensoris.protobuf.types.spat"
    "ial.MapLocationReference.TileIdObjectIdH"
    "\000\022\'\n\textension\030\017 \003(\0132\024.google.protobuf.A"
    "ny\032\314\001\n\022TileIdLinkIdOffset\022,\n\007tile_id\030\001 \001"
    "(\0132\033.google.protobuf.Int64Value\022,\n\007link_"
    "id\030\002 \001(\0132\033.google.protobuf.Int64Value\0221\n"
    "\006offset\030\003 \001(\0132\033.google.protobuf.Int64Val"
    "ueB\004\210\265\030\000\022\'\n\textension\030\017 \003(\0132\024.google.pro"
    "tobuf.Any\032\227\001\n\016TileIdObjectId\022,\n\007tile_id\030"
    "\001 \001(\0132\033.google.protobuf.Int64Value\022.\n\tob"
    "ject_id\030\002 \001(\0132\033.google.protobuf.Int64Val"
    "ue\022\'\n\textension\030\017 \003(\0132\024.google.protobuf."
    "AnyB\025\n\023map_based_referenceBa\n\032org.sensor"
    "is.types.spatialB\024SensorisSpatialTypesP\001"
    "Z(sensoris.org/specification/types/spati"
    "al\370\001\001b\006proto3"
};
static const ::_pbi::DescriptorTable* PROTOBUF_NONNULL const
    descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_deps[3] = {
        &::descriptor_table_google_2fprotobuf_2fany_2eproto,
        &::descriptor_table_google_2fprotobuf_2fwrappers_2eproto,
        &::descriptor_table_sensoris_2fprotobuf_2ftypes_2fbase_2eproto,
};
static ::absl::once_flag descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto = {
    false,
    false,
    7773,
    descriptor_table_protodef_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
    "sensoris/protobuf/types/spatial.proto",
    &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
    descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_deps,
    3,
    26,
    schemas,
    file_default_instances,
    TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::offsets,
    file_level_enum_descriptors_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
    file_level_service_descriptors_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
};
namespace sensoris {
namespace protobuf {
namespace types {
namespace spatial {
// ===================================================================

class PositionAndAccuracy_Geographic::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PositionAndAccuracy_Geographic>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_._has_bits_);
};

void PositionAndAccuracy_Geographic::clear_longitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.longitude_ != nullptr) _impl_.longitude_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PositionAndAccuracy_Geographic::clear_latitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.latitude_ != nullptr) _impl_.latitude_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PositionAndAccuracy_Geographic::clear_altitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.altitude_ != nullptr) _impl_.altitude_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
PositionAndAccuracy_Geographic::PositionAndAccuracy_Geographic(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PositionAndAccuracy_Geographic_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
}
PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_Geographic::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

PositionAndAccuracy_Geographic::PositionAndAccuracy_Geographic(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PositionAndAccuracy_Geographic& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PositionAndAccuracy_Geographic_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PositionAndAccuracy_Geographic* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.longitude_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.longitude_)
                : nullptr;
  _impl_.latitude_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.latitude_)
                : nullptr;
  _impl_.altitude_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.altitude_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
}
PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_Geographic::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void PositionAndAccuracy_Geographic::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, longitude_),
           0,
           offsetof(Impl_, altitude_) -
               offsetof(Impl_, longitude_) +
               sizeof(Impl_::altitude_));
}
PositionAndAccuracy_Geographic::~PositionAndAccuracy_Geographic() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  SharedDtor(*this);
}
inline void PositionAndAccuracy_Geographic::SharedDtor(MessageLite& self) {
  PositionAndAccuracy_Geographic& this_ = static_cast<PositionAndAccuracy_Geographic&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.longitude_;
  delete this_._impl_.latitude_;
  delete this_._impl_.altitude_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PositionAndAccuracy_Geographic::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PositionAndAccuracy_Geographic(arena);
}
constexpr auto PositionAndAccuracy_Geographic::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(PositionAndAccuracy_Geographic),
                                            alignof(PositionAndAccuracy_Geographic));
}
constexpr auto PositionAndAccuracy_Geographic::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PositionAndAccuracy_Geographic_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PositionAndAccuracy_Geographic::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PositionAndAccuracy_Geographic>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PositionAndAccuracy_Geographic::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PositionAndAccuracy_Geographic>(), &PositionAndAccuracy_Geographic::ByteSizeLong,
              &PositionAndAccuracy_Geographic::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_._cached_size_),
          false,
      },
      &PositionAndAccuracy_Geographic::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_Geographic_class_data_ =
        PositionAndAccuracy_Geographic::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PositionAndAccuracy_Geographic::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PositionAndAccuracy_Geographic_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PositionAndAccuracy_Geographic_class_data_.tc_table);
  return PositionAndAccuracy_Geographic_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
PositionAndAccuracy_Geographic::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PositionAndAccuracy_Geographic_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.longitude_)}},
    // .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.latitude_)}},
    // .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.altitude_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.longitude_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.latitude_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.altitude_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PositionAndAccuracy_Geographic::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.longitude_ != nullptr);
      _impl_.longitude_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.latitude_ != nullptr);
      _impl_.latitude_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.altitude_ != nullptr);
      _impl_.altitude_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PositionAndAccuracy_Geographic::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PositionAndAccuracy_Geographic& this_ = static_cast<const PositionAndAccuracy_Geographic&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PositionAndAccuracy_Geographic::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PositionAndAccuracy_Geographic& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.longitude_, this_._impl_.longitude_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.latitude_, this_._impl_.latitude_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.altitude_, this_._impl_.altitude_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PositionAndAccuracy_Geographic::ByteSizeLong(const MessageLite& base) {
  const PositionAndAccuracy_Geographic& this_ = static_cast<const PositionAndAccuracy_Geographic&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PositionAndAccuracy_Geographic::ByteSizeLong() const {
  const PositionAndAccuracy_Geographic& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.longitude_);
    }
    // .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.latitude_);
    }
    // .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.altitude_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PositionAndAccuracy_Geographic::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PositionAndAccuracy_Geographic*>(&to_msg);
  auto& from = static_cast<const PositionAndAccuracy_Geographic&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.longitude_ != nullptr);
      if (_this->_impl_.longitude_ == nullptr) {
        _this->_impl_.longitude_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.longitude_);
      } else {
        _this->_impl_.longitude_->MergeFrom(*from._impl_.longitude_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.latitude_ != nullptr);
      if (_this->_impl_.latitude_ == nullptr) {
        _this->_impl_.latitude_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.latitude_);
      } else {
        _this->_impl_.latitude_->MergeFrom(*from._impl_.latitude_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.altitude_ != nullptr);
      if (_this->_impl_.altitude_ == nullptr) {
        _this->_impl_.altitude_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.altitude_);
      } else {
        _this->_impl_.altitude_->MergeFrom(*from._impl_.altitude_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PositionAndAccuracy_Geographic::CopyFrom(const PositionAndAccuracy_Geographic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PositionAndAccuracy_Geographic::InternalSwap(PositionAndAccuracy_Geographic* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.altitude_)
      + sizeof(PositionAndAccuracy_Geographic::_impl_.altitude_)
      - PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.longitude_)>(
          reinterpret_cast<char*>(&_impl_.longitude_),
          reinterpret_cast<char*>(&other->_impl_.longitude_));
}

::google::protobuf::Metadata PositionAndAccuracy_Geographic::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PositionAndAccuracy_Metric::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PositionAndAccuracy_Metric>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_._has_bits_);
};

void PositionAndAccuracy_Metric::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ != nullptr) _impl_.x_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PositionAndAccuracy_Metric::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ != nullptr) _impl_.y_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PositionAndAccuracy_Metric::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ != nullptr) _impl_.z_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
PositionAndAccuracy_Metric::PositionAndAccuracy_Metric(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PositionAndAccuracy_Metric_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
}
PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_Metric::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

PositionAndAccuracy_Metric::PositionAndAccuracy_Metric(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PositionAndAccuracy_Metric& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PositionAndAccuracy_Metric_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PositionAndAccuracy_Metric* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.x_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.x_)
                : nullptr;
  _impl_.y_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.y_)
                : nullptr;
  _impl_.z_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.z_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
}
PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_Metric::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void PositionAndAccuracy_Metric::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, z_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::z_));
}
PositionAndAccuracy_Metric::~PositionAndAccuracy_Metric() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  SharedDtor(*this);
}
inline void PositionAndAccuracy_Metric::SharedDtor(MessageLite& self) {
  PositionAndAccuracy_Metric& this_ = static_cast<PositionAndAccuracy_Metric&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.x_;
  delete this_._impl_.y_;
  delete this_._impl_.z_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PositionAndAccuracy_Metric::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PositionAndAccuracy_Metric(arena);
}
constexpr auto PositionAndAccuracy_Metric::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(PositionAndAccuracy_Metric),
                                            alignof(PositionAndAccuracy_Metric));
}
constexpr auto PositionAndAccuracy_Metric::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PositionAndAccuracy_Metric_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PositionAndAccuracy_Metric::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PositionAndAccuracy_Metric>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PositionAndAccuracy_Metric::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PositionAndAccuracy_Metric>(), &PositionAndAccuracy_Metric::ByteSizeLong,
              &PositionAndAccuracy_Metric::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_._cached_size_),
          false,
      },
      &PositionAndAccuracy_Metric::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_Metric_class_data_ =
        PositionAndAccuracy_Metric::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PositionAndAccuracy_Metric::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PositionAndAccuracy_Metric_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PositionAndAccuracy_Metric_class_data_.tc_table);
  return PositionAndAccuracy_Metric_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
PositionAndAccuracy_Metric::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PositionAndAccuracy_Metric_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.x_)}},
    // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.y_)}},
    // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.x_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.y_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.z_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PositionAndAccuracy_Metric::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.x_ != nullptr);
      _impl_.x_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.y_ != nullptr);
      _impl_.y_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.z_ != nullptr);
      _impl_.z_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PositionAndAccuracy_Metric::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PositionAndAccuracy_Metric& this_ = static_cast<const PositionAndAccuracy_Metric&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PositionAndAccuracy_Metric::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PositionAndAccuracy_Metric& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.x_, this_._impl_.x_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.y_, this_._impl_.y_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.z_, this_._impl_.z_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PositionAndAccuracy_Metric::ByteSizeLong(const MessageLite& base) {
  const PositionAndAccuracy_Metric& this_ = static_cast<const PositionAndAccuracy_Metric&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PositionAndAccuracy_Metric::ByteSizeLong() const {
  const PositionAndAccuracy_Metric& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.x_);
    }
    // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.y_);
    }
    // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.z_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PositionAndAccuracy_Metric::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PositionAndAccuracy_Metric*>(&to_msg);
  auto& from = static_cast<const PositionAndAccuracy_Metric&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.x_ != nullptr);
      if (_this->_impl_.x_ == nullptr) {
        _this->_impl_.x_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.x_);
      } else {
        _this->_impl_.x_->MergeFrom(*from._impl_.x_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.y_ != nullptr);
      if (_this->_impl_.y_ == nullptr) {
        _this->_impl_.y_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.y_);
      } else {
        _this->_impl_.y_->MergeFrom(*from._impl_.y_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.z_ != nullptr);
      if (_this->_impl_.z_ == nullptr) {
        _this->_impl_.z_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.z_);
      } else {
        _this->_impl_.z_->MergeFrom(*from._impl_.z_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PositionAndAccuracy_Metric::CopyFrom(const PositionAndAccuracy_Metric& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PositionAndAccuracy_Metric::InternalSwap(PositionAndAccuracy_Metric* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.z_)
      + sizeof(PositionAndAccuracy_Metric::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata PositionAndAccuracy_Metric::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PositionAndAccuracy_HorizontalVerticalStdDev::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PositionAndAccuracy_HorizontalVerticalStdDev>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_._has_bits_);
};

void PositionAndAccuracy_HorizontalVerticalStdDev::clear_horizontal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.horizontal_ != nullptr) _impl_.horizontal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PositionAndAccuracy_HorizontalVerticalStdDev::clear_vertical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vertical_ != nullptr) _impl_.vertical_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
PositionAndAccuracy_HorizontalVerticalStdDev::PositionAndAccuracy_HorizontalVerticalStdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PositionAndAccuracy_HorizontalVerticalStdDev_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
}
PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_HorizontalVerticalStdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

PositionAndAccuracy_HorizontalVerticalStdDev::PositionAndAccuracy_HorizontalVerticalStdDev(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PositionAndAccuracy_HorizontalVerticalStdDev& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PositionAndAccuracy_HorizontalVerticalStdDev_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PositionAndAccuracy_HorizontalVerticalStdDev* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.horizontal_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.horizontal_)
                : nullptr;
  _impl_.vertical_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.vertical_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
}
PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_HorizontalVerticalStdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void PositionAndAccuracy_HorizontalVerticalStdDev::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, horizontal_),
           0,
           offsetof(Impl_, vertical_) -
               offsetof(Impl_, horizontal_) +
               sizeof(Impl_::vertical_));
}
PositionAndAccuracy_HorizontalVerticalStdDev::~PositionAndAccuracy_HorizontalVerticalStdDev() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  SharedDtor(*this);
}
inline void PositionAndAccuracy_HorizontalVerticalStdDev::SharedDtor(MessageLite& self) {
  PositionAndAccuracy_HorizontalVerticalStdDev& this_ = static_cast<PositionAndAccuracy_HorizontalVerticalStdDev&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.horizontal_;
  delete this_._impl_.vertical_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalVerticalStdDev::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PositionAndAccuracy_HorizontalVerticalStdDev(arena);
}
constexpr auto PositionAndAccuracy_HorizontalVerticalStdDev::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(PositionAndAccuracy_HorizontalVerticalStdDev),
                                            alignof(PositionAndAccuracy_HorizontalVerticalStdDev));
}
constexpr auto PositionAndAccuracy_HorizontalVerticalStdDev::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PositionAndAccuracy_HorizontalVerticalStdDev::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PositionAndAccuracy_HorizontalVerticalStdDev>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PositionAndAccuracy_HorizontalVerticalStdDev::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PositionAndAccuracy_HorizontalVerticalStdDev>(), &PositionAndAccuracy_HorizontalVerticalStdDev::ByteSizeLong,
              &PositionAndAccuracy_HorizontalVerticalStdDev::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_._cached_size_),
          false,
      },
      &PositionAndAccuracy_HorizontalVerticalStdDev::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_HorizontalVerticalStdDev_class_data_ =
        PositionAndAccuracy_HorizontalVerticalStdDev::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PositionAndAccuracy_HorizontalVerticalStdDev::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PositionAndAccuracy_HorizontalVerticalStdDev_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PositionAndAccuracy_HorizontalVerticalStdDev_class_data_.tc_table);
  return PositionAndAccuracy_HorizontalVerticalStdDev_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2>
PositionAndAccuracy_HorizontalVerticalStdDev::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PositionAndAccuracy_HorizontalVerticalStdDev_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.vertical_)}},
    // .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.horizontal_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.horizontal_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.vertical_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PositionAndAccuracy_HorizontalVerticalStdDev::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.horizontal_ != nullptr);
      _impl_.horizontal_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.vertical_ != nullptr);
      _impl_.vertical_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalVerticalStdDev::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PositionAndAccuracy_HorizontalVerticalStdDev& this_ = static_cast<const PositionAndAccuracy_HorizontalVerticalStdDev&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalVerticalStdDev::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PositionAndAccuracy_HorizontalVerticalStdDev& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.horizontal_, this_._impl_.horizontal_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.vertical_, this_._impl_.vertical_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PositionAndAccuracy_HorizontalVerticalStdDev::ByteSizeLong(const MessageLite& base) {
  const PositionAndAccuracy_HorizontalVerticalStdDev& this_ = static_cast<const PositionAndAccuracy_HorizontalVerticalStdDev&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PositionAndAccuracy_HorizontalVerticalStdDev::ByteSizeLong() const {
  const PositionAndAccuracy_HorizontalVerticalStdDev& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.horizontal_);
    }
    // .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.vertical_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PositionAndAccuracy_HorizontalVerticalStdDev::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PositionAndAccuracy_HorizontalVerticalStdDev*>(&to_msg);
  auto& from = static_cast<const PositionAndAccuracy_HorizontalVerticalStdDev&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.horizontal_ != nullptr);
      if (_this->_impl_.horizontal_ == nullptr) {
        _this->_impl_.horizontal_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.horizontal_);
      } else {
        _this->_impl_.horizontal_->MergeFrom(*from._impl_.horizontal_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.vertical_ != nullptr);
      if (_this->_impl_.vertical_ == nullptr) {
        _this->_impl_.vertical_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.vertical_);
      } else {
        _this->_impl_.vertical_->MergeFrom(*from._impl_.vertical_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PositionAndAccuracy_HorizontalVerticalStdDev::CopyFrom(const PositionAndAccuracy_HorizontalVerticalStdDev& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PositionAndAccuracy_HorizontalVerticalStdDev::InternalSwap(PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.vertical_)
      + sizeof(PositionAndAccuracy_HorizontalVerticalStdDev::_impl_.vertical_)
      - PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.horizontal_)>(
          reinterpret_cast<char*>(&_impl_.horizontal_),
          reinterpret_cast<char*>(&other->_impl_.horizontal_));
}

::google::protobuf::Metadata PositionAndAccuracy_HorizontalVerticalStdDev::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_._has_bits_);
};

void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::clear_horizontal_ellipse_major() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.horizontal_ellipse_major_ != nullptr) _impl_.horizontal_ellipse_major_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::clear_horizontal_ellipse_minor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.horizontal_ellipse_minor_ != nullptr) _impl_.horizontal_ellipse_minor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::clear_horizontal_ellipse_major_heading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.horizontal_ellipse_major_heading_ != nullptr) _impl_.horizontal_ellipse_major_heading_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::clear_vertical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vertical_ != nullptr) _impl_.vertical_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
}
PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.horizontal_ellipse_major_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.horizontal_ellipse_major_)
                : nullptr;
  _impl_.horizontal_ellipse_minor_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.horizontal_ellipse_minor_)
                : nullptr;
  _impl_.horizontal_ellipse_major_heading_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.horizontal_ellipse_major_heading_)
                : nullptr;
  _impl_.vertical_ = ((cached_has_bits & 0x00000008u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.vertical_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
}
PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, horizontal_ellipse_major_),
           0,
           offsetof(Impl_, vertical_) -
               offsetof(Impl_, horizontal_ellipse_major_) +
               sizeof(Impl_::vertical_));
}
PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::~PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  SharedDtor(*this);
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::SharedDtor(MessageLite& self) {
  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& this_ = static_cast<PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.horizontal_ellipse_major_;
  delete this_._impl_.horizontal_ellipse_minor_;
  delete this_._impl_.horizontal_ellipse_major_heading_;
  delete this_._impl_.vertical_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(arena);
}
constexpr auto PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev),
                                            alignof(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev));
}
constexpr auto PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>(), &PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::ByteSizeLong,
              &PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_._cached_size_),
          false,
      },
      &PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_class_data_ =
        PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_class_data_.tc_table);
  return PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 4, 0, 2>
PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {34, 3, 3, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.vertical_)}},
    // .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_)}},
    // .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_minor_)}},
    // .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_heading_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_minor_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_heading_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.vertical_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.horizontal_ellipse_major_ != nullptr);
      _impl_.horizontal_ellipse_major_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.horizontal_ellipse_minor_ != nullptr);
      _impl_.horizontal_ellipse_minor_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.horizontal_ellipse_major_heading_ != nullptr);
      _impl_.horizontal_ellipse_major_heading_->Clear();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(_impl_.vertical_ != nullptr);
      _impl_.vertical_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& this_ = static_cast<const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.horizontal_ellipse_major_, this_._impl_.horizontal_ellipse_major_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.horizontal_ellipse_minor_, this_._impl_.horizontal_ellipse_minor_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.horizontal_ellipse_major_heading_, this_._impl_.horizontal_ellipse_major_heading_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.vertical_, this_._impl_.vertical_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::ByteSizeLong(const MessageLite& base) {
  const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& this_ = static_cast<const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::ByteSizeLong() const {
  const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.horizontal_ellipse_major_);
    }
    // .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.horizontal_ellipse_minor_);
    }
    // .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.horizontal_ellipse_major_heading_);
    }
    // .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.vertical_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev*>(&to_msg);
  auto& from = static_cast<const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.horizontal_ellipse_major_ != nullptr);
      if (_this->_impl_.horizontal_ellipse_major_ == nullptr) {
        _this->_impl_.horizontal_ellipse_major_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.horizontal_ellipse_major_);
      } else {
        _this->_impl_.horizontal_ellipse_major_->MergeFrom(*from._impl_.horizontal_ellipse_major_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.horizontal_ellipse_minor_ != nullptr);
      if (_this->_impl_.horizontal_ellipse_minor_ == nullptr) {
        _this->_impl_.horizontal_ellipse_minor_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.horizontal_ellipse_minor_);
      } else {
        _this->_impl_.horizontal_ellipse_minor_->MergeFrom(*from._impl_.horizontal_ellipse_minor_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.horizontal_ellipse_major_heading_ != nullptr);
      if (_this->_impl_.horizontal_ellipse_major_heading_ == nullptr) {
        _this->_impl_.horizontal_ellipse_major_heading_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.horizontal_ellipse_major_heading_);
      } else {
        _this->_impl_.horizontal_ellipse_major_heading_->MergeFrom(*from._impl_.horizontal_ellipse_major_heading_);
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(from._impl_.vertical_ != nullptr);
      if (_this->_impl_.vertical_ == nullptr) {
        _this->_impl_.vertical_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.vertical_);
      } else {
        _this->_impl_.vertical_->MergeFrom(*from._impl_.vertical_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::CopyFrom(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::InternalSwap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.vertical_)
      + sizeof(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_impl_.vertical_)
      - PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_)>(
          reinterpret_cast<char*>(&_impl_.horizontal_ellipse_major_),
          reinterpret_cast<char*>(&other->_impl_.horizontal_ellipse_major_));
}

::google::protobuf::Metadata PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PositionAndAccuracy::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy, _impl_._oneof_case_);
};

void PositionAndAccuracy::set_allocated_geographic_wgs84(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PROTOBUF_NULLABLE geographic_wgs84) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geographic_metric();
  if (geographic_wgs84) {
    ::google::protobuf::Arena* submessage_arena = geographic_wgs84->GetArena();
    if (message_arena != submessage_arena) {
      geographic_wgs84 = ::google::protobuf::internal::GetOwnedMessage(message_arena, geographic_wgs84, submessage_arena);
    }
    set_has_geographic_wgs84();
    _impl_.geographic_metric_.geographic_wgs84_ = geographic_wgs84;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
}
void PositionAndAccuracy::set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE metric_vehicle) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geographic_metric();
  if (metric_vehicle) {
    ::google::protobuf::Arena* submessage_arena = metric_vehicle->GetArena();
    if (message_arena != submessage_arena) {
      metric_vehicle = ::google::protobuf::internal::GetOwnedMessage(message_arena, metric_vehicle, submessage_arena);
    }
    set_has_metric_vehicle();
    _impl_.geographic_metric_.metric_vehicle_ = metric_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
}
void PositionAndAccuracy::set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE metric_event_group) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geographic_metric();
  if (metric_event_group) {
    ::google::protobuf::Arena* submessage_arena = metric_event_group->GetArena();
    if (message_arena != submessage_arena) {
      metric_event_group = ::google::protobuf::internal::GetOwnedMessage(message_arena, metric_event_group, submessage_arena);
    }
    set_has_metric_event_group();
    _impl_.geographic_metric_.metric_event_group_ = metric_event_group;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
}
void PositionAndAccuracy::set_allocated_metric_ecef(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE metric_ecef) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geographic_metric();
  if (metric_ecef) {
    ::google::protobuf::Arena* submessage_arena = metric_ecef->GetArena();
    if (message_arena != submessage_arena) {
      metric_ecef = ::google::protobuf::internal::GetOwnedMessage(message_arena, metric_ecef, submessage_arena);
    }
    set_has_metric_ecef();
    _impl_.geographic_metric_.metric_ecef_ = metric_ecef;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
}
void PositionAndAccuracy::set_allocated_combined_std_dev(::google::protobuf::Int64Value* PROTOBUF_NULLABLE combined_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (combined_std_dev) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(combined_std_dev)->GetArena();
    if (message_arena != submessage_arena) {
      combined_std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, combined_std_dev, submessage_arena);
    }
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = combined_std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
}
void PositionAndAccuracy::clear_combined_std_dev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kCombinedStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.combined_std_dev_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.combined_std_dev_);
    }
    clear_has_accuracy();
  }
}
void PositionAndAccuracy::set_allocated_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NULLABLE std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (std_dev) {
    ::google::protobuf::Arena* submessage_arena = std_dev->GetArena();
    if (message_arena != submessage_arena) {
      std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, std_dev, submessage_arena);
    }
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
}
void PositionAndAccuracy::set_allocated_horizontal_confidence_ellipse_vertical_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NULLABLE horizontal_confidence_ellipse_vertical_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (horizontal_confidence_ellipse_vertical_std_dev) {
    ::google::protobuf::Arena* submessage_arena = horizontal_confidence_ellipse_vertical_std_dev->GetArena();
    if (message_arena != submessage_arena) {
      horizontal_confidence_ellipse_vertical_std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, horizontal_confidence_ellipse_vertical_std_dev, submessage_arena);
    }
    set_has_horizontal_confidence_ellipse_vertical_std_dev();
    _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = horizontal_confidence_ellipse_vertical_std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
}
void PositionAndAccuracy::set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE covariance) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (covariance) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(covariance)->GetArena();
    if (message_arena != submessage_arena) {
      covariance = ::google::protobuf::internal::GetOwnedMessage(message_arena, covariance, submessage_arena);
    }
    set_has_covariance();
    _impl_.accuracy_.covariance_ = covariance;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
}
void PositionAndAccuracy::clear_covariance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kCovariance) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.covariance_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.covariance_);
    }
    clear_has_accuracy();
  }
}
void PositionAndAccuracy::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
PositionAndAccuracy::PositionAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PositionAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE PositionAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& from_msg)
      : extension_{visibility, arena, from.extension_},
        geographic_metric_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

PositionAndAccuracy::PositionAndAccuracy(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PositionAndAccuracy& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PositionAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PositionAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (geographic_metric_case()) {
    case GEOGRAPHIC_METRIC_NOT_SET:
      break;
      case kGeographicWgs84:
        _impl_.geographic_metric_.geographic_wgs84_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geographic_metric_.geographic_wgs84_);
        break;
      case kMetricVehicle:
        _impl_.geographic_metric_.metric_vehicle_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geographic_metric_.metric_vehicle_);
        break;
      case kMetricEventGroup:
        _impl_.geographic_metric_.metric_event_group_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geographic_metric_.metric_event_group_);
        break;
      case kMetricEcef:
        _impl_.geographic_metric_.metric_ecef_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geographic_metric_.metric_ecef_);
        break;
  }
  switch (accuracy_case()) {
    case ACCURACY_NOT_SET:
      break;
      case kCombinedStdDev:
        _impl_.accuracy_.combined_std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.combined_std_dev_);
        break;
      case kStdDev:
        _impl_.accuracy_.std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.std_dev_);
        break;
      case kHorizontalConfidenceEllipseVerticalStdDev:
        _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_);
        break;
      case kCovariance:
        _impl_.accuracy_.covariance_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.covariance_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE PositionAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : extension_{visibility, arena},
        geographic_metric_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void PositionAndAccuracy::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
PositionAndAccuracy::~PositionAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  SharedDtor(*this);
}
inline void PositionAndAccuracy::SharedDtor(MessageLite& self) {
  PositionAndAccuracy& this_ = static_cast<PositionAndAccuracy&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_geographic_metric()) {
    this_.clear_geographic_metric();
  }
  if (this_.has_accuracy()) {
    this_.clear_accuracy();
  }
  this_._impl_.~Impl_();
}

void PositionAndAccuracy::clear_geographic_metric() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (geographic_metric_case()) {
    case kGeographicWgs84: {
      if (GetArena() == nullptr) {
        delete _impl_.geographic_metric_.geographic_wgs84_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geographic_metric_.geographic_wgs84_);
      }
      break;
    }
    case kMetricVehicle: {
      if (GetArena() == nullptr) {
        delete _impl_.geographic_metric_.metric_vehicle_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geographic_metric_.metric_vehicle_);
      }
      break;
    }
    case kMetricEventGroup: {
      if (GetArena() == nullptr) {
        delete _impl_.geographic_metric_.metric_event_group_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geographic_metric_.metric_event_group_);
      }
      break;
    }
    case kMetricEcef: {
      if (GetArena() == nullptr) {
        delete _impl_.geographic_metric_.metric_ecef_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geographic_metric_.metric_ecef_);
      }
      break;
    }
    case GEOGRAPHIC_METRIC_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = GEOGRAPHIC_METRIC_NOT_SET;
}

void PositionAndAccuracy::clear_accuracy() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (accuracy_case()) {
    case kCombinedStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.combined_std_dev_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.combined_std_dev_);
      }
      break;
    }
    case kStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.std_dev_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.std_dev_);
      }
      break;
    }
    case kHorizontalConfidenceEllipseVerticalStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_);
      }
      break;
    }
    case kCovariance: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.covariance_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.covariance_);
      }
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = ACCURACY_NOT_SET;
}


inline void* PROTOBUF_NONNULL PositionAndAccuracy::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PositionAndAccuracy(arena);
}
constexpr auto PositionAndAccuracy::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.extension_) +
          decltype(PositionAndAccuracy::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(PositionAndAccuracy), alignof(PositionAndAccuracy), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&PositionAndAccuracy::PlacementNew_,
                                 sizeof(PositionAndAccuracy),
                                 alignof(PositionAndAccuracy));
  }
}
constexpr auto PositionAndAccuracy::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PositionAndAccuracy_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PositionAndAccuracy::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PositionAndAccuracy>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PositionAndAccuracy::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PositionAndAccuracy>(), &PositionAndAccuracy::ByteSizeLong,
              &PositionAndAccuracy::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_._cached_size_),
          false,
      },
      &PositionAndAccuracy::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_class_data_ =
        PositionAndAccuracy::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PositionAndAccuracy::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PositionAndAccuracy_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PositionAndAccuracy_class_data_.tc_table);
  return PositionAndAccuracy_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 9, 9, 0, 2>
PositionAndAccuracy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    15, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950656,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    9,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PositionAndAccuracy_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 8, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic geographic_wgs84 = 1;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.geographic_metric_.geographic_wgs84_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_vehicle = 2;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.geographic_metric_.metric_vehicle_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_event_group = 3;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.geographic_metric_.metric_event_group_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_ecef = 4;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.geographic_metric_.metric_ecef_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.accuracy_.combined_std_dev_), _Internal::kOneofCaseOffset + 4, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev std_dev = 6;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.accuracy_.std_dev_), _Internal::kOneofCaseOffset + 4, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev horizontal_confidence_ellipse_vertical_std_dev = 7;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_), _Internal::kOneofCaseOffset + 4, 6,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 8 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.accuracy_.covariance_), _Internal::kOneofCaseOffset + 4, 7,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.extension_), 0, 8,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Matrix3x3>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PositionAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  clear_geographic_metric();
  clear_accuracy();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PositionAndAccuracy::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PositionAndAccuracy& this_ = static_cast<const PositionAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PositionAndAccuracy::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PositionAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (this_.geographic_metric_case()) {
    case kGeographicWgs84: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          1, *this_._impl_.geographic_metric_.geographic_wgs84_, this_._impl_.geographic_metric_.geographic_wgs84_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMetricVehicle: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          2, *this_._impl_.geographic_metric_.metric_vehicle_, this_._impl_.geographic_metric_.metric_vehicle_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMetricEventGroup: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, *this_._impl_.geographic_metric_.metric_event_group_, this_._impl_.geographic_metric_.metric_event_group_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMetricEcef: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *this_._impl_.geographic_metric_.metric_ecef_, this_._impl_.geographic_metric_.metric_ecef_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  switch (this_.accuracy_case()) {
    case kCombinedStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *this_._impl_.accuracy_.combined_std_dev_, this_._impl_.accuracy_.combined_std_dev_->GetCachedSize(), target,
          stream);
      break;
    }
    case kStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *this_._impl_.accuracy_.std_dev_, this_._impl_.accuracy_.std_dev_->GetCachedSize(), target,
          stream);
      break;
    }
    case kHorizontalConfidenceEllipseVerticalStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          7, *this_._impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_, this_._impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_->GetCachedSize(), target,
          stream);
      break;
    }
    case kCovariance: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          8, *this_._impl_.accuracy_.covariance_, this_._impl_.accuracy_.covariance_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PositionAndAccuracy::ByteSizeLong(const MessageLite& base) {
  const PositionAndAccuracy& this_ = static_cast<const PositionAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PositionAndAccuracy::ByteSizeLong() const {
  const PositionAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  switch (this_.geographic_metric_case()) {
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic geographic_wgs84 = 1;
    case kGeographicWgs84: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.geographic_metric_.geographic_wgs84_);
      break;
    }
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_vehicle = 2;
    case kMetricVehicle: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.geographic_metric_.metric_vehicle_);
      break;
    }
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_event_group = 3;
    case kMetricEventGroup: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.geographic_metric_.metric_event_group_);
      break;
    }
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_ecef = 4;
    case kMetricEcef: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.geographic_metric_.metric_ecef_);
      break;
    }
    case GEOGRAPHIC_METRIC_NOT_SET: {
      break;
    }
  }
  switch (this_.accuracy_case()) {
    // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
    case kCombinedStdDev: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.combined_std_dev_);
      break;
    }
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev std_dev = 6;
    case kStdDev: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.std_dev_);
      break;
    }
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev horizontal_confidence_ellipse_vertical_std_dev = 7;
    case kHorizontalConfidenceEllipseVerticalStdDev: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_);
      break;
    }
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 8 [(.sensoris.protobuf.types.base.exponent) = 0];
    case kCovariance: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.covariance_);
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PositionAndAccuracy::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PositionAndAccuracy*>(&to_msg);
  auto& from = static_cast<const PositionAndAccuracy&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_geographic_metric();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGeographicWgs84: {
        if (oneof_needs_init) {
          _this->_impl_.geographic_metric_.geographic_wgs84_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geographic_metric_.geographic_wgs84_);
        } else {
          _this->_impl_.geographic_metric_.geographic_wgs84_->MergeFrom(*from._impl_.geographic_metric_.geographic_wgs84_);
        }
        break;
      }
      case kMetricVehicle: {
        if (oneof_needs_init) {
          _this->_impl_.geographic_metric_.metric_vehicle_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geographic_metric_.metric_vehicle_);
        } else {
          _this->_impl_.geographic_metric_.metric_vehicle_->MergeFrom(*from._impl_.geographic_metric_.metric_vehicle_);
        }
        break;
      }
      case kMetricEventGroup: {
        if (oneof_needs_init) {
          _this->_impl_.geographic_metric_.metric_event_group_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geographic_metric_.metric_event_group_);
        } else {
          _this->_impl_.geographic_metric_.metric_event_group_->MergeFrom(*from._impl_.geographic_metric_.metric_event_group_);
        }
        break;
      }
      case kMetricEcef: {
        if (oneof_needs_init) {
          _this->_impl_.geographic_metric_.metric_ecef_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geographic_metric_.metric_ecef_);
        } else {
          _this->_impl_.geographic_metric_.metric_ecef_->MergeFrom(*from._impl_.geographic_metric_.metric_ecef_);
        }
        break;
      }
      case GEOGRAPHIC_METRIC_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_accuracy();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kCombinedStdDev: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.combined_std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.combined_std_dev_);
        } else {
          _this->_impl_.accuracy_.combined_std_dev_->MergeFrom(*from._impl_.accuracy_.combined_std_dev_);
        }
        break;
      }
      case kStdDev: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.std_dev_);
        } else {
          _this->_impl_.accuracy_.std_dev_->MergeFrom(*from._impl_.accuracy_.std_dev_);
        }
        break;
      }
      case kHorizontalConfidenceEllipseVerticalStdDev: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_);
        } else {
          _this->_impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_->MergeFrom(*from._impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_);
        }
        break;
      }
      case kCovariance: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.covariance_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.covariance_);
        } else {
          _this->_impl_.accuracy_.covariance_->MergeFrom(*from._impl_.accuracy_.covariance_);
        }
        break;
      }
      case ACCURACY_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PositionAndAccuracy::CopyFrom(const PositionAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PositionAndAccuracy::InternalSwap(PositionAndAccuracy* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  swap(_impl_.geographic_metric_, other->_impl_.geographic_metric_);
  swap(_impl_.accuracy_, other->_impl_.accuracy_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata PositionAndAccuracy::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PolylineAndAccuracy::_Internal {
 public:
};

void PolylineAndAccuracy::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
PolylineAndAccuracy::PolylineAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PolylineAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE PolylineAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& from_msg)
      : position_and_accuracy_{visibility, arena, from.position_and_accuracy_},
        extension_{visibility, arena, from.extension_},
        _cached_size_{0} {}

PolylineAndAccuracy::PolylineAndAccuracy(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PolylineAndAccuracy& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PolylineAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PolylineAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE PolylineAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : position_and_accuracy_{visibility, arena},
        extension_{visibility, arena},
        _cached_size_{0} {}

inline void PolylineAndAccuracy::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
PolylineAndAccuracy::~PolylineAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  SharedDtor(*this);
}
inline void PolylineAndAccuracy::SharedDtor(MessageLite& self) {
  PolylineAndAccuracy& this_ = static_cast<PolylineAndAccuracy&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PolylineAndAccuracy::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PolylineAndAccuracy(arena);
}
constexpr auto PolylineAndAccuracy::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(PolylineAndAccuracy, _impl_.position_and_accuracy_) +
          decltype(PolylineAndAccuracy::_impl_.position_and_accuracy_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(PolylineAndAccuracy, _impl_.extension_) +
          decltype(PolylineAndAccuracy::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(PolylineAndAccuracy), alignof(PolylineAndAccuracy), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&PolylineAndAccuracy::PlacementNew_,
                                 sizeof(PolylineAndAccuracy),
                                 alignof(PolylineAndAccuracy));
  }
}
constexpr auto PolylineAndAccuracy::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PolylineAndAccuracy_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PolylineAndAccuracy::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PolylineAndAccuracy>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PolylineAndAccuracy::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PolylineAndAccuracy>(), &PolylineAndAccuracy::ByteSizeLong,
              &PolylineAndAccuracy::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PolylineAndAccuracy, _impl_._cached_size_),
          false,
      },
      &PolylineAndAccuracy::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PolylineAndAccuracy_class_data_ =
        PolylineAndAccuracy::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PolylineAndAccuracy::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PolylineAndAccuracy_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PolylineAndAccuracy_class_data_.tc_table);
  return PolylineAndAccuracy_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 2, 2, 0, 2>
PolylineAndAccuracy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950910,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PolylineAndAccuracy_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PolylineAndAccuracy>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(PolylineAndAccuracy, _impl_.position_and_accuracy_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 1, PROTOBUF_FIELD_OFFSET(PolylineAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(PolylineAndAccuracy, _impl_.position_and_accuracy_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(PolylineAndAccuracy, _impl_.extension_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PolylineAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.position_and_accuracy_.Clear();
  _impl_.extension_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PolylineAndAccuracy::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PolylineAndAccuracy& this_ = static_cast<const PolylineAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PolylineAndAccuracy::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PolylineAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_position_and_accuracy_size());
       i < n; i++) {
    const auto& repfield = this_._internal_position_and_accuracy().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            1, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PolylineAndAccuracy::ByteSizeLong(const MessageLite& base) {
  const PolylineAndAccuracy& this_ = static_cast<const PolylineAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PolylineAndAccuracy::ByteSizeLong() const {
  const PolylineAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {
      total_size += 1UL * this_._internal_position_and_accuracy_size();
      for (const auto& msg : this_._internal_position_and_accuracy()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PolylineAndAccuracy::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PolylineAndAccuracy*>(&to_msg);
  auto& from = static_cast<const PolylineAndAccuracy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_position_and_accuracy()->MergeFrom(
      from._internal_position_and_accuracy());
  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PolylineAndAccuracy::CopyFrom(const PolylineAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PolylineAndAccuracy::InternalSwap(PolylineAndAccuracy* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.position_and_accuracy_.InternalSwap(&other->_impl_.position_and_accuracy_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
}

::google::protobuf::Metadata PolylineAndAccuracy::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PolylineCorridorAndAccuracy::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PolylineCorridorAndAccuracy>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_._has_bits_);
};

void PolylineCorridorAndAccuracy::clear_total_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.total_width_and_accuracy_ != nullptr) _impl_.total_width_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PolylineCorridorAndAccuracy::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
PolylineCorridorAndAccuracy::PolylineCorridorAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PolylineCorridorAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE PolylineCorridorAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_} {}

PolylineCorridorAndAccuracy::PolylineCorridorAndAccuracy(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PolylineCorridorAndAccuracy& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PolylineCorridorAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PolylineCorridorAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.center_polyline_and_accuracy_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.center_polyline_and_accuracy_)
                : nullptr;
  _impl_.total_width_and_accuracy_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.total_width_and_accuracy_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE PolylineCorridorAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        extension_{visibility, arena} {}

inline void PolylineCorridorAndAccuracy::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, center_polyline_and_accuracy_),
           0,
           offsetof(Impl_, total_width_and_accuracy_) -
               offsetof(Impl_, center_polyline_and_accuracy_) +
               sizeof(Impl_::total_width_and_accuracy_));
}
PolylineCorridorAndAccuracy::~PolylineCorridorAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  SharedDtor(*this);
}
inline void PolylineCorridorAndAccuracy::SharedDtor(MessageLite& self) {
  PolylineCorridorAndAccuracy& this_ = static_cast<PolylineCorridorAndAccuracy&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.center_polyline_and_accuracy_;
  delete this_._impl_.total_width_and_accuracy_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PolylineCorridorAndAccuracy::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PolylineCorridorAndAccuracy(arena);
}
constexpr auto PolylineCorridorAndAccuracy::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.extension_) +
          decltype(PolylineCorridorAndAccuracy::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(PolylineCorridorAndAccuracy), alignof(PolylineCorridorAndAccuracy), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&PolylineCorridorAndAccuracy::PlacementNew_,
                                 sizeof(PolylineCorridorAndAccuracy),
                                 alignof(PolylineCorridorAndAccuracy));
  }
}
constexpr auto PolylineCorridorAndAccuracy::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PolylineCorridorAndAccuracy_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PolylineCorridorAndAccuracy::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PolylineCorridorAndAccuracy>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PolylineCorridorAndAccuracy::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PolylineCorridorAndAccuracy>(), &PolylineCorridorAndAccuracy::ByteSizeLong,
              &PolylineCorridorAndAccuracy::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_._cached_size_),
          false,
      },
      &PolylineCorridorAndAccuracy::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PolylineCorridorAndAccuracy_class_data_ =
        PolylineCorridorAndAccuracy::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PolylineCorridorAndAccuracy::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PolylineCorridorAndAccuracy_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PolylineCorridorAndAccuracy_class_data_.tc_table);
  return PolylineCorridorAndAccuracy_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
PolylineCorridorAndAccuracy::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_._has_bits_),
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950908,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PolylineCorridorAndAccuracy_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.PolylineAndAccuracy center_polyline_and_accuracy = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.center_polyline_and_accuracy_)}},
    // .sensoris.protobuf.types.base.Int64ValueAndAccuracy total_width_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.total_width_and_accuracy_)}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 2, PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PolylineAndAccuracy center_polyline_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.center_polyline_and_accuracy_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64ValueAndAccuracy total_width_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.total_width_and_accuracy_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.extension_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PolylineAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PolylineCorridorAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.center_polyline_and_accuracy_ != nullptr);
      _impl_.center_polyline_and_accuracy_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.total_width_and_accuracy_ != nullptr);
      _impl_.total_width_and_accuracy_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PolylineCorridorAndAccuracy::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PolylineCorridorAndAccuracy& this_ = static_cast<const PolylineCorridorAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PolylineCorridorAndAccuracy::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PolylineCorridorAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.PolylineAndAccuracy center_polyline_and_accuracy = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.center_polyline_and_accuracy_, this_._impl_.center_polyline_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy total_width_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.total_width_and_accuracy_, this_._impl_.total_width_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PolylineCorridorAndAccuracy::ByteSizeLong(const MessageLite& base) {
  const PolylineCorridorAndAccuracy& this_ = static_cast<const PolylineCorridorAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PolylineCorridorAndAccuracy::ByteSizeLong() const {
  const PolylineCorridorAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // .sensoris.protobuf.types.spatial.PolylineAndAccuracy center_polyline_and_accuracy = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.center_polyline_and_accuracy_);
    }
    // .sensoris.protobuf.types.base.Int64ValueAndAccuracy total_width_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.total_width_and_accuracy_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PolylineCorridorAndAccuracy::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PolylineCorridorAndAccuracy*>(&to_msg);
  auto& from = static_cast<const PolylineCorridorAndAccuracy&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.center_polyline_and_accuracy_ != nullptr);
      if (_this->_impl_.center_polyline_and_accuracy_ == nullptr) {
        _this->_impl_.center_polyline_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.center_polyline_and_accuracy_);
      } else {
        _this->_impl_.center_polyline_and_accuracy_->MergeFrom(*from._impl_.center_polyline_and_accuracy_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.total_width_and_accuracy_ != nullptr);
      if (_this->_impl_.total_width_and_accuracy_ == nullptr) {
        _this->_impl_.total_width_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.total_width_and_accuracy_);
      } else {
        _this->_impl_.total_width_and_accuracy_->MergeFrom(*from._impl_.total_width_and_accuracy_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PolylineCorridorAndAccuracy::CopyFrom(const PolylineCorridorAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PolylineCorridorAndAccuracy::InternalSwap(PolylineCorridorAndAccuracy* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.total_width_and_accuracy_)
      + sizeof(PolylineCorridorAndAccuracy::_impl_.total_width_and_accuracy_)
      - PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.center_polyline_and_accuracy_)>(
          reinterpret_cast<char*>(&_impl_.center_polyline_and_accuracy_),
          reinterpret_cast<char*>(&other->_impl_.center_polyline_and_accuracy_));
}

::google::protobuf::Metadata PolylineCorridorAndAccuracy::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DirectedPolylineCorridor::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DirectedPolylineCorridor>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_._has_bits_);
};

void DirectedPolylineCorridor::clear_is_bidirectional() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.is_bidirectional_ != nullptr) _impl_.is_bidirectional_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void DirectedPolylineCorridor::clear_heading_deviation_from_center_line() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.heading_deviation_from_center_line_ != nullptr) _impl_.heading_deviation_from_center_line_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void DirectedPolylineCorridor::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
DirectedPolylineCorridor::DirectedPolylineCorridor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DirectedPolylineCorridor_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
}
PROTOBUF_NDEBUG_INLINE DirectedPolylineCorridor::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::DirectedPolylineCorridor& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_} {}

DirectedPolylineCorridor::DirectedPolylineCorridor(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DirectedPolylineCorridor& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DirectedPolylineCorridor_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DirectedPolylineCorridor* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.polyline_corridor_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.polyline_corridor_)
                : nullptr;
  _impl_.is_bidirectional_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.is_bidirectional_)
                : nullptr;
  _impl_.heading_deviation_from_center_line_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.heading_deviation_from_center_line_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
}
PROTOBUF_NDEBUG_INLINE DirectedPolylineCorridor::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        extension_{visibility, arena} {}

inline void DirectedPolylineCorridor::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, polyline_corridor_),
           0,
           offsetof(Impl_, heading_deviation_from_center_line_) -
               offsetof(Impl_, polyline_corridor_) +
               sizeof(Impl_::heading_deviation_from_center_line_));
}
DirectedPolylineCorridor::~DirectedPolylineCorridor() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  SharedDtor(*this);
}
inline void DirectedPolylineCorridor::SharedDtor(MessageLite& self) {
  DirectedPolylineCorridor& this_ = static_cast<DirectedPolylineCorridor&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.polyline_corridor_;
  delete this_._impl_.is_bidirectional_;
  delete this_._impl_.heading_deviation_from_center_line_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DirectedPolylineCorridor::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DirectedPolylineCorridor(arena);
}
constexpr auto DirectedPolylineCorridor::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.extension_) +
          decltype(DirectedPolylineCorridor::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(DirectedPolylineCorridor), alignof(DirectedPolylineCorridor), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&DirectedPolylineCorridor::PlacementNew_,
                                 sizeof(DirectedPolylineCorridor),
                                 alignof(DirectedPolylineCorridor));
  }
}
constexpr auto DirectedPolylineCorridor::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DirectedPolylineCorridor_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DirectedPolylineCorridor::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DirectedPolylineCorridor>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DirectedPolylineCorridor::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DirectedPolylineCorridor>(), &DirectedPolylineCorridor::ByteSizeLong,
              &DirectedPolylineCorridor::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_._cached_size_),
          false,
      },
      &DirectedPolylineCorridor::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DirectedPolylineCorridor_class_data_ =
        DirectedPolylineCorridor::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DirectedPolylineCorridor::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DirectedPolylineCorridor_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DirectedPolylineCorridor_class_data_.tc_table);
  return DirectedPolylineCorridor_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 4, 4, 0, 2>
DirectedPolylineCorridor::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_._has_bits_),
    0, // no _extensions_
    15, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950904,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    DirectedPolylineCorridor_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::DirectedPolylineCorridor>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy polyline_corridor = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.polyline_corridor_)}},
    // .google.protobuf.BoolValue is_bidirectional = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.is_bidirectional_)}},
    // .google.protobuf.Int64Value heading_deviation_from_center_line = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.heading_deviation_from_center_line_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 3, PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy polyline_corridor = 1;
    {PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.polyline_corridor_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.BoolValue is_bidirectional = 2;
    {PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.is_bidirectional_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value heading_deviation_from_center_line = 3;
    {PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.heading_deviation_from_center_line_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.extension_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::BoolValue>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void DirectedPolylineCorridor::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.polyline_corridor_ != nullptr);
      _impl_.polyline_corridor_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.is_bidirectional_ != nullptr);
      _impl_.is_bidirectional_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.heading_deviation_from_center_line_ != nullptr);
      _impl_.heading_deviation_from_center_line_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DirectedPolylineCorridor::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DirectedPolylineCorridor& this_ = static_cast<const DirectedPolylineCorridor&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DirectedPolylineCorridor::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DirectedPolylineCorridor& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy polyline_corridor = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.polyline_corridor_, this_._impl_.polyline_corridor_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.BoolValue is_bidirectional = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.is_bidirectional_, this_._impl_.is_bidirectional_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value heading_deviation_from_center_line = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.heading_deviation_from_center_line_, this_._impl_.heading_deviation_from_center_line_->GetCachedSize(), target,
        stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DirectedPolylineCorridor::ByteSizeLong(const MessageLite& base) {
  const DirectedPolylineCorridor& this_ = static_cast<const DirectedPolylineCorridor&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DirectedPolylineCorridor::ByteSizeLong() const {
  const DirectedPolylineCorridor& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // .sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy polyline_corridor = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.polyline_corridor_);
    }
    // .google.protobuf.BoolValue is_bidirectional = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.is_bidirectional_);
    }
    // .google.protobuf.Int64Value heading_deviation_from_center_line = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.heading_deviation_from_center_line_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DirectedPolylineCorridor::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<DirectedPolylineCorridor*>(&to_msg);
  auto& from = static_cast<const DirectedPolylineCorridor&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.polyline_corridor_ != nullptr);
      if (_this->_impl_.polyline_corridor_ == nullptr) {
        _this->_impl_.polyline_corridor_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.polyline_corridor_);
      } else {
        _this->_impl_.polyline_corridor_->MergeFrom(*from._impl_.polyline_corridor_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.is_bidirectional_ != nullptr);
      if (_this->_impl_.is_bidirectional_ == nullptr) {
        _this->_impl_.is_bidirectional_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.is_bidirectional_);
      } else {
        _this->_impl_.is_bidirectional_->MergeFrom(*from._impl_.is_bidirectional_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.heading_deviation_from_center_line_ != nullptr);
      if (_this->_impl_.heading_deviation_from_center_line_ == nullptr) {
        _this->_impl_.heading_deviation_from_center_line_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.heading_deviation_from_center_line_);
      } else {
        _this->_impl_.heading_deviation_from_center_line_->MergeFrom(*from._impl_.heading_deviation_from_center_line_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DirectedPolylineCorridor::CopyFrom(const DirectedPolylineCorridor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DirectedPolylineCorridor::InternalSwap(DirectedPolylineCorridor* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.heading_deviation_from_center_line_)
      + sizeof(DirectedPolylineCorridor::_impl_.heading_deviation_from_center_line_)
      - PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.polyline_corridor_)>(
          reinterpret_cast<char*>(&_impl_.polyline_corridor_),
          reinterpret_cast<char*>(&other->_impl_.polyline_corridor_));
}

::google::protobuf::Metadata DirectedPolylineCorridor::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CircleAndAccuracy::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CircleAndAccuracy>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_._has_bits_);
};

void CircleAndAccuracy::clear_radius_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.radius_and_accuracy_ != nullptr) _impl_.radius_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CircleAndAccuracy::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
CircleAndAccuracy::CircleAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CircleAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.CircleAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE CircleAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::CircleAndAccuracy& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_} {}

CircleAndAccuracy::CircleAndAccuracy(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CircleAndAccuracy& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CircleAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CircleAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.center_position_and_accuracy_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.center_position_and_accuracy_)
                : nullptr;
  _impl_.radius_and_accuracy_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.radius_and_accuracy_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.CircleAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE CircleAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        extension_{visibility, arena} {}

inline void CircleAndAccuracy::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, center_position_and_accuracy_),
           0,
           offsetof(Impl_, radius_and_accuracy_) -
               offsetof(Impl_, center_position_and_accuracy_) +
               sizeof(Impl_::radius_and_accuracy_));
}
CircleAndAccuracy::~CircleAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  SharedDtor(*this);
}
inline void CircleAndAccuracy::SharedDtor(MessageLite& self) {
  CircleAndAccuracy& this_ = static_cast<CircleAndAccuracy&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.center_position_and_accuracy_;
  delete this_._impl_.radius_and_accuracy_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CircleAndAccuracy::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CircleAndAccuracy(arena);
}
constexpr auto CircleAndAccuracy::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.extension_) +
          decltype(CircleAndAccuracy::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(CircleAndAccuracy), alignof(CircleAndAccuracy), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CircleAndAccuracy::PlacementNew_,
                                 sizeof(CircleAndAccuracy),
                                 alignof(CircleAndAccuracy));
  }
}
constexpr auto CircleAndAccuracy::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CircleAndAccuracy_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CircleAndAccuracy::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CircleAndAccuracy>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CircleAndAccuracy::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CircleAndAccuracy>(), &CircleAndAccuracy::ByteSizeLong,
              &CircleAndAccuracy::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_._cached_size_),
          false,
      },
      &CircleAndAccuracy::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CircleAndAccuracy_class_data_ =
        CircleAndAccuracy::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CircleAndAccuracy::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CircleAndAccuracy_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CircleAndAccuracy_class_data_.tc_table);
  return CircleAndAccuracy_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
CircleAndAccuracy::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_._has_bits_),
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950908,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    CircleAndAccuracy_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::CircleAndAccuracy>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.center_position_and_accuracy_)}},
    // .sensoris.protobuf.types.base.Int64ValueAndAccuracy radius_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.radius_and_accuracy_)}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 2, PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.center_position_and_accuracy_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64ValueAndAccuracy radius_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.radius_and_accuracy_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.extension_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void CircleAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.center_position_and_accuracy_ != nullptr);
      _impl_.center_position_and_accuracy_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.radius_and_accuracy_ != nullptr);
      _impl_.radius_and_accuracy_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CircleAndAccuracy::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CircleAndAccuracy& this_ = static_cast<const CircleAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CircleAndAccuracy::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CircleAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.center_position_and_accuracy_, this_._impl_.center_position_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy radius_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.radius_and_accuracy_, this_._impl_.radius_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CircleAndAccuracy::ByteSizeLong(const MessageLite& base) {
  const CircleAndAccuracy& this_ = static_cast<const CircleAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CircleAndAccuracy::ByteSizeLong() const {
  const CircleAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.center_position_and_accuracy_);
    }
    // .sensoris.protobuf.types.base.Int64ValueAndAccuracy radius_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.radius_and_accuracy_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CircleAndAccuracy::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CircleAndAccuracy*>(&to_msg);
  auto& from = static_cast<const CircleAndAccuracy&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.center_position_and_accuracy_ != nullptr);
      if (_this->_impl_.center_position_and_accuracy_ == nullptr) {
        _this->_impl_.center_position_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.center_position_and_accuracy_);
      } else {
        _this->_impl_.center_position_and_accuracy_->MergeFrom(*from._impl_.center_position_and_accuracy_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.radius_and_accuracy_ != nullptr);
      if (_this->_impl_.radius_and_accuracy_ == nullptr) {
        _this->_impl_.radius_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.radius_and_accuracy_);
      } else {
        _this->_impl_.radius_and_accuracy_->MergeFrom(*from._impl_.radius_and_accuracy_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CircleAndAccuracy::CopyFrom(const CircleAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CircleAndAccuracy::InternalSwap(CircleAndAccuracy* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.radius_and_accuracy_)
      + sizeof(CircleAndAccuracy::_impl_.radius_and_accuracy_)
      - PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.center_position_and_accuracy_)>(
          reinterpret_cast<char*>(&_impl_.center_position_and_accuracy_),
          reinterpret_cast<char*>(&other->_impl_.center_position_and_accuracy_));
}

::google::protobuf::Metadata CircleAndAccuracy::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RectangleAndAccuracy::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RectangleAndAccuracy>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_._has_bits_);
};

void RectangleAndAccuracy::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
RectangleAndAccuracy::RectangleAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RectangleAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE RectangleAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::RectangleAndAccuracy& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_} {}

RectangleAndAccuracy::RectangleAndAccuracy(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RectangleAndAccuracy& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RectangleAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RectangleAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.minimum_position_and_accuracy_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.minimum_position_and_accuracy_)
                : nullptr;
  _impl_.maximum_position_and_accuracy_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.maximum_position_and_accuracy_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE RectangleAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        extension_{visibility, arena} {}

inline void RectangleAndAccuracy::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, minimum_position_and_accuracy_),
           0,
           offsetof(Impl_, maximum_position_and_accuracy_) -
               offsetof(Impl_, minimum_position_and_accuracy_) +
               sizeof(Impl_::maximum_position_and_accuracy_));
}
RectangleAndAccuracy::~RectangleAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  SharedDtor(*this);
}
inline void RectangleAndAccuracy::SharedDtor(MessageLite& self) {
  RectangleAndAccuracy& this_ = static_cast<RectangleAndAccuracy&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.minimum_position_and_accuracy_;
  delete this_._impl_.maximum_position_and_accuracy_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RectangleAndAccuracy::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RectangleAndAccuracy(arena);
}
constexpr auto RectangleAndAccuracy::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.extension_) +
          decltype(RectangleAndAccuracy::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(RectangleAndAccuracy), alignof(RectangleAndAccuracy), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&RectangleAndAccuracy::PlacementNew_,
                                 sizeof(RectangleAndAccuracy),
                                 alignof(RectangleAndAccuracy));
  }
}
constexpr auto RectangleAndAccuracy::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RectangleAndAccuracy_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RectangleAndAccuracy::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RectangleAndAccuracy>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RectangleAndAccuracy::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RectangleAndAccuracy>(), &RectangleAndAccuracy::ByteSizeLong,
              &RectangleAndAccuracy::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_._cached_size_),
          false,
      },
      &RectangleAndAccuracy::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RectangleAndAccuracy_class_data_ =
        RectangleAndAccuracy::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RectangleAndAccuracy::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RectangleAndAccuracy_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RectangleAndAccuracy_class_data_.tc_table);
  return RectangleAndAccuracy_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
RectangleAndAccuracy::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_._has_bits_),
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950908,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RectangleAndAccuracy_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RectangleAndAccuracy>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy minimum_position_and_accuracy = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.minimum_position_and_accuracy_)}},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy maximum_position_and_accuracy = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.maximum_position_and_accuracy_)}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 2, PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy minimum_position_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.minimum_position_and_accuracy_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy maximum_position_and_accuracy = 2;
    {PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.maximum_position_and_accuracy_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.extension_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RectangleAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.minimum_position_and_accuracy_ != nullptr);
      _impl_.minimum_position_and_accuracy_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.maximum_position_and_accuracy_ != nullptr);
      _impl_.maximum_position_and_accuracy_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RectangleAndAccuracy::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RectangleAndAccuracy& this_ = static_cast<const RectangleAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RectangleAndAccuracy::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RectangleAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy minimum_position_and_accuracy = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.minimum_position_and_accuracy_, this_._impl_.minimum_position_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy maximum_position_and_accuracy = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.maximum_position_and_accuracy_, this_._impl_.maximum_position_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RectangleAndAccuracy::ByteSizeLong(const MessageLite& base) {
  const RectangleAndAccuracy& this_ = static_cast<const RectangleAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RectangleAndAccuracy::ByteSizeLong() const {
  const RectangleAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy minimum_position_and_accuracy = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.minimum_position_and_accuracy_);
    }
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy maximum_position_and_accuracy = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.maximum_position_and_accuracy_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RectangleAndAccuracy::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RectangleAndAccuracy*>(&to_msg);
  auto& from = static_cast<const RectangleAndAccuracy&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.minimum_position_and_accuracy_ != nullptr);
      if (_this->_impl_.minimum_position_and_accuracy_ == nullptr) {
        _this->_impl_.minimum_position_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.minimum_position_and_accuracy_);
      } else {
        _this->_impl_.minimum_position_and_accuracy_->MergeFrom(*from._impl_.minimum_position_and_accuracy_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.maximum_position_and_accuracy_ != nullptr);
      if (_this->_impl_.maximum_position_and_accuracy_ == nullptr) {
        _this->_impl_.maximum_position_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.maximum_position_and_accuracy_);
      } else {
        _this->_impl_.maximum_position_and_accuracy_->MergeFrom(*from._impl_.maximum_position_and_accuracy_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RectangleAndAccuracy::CopyFrom(const RectangleAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RectangleAndAccuracy::InternalSwap(RectangleAndAccuracy* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.maximum_position_and_accuracy_)
      + sizeof(RectangleAndAccuracy::_impl_.maximum_position_and_accuracy_)
      - PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.minimum_position_and_accuracy_)>(
          reinterpret_cast<char*>(&_impl_.minimum_position_and_accuracy_),
          reinterpret_cast<char*>(&other->_impl_.minimum_position_and_accuracy_));
}

::google::protobuf::Metadata RectangleAndAccuracy::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PolygonAndAccuracy::_Internal {
 public:
};

void PolygonAndAccuracy::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
PolygonAndAccuracy::PolygonAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PolygonAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE PolygonAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::PolygonAndAccuracy& from_msg)
      : position_and_accuracy_{visibility, arena, from.position_and_accuracy_},
        extension_{visibility, arena, from.extension_},
        _cached_size_{0} {}

PolygonAndAccuracy::PolygonAndAccuracy(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PolygonAndAccuracy& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PolygonAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PolygonAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE PolygonAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : position_and_accuracy_{visibility, arena},
        extension_{visibility, arena},
        _cached_size_{0} {}

inline void PolygonAndAccuracy::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
PolygonAndAccuracy::~PolygonAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  SharedDtor(*this);
}
inline void PolygonAndAccuracy::SharedDtor(MessageLite& self) {
  PolygonAndAccuracy& this_ = static_cast<PolygonAndAccuracy&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PolygonAndAccuracy::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PolygonAndAccuracy(arena);
}
constexpr auto PolygonAndAccuracy::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(PolygonAndAccuracy, _impl_.position_and_accuracy_) +
          decltype(PolygonAndAccuracy::_impl_.position_and_accuracy_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(PolygonAndAccuracy, _impl_.extension_) +
          decltype(PolygonAndAccuracy::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(PolygonAndAccuracy), alignof(PolygonAndAccuracy), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&PolygonAndAccuracy::PlacementNew_,
                                 sizeof(PolygonAndAccuracy),
                                 alignof(PolygonAndAccuracy));
  }
}
constexpr auto PolygonAndAccuracy::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PolygonAndAccuracy_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PolygonAndAccuracy::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PolygonAndAccuracy>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PolygonAndAccuracy::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PolygonAndAccuracy>(), &PolygonAndAccuracy::ByteSizeLong,
              &PolygonAndAccuracy::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PolygonAndAccuracy, _impl_._cached_size_),
          false,
      },
      &PolygonAndAccuracy::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PolygonAndAccuracy_class_data_ =
        PolygonAndAccuracy::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PolygonAndAccuracy::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PolygonAndAccuracy_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PolygonAndAccuracy_class_data_.tc_table);
  return PolygonAndAccuracy_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 2, 2, 0, 2>
PolygonAndAccuracy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950910,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PolygonAndAccuracy_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PolygonAndAccuracy>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(PolygonAndAccuracy, _impl_.position_and_accuracy_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 1, PROTOBUF_FIELD_OFFSET(PolygonAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(PolygonAndAccuracy, _impl_.position_and_accuracy_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(PolygonAndAccuracy, _impl_.extension_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PolygonAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.position_and_accuracy_.Clear();
  _impl_.extension_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PolygonAndAccuracy::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PolygonAndAccuracy& this_ = static_cast<const PolygonAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PolygonAndAccuracy::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PolygonAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_position_and_accuracy_size());
       i < n; i++) {
    const auto& repfield = this_._internal_position_and_accuracy().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            1, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PolygonAndAccuracy::ByteSizeLong(const MessageLite& base) {
  const PolygonAndAccuracy& this_ = static_cast<const PolygonAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PolygonAndAccuracy::ByteSizeLong() const {
  const PolygonAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {
      total_size += 1UL * this_._internal_position_and_accuracy_size();
      for (const auto& msg : this_._internal_position_and_accuracy()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PolygonAndAccuracy::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PolygonAndAccuracy*>(&to_msg);
  auto& from = static_cast<const PolygonAndAccuracy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_position_and_accuracy()->MergeFrom(
      from._internal_position_and_accuracy());
  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PolygonAndAccuracy::CopyFrom(const PolygonAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PolygonAndAccuracy::InternalSwap(PolygonAndAccuracy* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.position_and_accuracy_.InternalSwap(&other->_impl_.position_and_accuracy_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
}

::google::protobuf::Metadata PolygonAndAccuracy::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class XyzVectorAndAccuracy_StdDev::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<XyzVectorAndAccuracy_StdDev>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_._has_bits_);
};

void XyzVectorAndAccuracy_StdDev::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ != nullptr) _impl_.x_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void XyzVectorAndAccuracy_StdDev::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ != nullptr) _impl_.y_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void XyzVectorAndAccuracy_StdDev::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ != nullptr) _impl_.z_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
XyzVectorAndAccuracy_StdDev::XyzVectorAndAccuracy_StdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, XyzVectorAndAccuracy_StdDev_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
}
PROTOBUF_NDEBUG_INLINE XyzVectorAndAccuracy_StdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

XyzVectorAndAccuracy_StdDev::XyzVectorAndAccuracy_StdDev(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const XyzVectorAndAccuracy_StdDev& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, XyzVectorAndAccuracy_StdDev_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  XyzVectorAndAccuracy_StdDev* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.x_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.x_)
                : nullptr;
  _impl_.y_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.y_)
                : nullptr;
  _impl_.z_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.z_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
}
PROTOBUF_NDEBUG_INLINE XyzVectorAndAccuracy_StdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void XyzVectorAndAccuracy_StdDev::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, z_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::z_));
}
XyzVectorAndAccuracy_StdDev::~XyzVectorAndAccuracy_StdDev() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  SharedDtor(*this);
}
inline void XyzVectorAndAccuracy_StdDev::SharedDtor(MessageLite& self) {
  XyzVectorAndAccuracy_StdDev& this_ = static_cast<XyzVectorAndAccuracy_StdDev&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.x_;
  delete this_._impl_.y_;
  delete this_._impl_.z_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL XyzVectorAndAccuracy_StdDev::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) XyzVectorAndAccuracy_StdDev(arena);
}
constexpr auto XyzVectorAndAccuracy_StdDev::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(XyzVectorAndAccuracy_StdDev),
                                            alignof(XyzVectorAndAccuracy_StdDev));
}
constexpr auto XyzVectorAndAccuracy_StdDev::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_XyzVectorAndAccuracy_StdDev_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &XyzVectorAndAccuracy_StdDev::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<XyzVectorAndAccuracy_StdDev>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &XyzVectorAndAccuracy_StdDev::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<XyzVectorAndAccuracy_StdDev>(), &XyzVectorAndAccuracy_StdDev::ByteSizeLong,
              &XyzVectorAndAccuracy_StdDev::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_._cached_size_),
          false,
      },
      &XyzVectorAndAccuracy_StdDev::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull XyzVectorAndAccuracy_StdDev_class_data_ =
        XyzVectorAndAccuracy_StdDev::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
XyzVectorAndAccuracy_StdDev::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&XyzVectorAndAccuracy_StdDev_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(XyzVectorAndAccuracy_StdDev_class_data_.tc_table);
  return XyzVectorAndAccuracy_StdDev_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
XyzVectorAndAccuracy_StdDev::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    XyzVectorAndAccuracy_StdDev_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Int64Value x = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.x_)}},
    // .google.protobuf.Int64Value y = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.y_)}},
    // .google.protobuf.Int64Value z = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value x = 1;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.x_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value y = 2;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.y_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value z = 3;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.z_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void XyzVectorAndAccuracy_StdDev::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.x_ != nullptr);
      _impl_.x_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.y_ != nullptr);
      _impl_.y_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.z_ != nullptr);
      _impl_.z_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL XyzVectorAndAccuracy_StdDev::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const XyzVectorAndAccuracy_StdDev& this_ = static_cast<const XyzVectorAndAccuracy_StdDev&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL XyzVectorAndAccuracy_StdDev::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const XyzVectorAndAccuracy_StdDev& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .google.protobuf.Int64Value x = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.x_, this_._impl_.x_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value y = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.y_, this_._impl_.y_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value z = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.z_, this_._impl_.z_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t XyzVectorAndAccuracy_StdDev::ByteSizeLong(const MessageLite& base) {
  const XyzVectorAndAccuracy_StdDev& this_ = static_cast<const XyzVectorAndAccuracy_StdDev&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t XyzVectorAndAccuracy_StdDev::ByteSizeLong() const {
  const XyzVectorAndAccuracy_StdDev& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // .google.protobuf.Int64Value x = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.x_);
    }
    // .google.protobuf.Int64Value y = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.y_);
    }
    // .google.protobuf.Int64Value z = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.z_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void XyzVectorAndAccuracy_StdDev::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<XyzVectorAndAccuracy_StdDev*>(&to_msg);
  auto& from = static_cast<const XyzVectorAndAccuracy_StdDev&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.x_ != nullptr);
      if (_this->_impl_.x_ == nullptr) {
        _this->_impl_.x_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.x_);
      } else {
        _this->_impl_.x_->MergeFrom(*from._impl_.x_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.y_ != nullptr);
      if (_this->_impl_.y_ == nullptr) {
        _this->_impl_.y_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.y_);
      } else {
        _this->_impl_.y_->MergeFrom(*from._impl_.y_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.z_ != nullptr);
      if (_this->_impl_.z_ == nullptr) {
        _this->_impl_.z_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.z_);
      } else {
        _this->_impl_.z_->MergeFrom(*from._impl_.z_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void XyzVectorAndAccuracy_StdDev::CopyFrom(const XyzVectorAndAccuracy_StdDev& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void XyzVectorAndAccuracy_StdDev::InternalSwap(XyzVectorAndAccuracy_StdDev* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.z_)
      + sizeof(XyzVectorAndAccuracy_StdDev::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata XyzVectorAndAccuracy_StdDev::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class XyzVectorAndAccuracy_Metric::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<XyzVectorAndAccuracy_Metric>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_._has_bits_);
};

void XyzVectorAndAccuracy_Metric::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ != nullptr) _impl_.x_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void XyzVectorAndAccuracy_Metric::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ != nullptr) _impl_.y_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void XyzVectorAndAccuracy_Metric::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ != nullptr) _impl_.z_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
XyzVectorAndAccuracy_Metric::XyzVectorAndAccuracy_Metric(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, XyzVectorAndAccuracy_Metric_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
}
PROTOBUF_NDEBUG_INLINE XyzVectorAndAccuracy_Metric::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

XyzVectorAndAccuracy_Metric::XyzVectorAndAccuracy_Metric(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const XyzVectorAndAccuracy_Metric& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, XyzVectorAndAccuracy_Metric_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  XyzVectorAndAccuracy_Metric* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.x_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.x_)
                : nullptr;
  _impl_.y_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.y_)
                : nullptr;
  _impl_.z_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.z_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
}
PROTOBUF_NDEBUG_INLINE XyzVectorAndAccuracy_Metric::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void XyzVectorAndAccuracy_Metric::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, z_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::z_));
}
XyzVectorAndAccuracy_Metric::~XyzVectorAndAccuracy_Metric() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  SharedDtor(*this);
}
inline void XyzVectorAndAccuracy_Metric::SharedDtor(MessageLite& self) {
  XyzVectorAndAccuracy_Metric& this_ = static_cast<XyzVectorAndAccuracy_Metric&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.x_;
  delete this_._impl_.y_;
  delete this_._impl_.z_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL XyzVectorAndAccuracy_Metric::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) XyzVectorAndAccuracy_Metric(arena);
}
constexpr auto XyzVectorAndAccuracy_Metric::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(XyzVectorAndAccuracy_Metric),
                                            alignof(XyzVectorAndAccuracy_Metric));
}
constexpr auto XyzVectorAndAccuracy_Metric::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_XyzVectorAndAccuracy_Metric_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &XyzVectorAndAccuracy_Metric::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<XyzVectorAndAccuracy_Metric>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &XyzVectorAndAccuracy_Metric::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<XyzVectorAndAccuracy_Metric>(), &XyzVectorAndAccuracy_Metric::ByteSizeLong,
              &XyzVectorAndAccuracy_Metric::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_._cached_size_),
          false,
      },
      &XyzVectorAndAccuracy_Metric::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull XyzVectorAndAccuracy_Metric_class_data_ =
        XyzVectorAndAccuracy_Metric::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
XyzVectorAndAccuracy_Metric::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&XyzVectorAndAccuracy_Metric_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(XyzVectorAndAccuracy_Metric_class_data_.tc_table);
  return XyzVectorAndAccuracy_Metric_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
XyzVectorAndAccuracy_Metric::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    XyzVectorAndAccuracy_Metric_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.base.Int64Value x = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.x_)}},
    // .sensoris.protobuf.types.base.Int64Value y = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.y_)}},
    // .sensoris.protobuf.types.base.Int64Value z = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.base.Int64Value x = 1;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.x_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value y = 2;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.y_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value z = 3;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.z_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void XyzVectorAndAccuracy_Metric::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.x_ != nullptr);
      _impl_.x_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.y_ != nullptr);
      _impl_.y_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.z_ != nullptr);
      _impl_.z_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL XyzVectorAndAccuracy_Metric::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const XyzVectorAndAccuracy_Metric& this_ = static_cast<const XyzVectorAndAccuracy_Metric&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL XyzVectorAndAccuracy_Metric::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const XyzVectorAndAccuracy_Metric& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.base.Int64Value x = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.x_, this_._impl_.x_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value y = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.y_, this_._impl_.y_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value z = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.z_, this_._impl_.z_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t XyzVectorAndAccuracy_Metric::ByteSizeLong(const MessageLite& base) {
  const XyzVectorAndAccuracy_Metric& this_ = static_cast<const XyzVectorAndAccuracy_Metric&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t XyzVectorAndAccuracy_Metric::ByteSizeLong() const {
  const XyzVectorAndAccuracy_Metric& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // .sensoris.protobuf.types.base.Int64Value x = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.x_);
    }
    // .sensoris.protobuf.types.base.Int64Value y = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.y_);
    }
    // .sensoris.protobuf.types.base.Int64Value z = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.z_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void XyzVectorAndAccuracy_Metric::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<XyzVectorAndAccuracy_Metric*>(&to_msg);
  auto& from = static_cast<const XyzVectorAndAccuracy_Metric&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.x_ != nullptr);
      if (_this->_impl_.x_ == nullptr) {
        _this->_impl_.x_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.x_);
      } else {
        _this->_impl_.x_->MergeFrom(*from._impl_.x_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.y_ != nullptr);
      if (_this->_impl_.y_ == nullptr) {
        _this->_impl_.y_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.y_);
      } else {
        _this->_impl_.y_->MergeFrom(*from._impl_.y_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.z_ != nullptr);
      if (_this->_impl_.z_ == nullptr) {
        _this->_impl_.z_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.z_);
      } else {
        _this->_impl_.z_->MergeFrom(*from._impl_.z_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void XyzVectorAndAccuracy_Metric::CopyFrom(const XyzVectorAndAccuracy_Metric& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void XyzVectorAndAccuracy_Metric::InternalSwap(XyzVectorAndAccuracy_Metric* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.z_)
      + sizeof(XyzVectorAndAccuracy_Metric::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata XyzVectorAndAccuracy_Metric::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class XyzVectorAndAccuracy::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy, _impl_._oneof_case_);
};

void XyzVectorAndAccuracy::set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE metric_vehicle) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geometry();
  if (metric_vehicle) {
    ::google::protobuf::Arena* submessage_arena = metric_vehicle->GetArena();
    if (message_arena != submessage_arena) {
      metric_vehicle = ::google::protobuf::internal::GetOwnedMessage(message_arena, metric_vehicle, submessage_arena);
    }
    set_has_metric_vehicle();
    _impl_.geometry_.metric_vehicle_ = metric_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
}
void XyzVectorAndAccuracy::set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE metric_event_group) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geometry();
  if (metric_event_group) {
    ::google::protobuf::Arena* submessage_arena = metric_event_group->GetArena();
    if (message_arena != submessage_arena) {
      metric_event_group = ::google::protobuf::internal::GetOwnedMessage(message_arena, metric_event_group, submessage_arena);
    }
    set_has_metric_event_group();
    _impl_.geometry_.metric_event_group_ = metric_event_group;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
}
void XyzVectorAndAccuracy::set_allocated_metric_origin(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE metric_origin) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geometry();
  if (metric_origin) {
    ::google::protobuf::Arena* submessage_arena = metric_origin->GetArena();
    if (message_arena != submessage_arena) {
      metric_origin = ::google::protobuf::internal::GetOwnedMessage(message_arena, metric_origin, submessage_arena);
    }
    set_has_metric_origin();
    _impl_.geometry_.metric_origin_ = metric_origin;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
}
void XyzVectorAndAccuracy::set_allocated_combined_std_dev(::google::protobuf::Int64Value* PROTOBUF_NULLABLE combined_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (combined_std_dev) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(combined_std_dev)->GetArena();
    if (message_arena != submessage_arena) {
      combined_std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, combined_std_dev, submessage_arena);
    }
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = combined_std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
}
void XyzVectorAndAccuracy::clear_combined_std_dev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kCombinedStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.combined_std_dev_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.combined_std_dev_);
    }
    clear_has_accuracy();
  }
}
void XyzVectorAndAccuracy::set_allocated_std_dev(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* PROTOBUF_NULLABLE std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (std_dev) {
    ::google::protobuf::Arena* submessage_arena = std_dev->GetArena();
    if (message_arena != submessage_arena) {
      std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, std_dev, submessage_arena);
    }
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
}
void XyzVectorAndAccuracy::set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE covariance) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (covariance) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(covariance)->GetArena();
    if (message_arena != submessage_arena) {
      covariance = ::google::protobuf::internal::GetOwnedMessage(message_arena, covariance, submessage_arena);
    }
    set_has_covariance();
    _impl_.accuracy_.covariance_ = covariance;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
}
void XyzVectorAndAccuracy::clear_covariance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kCovariance) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.covariance_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.covariance_);
    }
    clear_has_accuracy();
  }
}
void XyzVectorAndAccuracy::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
XyzVectorAndAccuracy::XyzVectorAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, XyzVectorAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE XyzVectorAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& from_msg)
      : extension_{visibility, arena, from.extension_},
        geometry_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

XyzVectorAndAccuracy::XyzVectorAndAccuracy(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const XyzVectorAndAccuracy& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, XyzVectorAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  XyzVectorAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (geometry_case()) {
    case GEOMETRY_NOT_SET:
      break;
      case kMetricVehicle:
        _impl_.geometry_.metric_vehicle_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geometry_.metric_vehicle_);
        break;
      case kMetricEventGroup:
        _impl_.geometry_.metric_event_group_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geometry_.metric_event_group_);
        break;
      case kMetricOrigin:
        _impl_.geometry_.metric_origin_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geometry_.metric_origin_);
        break;
  }
  switch (accuracy_case()) {
    case ACCURACY_NOT_SET:
      break;
      case kCombinedStdDev:
        _impl_.accuracy_.combined_std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.combined_std_dev_);
        break;
      case kStdDev:
        _impl_.accuracy_.std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.std_dev_);
        break;
      case kCovariance:
        _impl_.accuracy_.covariance_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.covariance_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE XyzVectorAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : extension_{visibility, arena},
        geometry_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void XyzVectorAndAccuracy::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
XyzVectorAndAccuracy::~XyzVectorAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  SharedDtor(*this);
}
inline void XyzVectorAndAccuracy::SharedDtor(MessageLite& self) {
  XyzVectorAndAccuracy& this_ = static_cast<XyzVectorAndAccuracy&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_geometry()) {
    this_.clear_geometry();
  }
  if (this_.has_accuracy()) {
    this_.clear_accuracy();
  }
  this_._impl_.~Impl_();
}

void XyzVectorAndAccuracy::clear_geometry() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (geometry_case()) {
    case kMetricVehicle: {
      if (GetArena() == nullptr) {
        delete _impl_.geometry_.metric_vehicle_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geometry_.metric_vehicle_);
      }
      break;
    }
    case kMetricEventGroup: {
      if (GetArena() == nullptr) {
        delete _impl_.geometry_.metric_event_group_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geometry_.metric_event_group_);
      }
      break;
    }
    case kMetricOrigin: {
      if (GetArena() == nullptr) {
        delete _impl_.geometry_.metric_origin_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geometry_.metric_origin_);
      }
      break;
    }
    case GEOMETRY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = GEOMETRY_NOT_SET;
}

void XyzVectorAndAccuracy::clear_accuracy() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (accuracy_case()) {
    case kCombinedStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.combined_std_dev_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.combined_std_dev_);
      }
      break;
    }
    case kStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.std_dev_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.std_dev_);
      }
      break;
    }
    case kCovariance: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.covariance_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.covariance_);
      }
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = ACCURACY_NOT_SET;
}


inline void* PROTOBUF_NONNULL XyzVectorAndAccuracy::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) XyzVectorAndAccuracy(arena);
}
constexpr auto XyzVectorAndAccuracy::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.extension_) +
          decltype(XyzVectorAndAccuracy::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(XyzVectorAndAccuracy), alignof(XyzVectorAndAccuracy), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&XyzVectorAndAccuracy::PlacementNew_,
                                 sizeof(XyzVectorAndAccuracy),
                                 alignof(XyzVectorAndAccuracy));
  }
}
constexpr auto XyzVectorAndAccuracy::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_XyzVectorAndAccuracy_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &XyzVectorAndAccuracy::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<XyzVectorAndAccuracy>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &XyzVectorAndAccuracy::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<XyzVectorAndAccuracy>(), &XyzVectorAndAccuracy::ByteSizeLong,
              &XyzVectorAndAccuracy::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_._cached_size_),
          false,
      },
      &XyzVectorAndAccuracy::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull XyzVectorAndAccuracy_class_data_ =
        XyzVectorAndAccuracy::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
XyzVectorAndAccuracy::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&XyzVectorAndAccuracy_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(XyzVectorAndAccuracy_class_data_.tc_table);
  return XyzVectorAndAccuracy_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 7, 7, 0, 2>
XyzVectorAndAccuracy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    15, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950848,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    XyzVectorAndAccuracy_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 6, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_vehicle = 1;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.geometry_.metric_vehicle_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_event_group = 2;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.geometry_.metric_event_group_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_origin = 3;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.geometry_.metric_origin_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value combined_std_dev = 4;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.accuracy_.combined_std_dev_), _Internal::kOneofCaseOffset + 4, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev std_dev = 5;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.accuracy_.std_dev_), _Internal::kOneofCaseOffset + 4, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.accuracy_.covariance_), _Internal::kOneofCaseOffset + 4, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.extension_), 0, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Matrix3x3>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void XyzVectorAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  clear_geometry();
  clear_accuracy();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL XyzVectorAndAccuracy::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const XyzVectorAndAccuracy& this_ = static_cast<const XyzVectorAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL XyzVectorAndAccuracy::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const XyzVectorAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (this_.geometry_case()) {
    case kMetricVehicle: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          1, *this_._impl_.geometry_.metric_vehicle_, this_._impl_.geometry_.metric_vehicle_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMetricEventGroup: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          2, *this_._impl_.geometry_.metric_event_group_, this_._impl_.geometry_.metric_event_group_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMetricOrigin: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, *this_._impl_.geometry_.metric_origin_, this_._impl_.geometry_.metric_origin_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  switch (this_.accuracy_case()) {
    case kCombinedStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *this_._impl_.accuracy_.combined_std_dev_, this_._impl_.accuracy_.combined_std_dev_->GetCachedSize(), target,
          stream);
      break;
    }
    case kStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *this_._impl_.accuracy_.std_dev_, this_._impl_.accuracy_.std_dev_->GetCachedSize(), target,
          stream);
      break;
    }
    case kCovariance: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *this_._impl_.accuracy_.covariance_, this_._impl_.accuracy_.covariance_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t XyzVectorAndAccuracy::ByteSizeLong(const MessageLite& base) {
  const XyzVectorAndAccuracy& this_ = static_cast<const XyzVectorAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t XyzVectorAndAccuracy::ByteSizeLong() const {
  const XyzVectorAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  switch (this_.geometry_case()) {
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_vehicle = 1;
    case kMetricVehicle: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.geometry_.metric_vehicle_);
      break;
    }
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_event_group = 2;
    case kMetricEventGroup: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.geometry_.metric_event_group_);
      break;
    }
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_origin = 3;
    case kMetricOrigin: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.geometry_.metric_origin_);
      break;
    }
    case GEOMETRY_NOT_SET: {
      break;
    }
  }
  switch (this_.accuracy_case()) {
    // .google.protobuf.Int64Value combined_std_dev = 4;
    case kCombinedStdDev: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.combined_std_dev_);
      break;
    }
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev std_dev = 5;
    case kStdDev: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.std_dev_);
      break;
    }
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6;
    case kCovariance: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.covariance_);
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void XyzVectorAndAccuracy::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<XyzVectorAndAccuracy*>(&to_msg);
  auto& from = static_cast<const XyzVectorAndAccuracy&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_geometry();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kMetricVehicle: {
        if (oneof_needs_init) {
          _this->_impl_.geometry_.metric_vehicle_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geometry_.metric_vehicle_);
        } else {
          _this->_impl_.geometry_.metric_vehicle_->MergeFrom(*from._impl_.geometry_.metric_vehicle_);
        }
        break;
      }
      case kMetricEventGroup: {
        if (oneof_needs_init) {
          _this->_impl_.geometry_.metric_event_group_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geometry_.metric_event_group_);
        } else {
          _this->_impl_.geometry_.metric_event_group_->MergeFrom(*from._impl_.geometry_.metric_event_group_);
        }
        break;
      }
      case kMetricOrigin: {
        if (oneof_needs_init) {
          _this->_impl_.geometry_.metric_origin_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geometry_.metric_origin_);
        } else {
          _this->_impl_.geometry_.metric_origin_->MergeFrom(*from._impl_.geometry_.metric_origin_);
        }
        break;
      }
      case GEOMETRY_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_accuracy();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kCombinedStdDev: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.combined_std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.combined_std_dev_);
        } else {
          _this->_impl_.accuracy_.combined_std_dev_->MergeFrom(*from._impl_.accuracy_.combined_std_dev_);
        }
        break;
      }
      case kStdDev: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.std_dev_);
        } else {
          _this->_impl_.accuracy_.std_dev_->MergeFrom(*from._impl_.accuracy_.std_dev_);
        }
        break;
      }
      case kCovariance: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.covariance_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.covariance_);
        } else {
          _this->_impl_.accuracy_.covariance_->MergeFrom(*from._impl_.accuracy_.covariance_);
        }
        break;
      }
      case ACCURACY_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void XyzVectorAndAccuracy::CopyFrom(const XyzVectorAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void XyzVectorAndAccuracy::InternalSwap(XyzVectorAndAccuracy* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  swap(_impl_.geometry_, other->_impl_.geometry_);
  swap(_impl_.accuracy_, other->_impl_.accuracy_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata XyzVectorAndAccuracy::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RectangularBoxAndAccuracy_CornerVectors::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RectangularBoxAndAccuracy_CornerVectors>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_._has_bits_);
};

RectangularBoxAndAccuracy_CornerVectors::RectangularBoxAndAccuracy_CornerVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RectangularBoxAndAccuracy_CornerVectors_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
}
PROTOBUF_NDEBUG_INLINE RectangularBoxAndAccuracy_CornerVectors::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RectangularBoxAndAccuracy_CornerVectors::RectangularBoxAndAccuracy_CornerVectors(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RectangularBoxAndAccuracy_CornerVectors& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RectangularBoxAndAccuracy_CornerVectors_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RectangularBoxAndAccuracy_CornerVectors* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.first_and_accuracy_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.first_and_accuracy_)
                : nullptr;
  _impl_.second_and_accuracy_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.second_and_accuracy_)
                : nullptr;
  _impl_.third_and_accuracy_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.third_and_accuracy_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
}
PROTOBUF_NDEBUG_INLINE RectangularBoxAndAccuracy_CornerVectors::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void RectangularBoxAndAccuracy_CornerVectors::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, first_and_accuracy_),
           0,
           offsetof(Impl_, third_and_accuracy_) -
               offsetof(Impl_, first_and_accuracy_) +
               sizeof(Impl_::third_and_accuracy_));
}
RectangularBoxAndAccuracy_CornerVectors::~RectangularBoxAndAccuracy_CornerVectors() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  SharedDtor(*this);
}
inline void RectangularBoxAndAccuracy_CornerVectors::SharedDtor(MessageLite& self) {
  RectangularBoxAndAccuracy_CornerVectors& this_ = static_cast<RectangularBoxAndAccuracy_CornerVectors&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.first_and_accuracy_;
  delete this_._impl_.second_and_accuracy_;
  delete this_._impl_.third_and_accuracy_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CornerVectors::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RectangularBoxAndAccuracy_CornerVectors(arena);
}
constexpr auto RectangularBoxAndAccuracy_CornerVectors::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(RectangularBoxAndAccuracy_CornerVectors),
                                            alignof(RectangularBoxAndAccuracy_CornerVectors));
}
constexpr auto RectangularBoxAndAccuracy_CornerVectors::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RectangularBoxAndAccuracy_CornerVectors_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RectangularBoxAndAccuracy_CornerVectors::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RectangularBoxAndAccuracy_CornerVectors>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RectangularBoxAndAccuracy_CornerVectors::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RectangularBoxAndAccuracy_CornerVectors>(), &RectangularBoxAndAccuracy_CornerVectors::ByteSizeLong,
              &RectangularBoxAndAccuracy_CornerVectors::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_._cached_size_),
          false,
      },
      &RectangularBoxAndAccuracy_CornerVectors::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RectangularBoxAndAccuracy_CornerVectors_class_data_ =
        RectangularBoxAndAccuracy_CornerVectors::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RectangularBoxAndAccuracy_CornerVectors::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RectangularBoxAndAccuracy_CornerVectors_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RectangularBoxAndAccuracy_CornerVectors_class_data_.tc_table);
  return RectangularBoxAndAccuracy_CornerVectors_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
RectangularBoxAndAccuracy_CornerVectors::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RectangularBoxAndAccuracy_CornerVectors_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.first_and_accuracy_)}},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.second_and_accuracy_)}},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.third_and_accuracy_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.first_and_accuracy_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.second_and_accuracy_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.third_and_accuracy_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RectangularBoxAndAccuracy_CornerVectors::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.first_and_accuracy_ != nullptr);
      _impl_.first_and_accuracy_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.second_and_accuracy_ != nullptr);
      _impl_.second_and_accuracy_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.third_and_accuracy_ != nullptr);
      _impl_.third_and_accuracy_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CornerVectors::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RectangularBoxAndAccuracy_CornerVectors& this_ = static_cast<const RectangularBoxAndAccuracy_CornerVectors&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CornerVectors::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RectangularBoxAndAccuracy_CornerVectors& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.first_and_accuracy_, this_._impl_.first_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.second_and_accuracy_, this_._impl_.second_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.third_and_accuracy_, this_._impl_.third_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RectangularBoxAndAccuracy_CornerVectors::ByteSizeLong(const MessageLite& base) {
  const RectangularBoxAndAccuracy_CornerVectors& this_ = static_cast<const RectangularBoxAndAccuracy_CornerVectors&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RectangularBoxAndAccuracy_CornerVectors::ByteSizeLong() const {
  const RectangularBoxAndAccuracy_CornerVectors& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.first_and_accuracy_);
    }
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.second_and_accuracy_);
    }
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.third_and_accuracy_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RectangularBoxAndAccuracy_CornerVectors::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RectangularBoxAndAccuracy_CornerVectors*>(&to_msg);
  auto& from = static_cast<const RectangularBoxAndAccuracy_CornerVectors&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.first_and_accuracy_ != nullptr);
      if (_this->_impl_.first_and_accuracy_ == nullptr) {
        _this->_impl_.first_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.first_and_accuracy_);
      } else {
        _this->_impl_.first_and_accuracy_->MergeFrom(*from._impl_.first_and_accuracy_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.second_and_accuracy_ != nullptr);
      if (_this->_impl_.second_and_accuracy_ == nullptr) {
        _this->_impl_.second_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.second_and_accuracy_);
      } else {
        _this->_impl_.second_and_accuracy_->MergeFrom(*from._impl_.second_and_accuracy_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.third_and_accuracy_ != nullptr);
      if (_this->_impl_.third_and_accuracy_ == nullptr) {
        _this->_impl_.third_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.third_and_accuracy_);
      } else {
        _this->_impl_.third_and_accuracy_->MergeFrom(*from._impl_.third_and_accuracy_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RectangularBoxAndAccuracy_CornerVectors::CopyFrom(const RectangularBoxAndAccuracy_CornerVectors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RectangularBoxAndAccuracy_CornerVectors::InternalSwap(RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.third_and_accuracy_)
      + sizeof(RectangularBoxAndAccuracy_CornerVectors::_impl_.third_and_accuracy_)
      - PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.first_and_accuracy_)>(
          reinterpret_cast<char*>(&_impl_.first_and_accuracy_),
          reinterpret_cast<char*>(&other->_impl_.first_and_accuracy_));
}

::google::protobuf::Metadata RectangularBoxAndAccuracy_CornerVectors::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RectangularBoxAndAccuracy_CenterOrientationSize::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RectangularBoxAndAccuracy_CenterOrientationSize>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_._has_bits_);
};

RectangularBoxAndAccuracy_CenterOrientationSize::RectangularBoxAndAccuracy_CenterOrientationSize(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RectangularBoxAndAccuracy_CenterOrientationSize_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
}
PROTOBUF_NDEBUG_INLINE RectangularBoxAndAccuracy_CenterOrientationSize::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RectangularBoxAndAccuracy_CenterOrientationSize::RectangularBoxAndAccuracy_CenterOrientationSize(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RectangularBoxAndAccuracy_CenterOrientationSize& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RectangularBoxAndAccuracy_CenterOrientationSize_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RectangularBoxAndAccuracy_CenterOrientationSize* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.center_position_and_accuracy_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.center_position_and_accuracy_)
                : nullptr;
  _impl_.orientation_and_accuracy_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.orientation_and_accuracy_)
                : nullptr;
  _impl_.size_and_accuracy_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.size_and_accuracy_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
}
PROTOBUF_NDEBUG_INLINE RectangularBoxAndAccuracy_CenterOrientationSize::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void RectangularBoxAndAccuracy_CenterOrientationSize::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, center_position_and_accuracy_),
           0,
           offsetof(Impl_, size_and_accuracy_) -
               offsetof(Impl_, center_position_and_accuracy_) +
               sizeof(Impl_::size_and_accuracy_));
}
RectangularBoxAndAccuracy_CenterOrientationSize::~RectangularBoxAndAccuracy_CenterOrientationSize() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  SharedDtor(*this);
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::SharedDtor(MessageLite& self) {
  RectangularBoxAndAccuracy_CenterOrientationSize& this_ = static_cast<RectangularBoxAndAccuracy_CenterOrientationSize&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.center_position_and_accuracy_;
  delete this_._impl_.orientation_and_accuracy_;
  delete this_._impl_.size_and_accuracy_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CenterOrientationSize::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RectangularBoxAndAccuracy_CenterOrientationSize(arena);
}
constexpr auto RectangularBoxAndAccuracy_CenterOrientationSize::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(RectangularBoxAndAccuracy_CenterOrientationSize),
                                            alignof(RectangularBoxAndAccuracy_CenterOrientationSize));
}
constexpr auto RectangularBoxAndAccuracy_CenterOrientationSize::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RectangularBoxAndAccuracy_CenterOrientationSize::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RectangularBoxAndAccuracy_CenterOrientationSize>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RectangularBoxAndAccuracy_CenterOrientationSize::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RectangularBoxAndAccuracy_CenterOrientationSize>(), &RectangularBoxAndAccuracy_CenterOrientationSize::ByteSizeLong,
              &RectangularBoxAndAccuracy_CenterOrientationSize::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_._cached_size_),
          false,
      },
      &RectangularBoxAndAccuracy_CenterOrientationSize::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RectangularBoxAndAccuracy_CenterOrientationSize_class_data_ =
        RectangularBoxAndAccuracy_CenterOrientationSize::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RectangularBoxAndAccuracy_CenterOrientationSize::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RectangularBoxAndAccuracy_CenterOrientationSize_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RectangularBoxAndAccuracy_CenterOrientationSize_class_data_.tc_table);
  return RectangularBoxAndAccuracy_CenterOrientationSize_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
RectangularBoxAndAccuracy_CenterOrientationSize::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RectangularBoxAndAccuracy_CenterOrientationSize_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.center_position_and_accuracy_)}},
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.orientation_and_accuracy_)}},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.size_and_accuracy_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.center_position_and_accuracy_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.orientation_and_accuracy_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.size_and_accuracy_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RectangularBoxAndAccuracy_CenterOrientationSize::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.center_position_and_accuracy_ != nullptr);
      _impl_.center_position_and_accuracy_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.orientation_and_accuracy_ != nullptr);
      _impl_.orientation_and_accuracy_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.size_and_accuracy_ != nullptr);
      _impl_.size_and_accuracy_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CenterOrientationSize::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RectangularBoxAndAccuracy_CenterOrientationSize& this_ = static_cast<const RectangularBoxAndAccuracy_CenterOrientationSize&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CenterOrientationSize::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RectangularBoxAndAccuracy_CenterOrientationSize& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.center_position_and_accuracy_, this_._impl_.center_position_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.orientation_and_accuracy_, this_._impl_.orientation_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.size_and_accuracy_, this_._impl_.size_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RectangularBoxAndAccuracy_CenterOrientationSize::ByteSizeLong(const MessageLite& base) {
  const RectangularBoxAndAccuracy_CenterOrientationSize& this_ = static_cast<const RectangularBoxAndAccuracy_CenterOrientationSize&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RectangularBoxAndAccuracy_CenterOrientationSize::ByteSizeLong() const {
  const RectangularBoxAndAccuracy_CenterOrientationSize& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.center_position_and_accuracy_);
    }
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.orientation_and_accuracy_);
    }
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.size_and_accuracy_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RectangularBoxAndAccuracy_CenterOrientationSize::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RectangularBoxAndAccuracy_CenterOrientationSize*>(&to_msg);
  auto& from = static_cast<const RectangularBoxAndAccuracy_CenterOrientationSize&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.center_position_and_accuracy_ != nullptr);
      if (_this->_impl_.center_position_and_accuracy_ == nullptr) {
        _this->_impl_.center_position_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.center_position_and_accuracy_);
      } else {
        _this->_impl_.center_position_and_accuracy_->MergeFrom(*from._impl_.center_position_and_accuracy_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.orientation_and_accuracy_ != nullptr);
      if (_this->_impl_.orientation_and_accuracy_ == nullptr) {
        _this->_impl_.orientation_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.orientation_and_accuracy_);
      } else {
        _this->_impl_.orientation_and_accuracy_->MergeFrom(*from._impl_.orientation_and_accuracy_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.size_and_accuracy_ != nullptr);
      if (_this->_impl_.size_and_accuracy_ == nullptr) {
        _this->_impl_.size_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.size_and_accuracy_);
      } else {
        _this->_impl_.size_and_accuracy_->MergeFrom(*from._impl_.size_and_accuracy_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RectangularBoxAndAccuracy_CenterOrientationSize::CopyFrom(const RectangularBoxAndAccuracy_CenterOrientationSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RectangularBoxAndAccuracy_CenterOrientationSize::InternalSwap(RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.size_and_accuracy_)
      + sizeof(RectangularBoxAndAccuracy_CenterOrientationSize::_impl_.size_and_accuracy_)
      - PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.center_position_and_accuracy_)>(
          reinterpret_cast<char*>(&_impl_.center_position_and_accuracy_),
          reinterpret_cast<char*>(&other->_impl_.center_position_and_accuracy_));
}

::google::protobuf::Metadata RectangularBoxAndAccuracy_CenterOrientationSize::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RectangularBoxAndAccuracy::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy, _impl_._oneof_case_);
};

void RectangularBoxAndAccuracy::set_allocated_corner_vectors(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NULLABLE corner_vectors) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geometry();
  if (corner_vectors) {
    ::google::protobuf::Arena* submessage_arena = corner_vectors->GetArena();
    if (message_arena != submessage_arena) {
      corner_vectors = ::google::protobuf::internal::GetOwnedMessage(message_arena, corner_vectors, submessage_arena);
    }
    set_has_corner_vectors();
    _impl_.geometry_.corner_vectors_ = corner_vectors;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
}
void RectangularBoxAndAccuracy::set_allocated_center_orientation_size(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NULLABLE center_orientation_size) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geometry();
  if (center_orientation_size) {
    ::google::protobuf::Arena* submessage_arena = center_orientation_size->GetArena();
    if (message_arena != submessage_arena) {
      center_orientation_size = ::google::protobuf::internal::GetOwnedMessage(message_arena, center_orientation_size, submessage_arena);
    }
    set_has_center_orientation_size();
    _impl_.geometry_.center_orientation_size_ = center_orientation_size;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
}
void RectangularBoxAndAccuracy::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
RectangularBoxAndAccuracy::RectangularBoxAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RectangularBoxAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE RectangularBoxAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& from_msg)
      : extension_{visibility, arena, from.extension_},
        geometry_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0]} {}

RectangularBoxAndAccuracy::RectangularBoxAndAccuracy(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RectangularBoxAndAccuracy& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RectangularBoxAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RectangularBoxAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (geometry_case()) {
    case GEOMETRY_NOT_SET:
      break;
      case kCornerVectors:
        _impl_.geometry_.corner_vectors_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geometry_.corner_vectors_);
        break;
      case kCenterOrientationSize:
        _impl_.geometry_.center_orientation_size_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geometry_.center_orientation_size_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE RectangularBoxAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : extension_{visibility, arena},
        geometry_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void RectangularBoxAndAccuracy::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
RectangularBoxAndAccuracy::~RectangularBoxAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  SharedDtor(*this);
}
inline void RectangularBoxAndAccuracy::SharedDtor(MessageLite& self) {
  RectangularBoxAndAccuracy& this_ = static_cast<RectangularBoxAndAccuracy&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_geometry()) {
    this_.clear_geometry();
  }
  this_._impl_.~Impl_();
}

void RectangularBoxAndAccuracy::clear_geometry() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (geometry_case()) {
    case kCornerVectors: {
      if (GetArena() == nullptr) {
        delete _impl_.geometry_.corner_vectors_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geometry_.corner_vectors_);
      }
      break;
    }
    case kCenterOrientationSize: {
      if (GetArena() == nullptr) {
        delete _impl_.geometry_.center_orientation_size_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geometry_.center_orientation_size_);
      }
      break;
    }
    case GEOMETRY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = GEOMETRY_NOT_SET;
}


inline void* PROTOBUF_NONNULL RectangularBoxAndAccuracy::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RectangularBoxAndAccuracy(arena);
}
constexpr auto RectangularBoxAndAccuracy::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy, _impl_.extension_) +
          decltype(RectangularBoxAndAccuracy::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(RectangularBoxAndAccuracy), alignof(RectangularBoxAndAccuracy), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&RectangularBoxAndAccuracy::PlacementNew_,
                                 sizeof(RectangularBoxAndAccuracy),
                                 alignof(RectangularBoxAndAccuracy));
  }
}
constexpr auto RectangularBoxAndAccuracy::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RectangularBoxAndAccuracy_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RectangularBoxAndAccuracy::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RectangularBoxAndAccuracy>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RectangularBoxAndAccuracy::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RectangularBoxAndAccuracy>(), &RectangularBoxAndAccuracy::ByteSizeLong,
              &RectangularBoxAndAccuracy::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy, _impl_._cached_size_),
          false,
      },
      &RectangularBoxAndAccuracy::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RectangularBoxAndAccuracy_class_data_ =
        RectangularBoxAndAccuracy::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RectangularBoxAndAccuracy::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RectangularBoxAndAccuracy_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RectangularBoxAndAccuracy_class_data_.tc_table);
  return RectangularBoxAndAccuracy_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 3, 3, 0, 2>
RectangularBoxAndAccuracy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    15, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950908,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RectangularBoxAndAccuracy_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 2, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors corner_vectors = 1;
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy, _impl_.geometry_.corner_vectors_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize center_orientation_size = 2;
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy, _impl_.geometry_.center_orientation_size_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy, _impl_.extension_), 0, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RectangularBoxAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  clear_geometry();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RectangularBoxAndAccuracy::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RectangularBoxAndAccuracy& this_ = static_cast<const RectangularBoxAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RectangularBoxAndAccuracy::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RectangularBoxAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (this_.geometry_case()) {
    case kCornerVectors: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          1, *this_._impl_.geometry_.corner_vectors_, this_._impl_.geometry_.corner_vectors_->GetCachedSize(), target,
          stream);
      break;
    }
    case kCenterOrientationSize: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          2, *this_._impl_.geometry_.center_orientation_size_, this_._impl_.geometry_.center_orientation_size_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RectangularBoxAndAccuracy::ByteSizeLong(const MessageLite& base) {
  const RectangularBoxAndAccuracy& this_ = static_cast<const RectangularBoxAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RectangularBoxAndAccuracy::ByteSizeLong() const {
  const RectangularBoxAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  switch (this_.geometry_case()) {
    // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors corner_vectors = 1;
    case kCornerVectors: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.geometry_.corner_vectors_);
      break;
    }
    // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize center_orientation_size = 2;
    case kCenterOrientationSize: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.geometry_.center_orientation_size_);
      break;
    }
    case GEOMETRY_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RectangularBoxAndAccuracy::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RectangularBoxAndAccuracy*>(&to_msg);
  auto& from = static_cast<const RectangularBoxAndAccuracy&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_geometry();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kCornerVectors: {
        if (oneof_needs_init) {
          _this->_impl_.geometry_.corner_vectors_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geometry_.corner_vectors_);
        } else {
          _this->_impl_.geometry_.corner_vectors_->MergeFrom(*from._impl_.geometry_.corner_vectors_);
        }
        break;
      }
      case kCenterOrientationSize: {
        if (oneof_needs_init) {
          _this->_impl_.geometry_.center_orientation_size_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.geometry_.center_orientation_size_);
        } else {
          _this->_impl_.geometry_.center_orientation_size_->MergeFrom(*from._impl_.geometry_.center_orientation_size_);
        }
        break;
      }
      case GEOMETRY_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RectangularBoxAndAccuracy::CopyFrom(const RectangularBoxAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RectangularBoxAndAccuracy::InternalSwap(RectangularBoxAndAccuracy* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  swap(_impl_.geometry_, other->_impl_.geometry_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata RectangularBoxAndAccuracy::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RotationAndAccuracy_Euler::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RotationAndAccuracy_Euler>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_._has_bits_);
};

void RotationAndAccuracy_Euler::clear_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.yaw_ != nullptr) _impl_.yaw_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RotationAndAccuracy_Euler::clear_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pitch_ != nullptr) _impl_.pitch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RotationAndAccuracy_Euler::clear_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.roll_ != nullptr) _impl_.roll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RotationAndAccuracy_Euler::RotationAndAccuracy_Euler(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RotationAndAccuracy_Euler_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
}
PROTOBUF_NDEBUG_INLINE RotationAndAccuracy_Euler::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RotationAndAccuracy_Euler::RotationAndAccuracy_Euler(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RotationAndAccuracy_Euler& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RotationAndAccuracy_Euler_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RotationAndAccuracy_Euler* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.yaw_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.yaw_)
                : nullptr;
  _impl_.pitch_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.pitch_)
                : nullptr;
  _impl_.roll_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.roll_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
}
PROTOBUF_NDEBUG_INLINE RotationAndAccuracy_Euler::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void RotationAndAccuracy_Euler::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, yaw_),
           0,
           offsetof(Impl_, roll_) -
               offsetof(Impl_, yaw_) +
               sizeof(Impl_::roll_));
}
RotationAndAccuracy_Euler::~RotationAndAccuracy_Euler() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  SharedDtor(*this);
}
inline void RotationAndAccuracy_Euler::SharedDtor(MessageLite& self) {
  RotationAndAccuracy_Euler& this_ = static_cast<RotationAndAccuracy_Euler&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.yaw_;
  delete this_._impl_.pitch_;
  delete this_._impl_.roll_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RotationAndAccuracy_Euler::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RotationAndAccuracy_Euler(arena);
}
constexpr auto RotationAndAccuracy_Euler::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(RotationAndAccuracy_Euler),
                                            alignof(RotationAndAccuracy_Euler));
}
constexpr auto RotationAndAccuracy_Euler::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RotationAndAccuracy_Euler_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RotationAndAccuracy_Euler::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RotationAndAccuracy_Euler>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RotationAndAccuracy_Euler::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RotationAndAccuracy_Euler>(), &RotationAndAccuracy_Euler::ByteSizeLong,
              &RotationAndAccuracy_Euler::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_._cached_size_),
          false,
      },
      &RotationAndAccuracy_Euler::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RotationAndAccuracy_Euler_class_data_ =
        RotationAndAccuracy_Euler::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RotationAndAccuracy_Euler::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RotationAndAccuracy_Euler_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RotationAndAccuracy_Euler_class_data_.tc_table);
  return RotationAndAccuracy_Euler_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
RotationAndAccuracy_Euler::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RotationAndAccuracy_Euler_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.yaw_)}},
    // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.pitch_)}},
    // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.roll_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.yaw_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.pitch_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.roll_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RotationAndAccuracy_Euler::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.yaw_ != nullptr);
      _impl_.yaw_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.pitch_ != nullptr);
      _impl_.pitch_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.roll_ != nullptr);
      _impl_.roll_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RotationAndAccuracy_Euler::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RotationAndAccuracy_Euler& this_ = static_cast<const RotationAndAccuracy_Euler&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RotationAndAccuracy_Euler::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RotationAndAccuracy_Euler& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.yaw_, this_._impl_.yaw_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.pitch_, this_._impl_.pitch_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.roll_, this_._impl_.roll_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RotationAndAccuracy_Euler::ByteSizeLong(const MessageLite& base) {
  const RotationAndAccuracy_Euler& this_ = static_cast<const RotationAndAccuracy_Euler&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RotationAndAccuracy_Euler::ByteSizeLong() const {
  const RotationAndAccuracy_Euler& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.yaw_);
    }
    // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.pitch_);
    }
    // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.roll_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RotationAndAccuracy_Euler::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RotationAndAccuracy_Euler*>(&to_msg);
  auto& from = static_cast<const RotationAndAccuracy_Euler&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.yaw_ != nullptr);
      if (_this->_impl_.yaw_ == nullptr) {
        _this->_impl_.yaw_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.yaw_);
      } else {
        _this->_impl_.yaw_->MergeFrom(*from._impl_.yaw_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.pitch_ != nullptr);
      if (_this->_impl_.pitch_ == nullptr) {
        _this->_impl_.pitch_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.pitch_);
      } else {
        _this->_impl_.pitch_->MergeFrom(*from._impl_.pitch_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.roll_ != nullptr);
      if (_this->_impl_.roll_ == nullptr) {
        _this->_impl_.roll_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.roll_);
      } else {
        _this->_impl_.roll_->MergeFrom(*from._impl_.roll_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RotationAndAccuracy_Euler::CopyFrom(const RotationAndAccuracy_Euler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RotationAndAccuracy_Euler::InternalSwap(RotationAndAccuracy_Euler* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.roll_)
      + sizeof(RotationAndAccuracy_Euler::_impl_.roll_)
      - PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.yaw_)>(
          reinterpret_cast<char*>(&_impl_.yaw_),
          reinterpret_cast<char*>(&other->_impl_.yaw_));
}

::google::protobuf::Metadata RotationAndAccuracy_Euler::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RotationAndAccuracy_Quaternion::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RotationAndAccuracy_Quaternion>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_._has_bits_);
};

void RotationAndAccuracy_Quaternion::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ != nullptr) _impl_.x_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RotationAndAccuracy_Quaternion::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ != nullptr) _impl_.y_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RotationAndAccuracy_Quaternion::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ != nullptr) _impl_.z_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void RotationAndAccuracy_Quaternion::clear_w() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.w_ != nullptr) _impl_.w_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
RotationAndAccuracy_Quaternion::RotationAndAccuracy_Quaternion(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RotationAndAccuracy_Quaternion_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
}
PROTOBUF_NDEBUG_INLINE RotationAndAccuracy_Quaternion::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RotationAndAccuracy_Quaternion::RotationAndAccuracy_Quaternion(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RotationAndAccuracy_Quaternion& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RotationAndAccuracy_Quaternion_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RotationAndAccuracy_Quaternion* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.x_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.x_)
                : nullptr;
  _impl_.y_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.y_)
                : nullptr;
  _impl_.z_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.z_)
                : nullptr;
  _impl_.w_ = ((cached_has_bits & 0x00000008u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.w_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
}
PROTOBUF_NDEBUG_INLINE RotationAndAccuracy_Quaternion::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void RotationAndAccuracy_Quaternion::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, w_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::w_));
}
RotationAndAccuracy_Quaternion::~RotationAndAccuracy_Quaternion() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  SharedDtor(*this);
}
inline void RotationAndAccuracy_Quaternion::SharedDtor(MessageLite& self) {
  RotationAndAccuracy_Quaternion& this_ = static_cast<RotationAndAccuracy_Quaternion&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.x_;
  delete this_._impl_.y_;
  delete this_._impl_.z_;
  delete this_._impl_.w_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RotationAndAccuracy_Quaternion::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RotationAndAccuracy_Quaternion(arena);
}
constexpr auto RotationAndAccuracy_Quaternion::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(RotationAndAccuracy_Quaternion),
                                            alignof(RotationAndAccuracy_Quaternion));
}
constexpr auto RotationAndAccuracy_Quaternion::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RotationAndAccuracy_Quaternion_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RotationAndAccuracy_Quaternion::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RotationAndAccuracy_Quaternion>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RotationAndAccuracy_Quaternion::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RotationAndAccuracy_Quaternion>(), &RotationAndAccuracy_Quaternion::ByteSizeLong,
              &RotationAndAccuracy_Quaternion::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_._cached_size_),
          false,
      },
      &RotationAndAccuracy_Quaternion::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RotationAndAccuracy_Quaternion_class_data_ =
        RotationAndAccuracy_Quaternion::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RotationAndAccuracy_Quaternion::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RotationAndAccuracy_Quaternion_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RotationAndAccuracy_Quaternion_class_data_.tc_table);
  return RotationAndAccuracy_Quaternion_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 4, 0, 2>
RotationAndAccuracy_Quaternion::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RotationAndAccuracy_Quaternion_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
    {::_pbi::TcParser::FastMtS1,
     {34, 3, 3, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.w_)}},
    // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.x_)}},
    // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.y_)}},
    // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.x_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.y_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.z_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.w_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RotationAndAccuracy_Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.x_ != nullptr);
      _impl_.x_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.y_ != nullptr);
      _impl_.y_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.z_ != nullptr);
      _impl_.z_->Clear();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(_impl_.w_ != nullptr);
      _impl_.w_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RotationAndAccuracy_Quaternion::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RotationAndAccuracy_Quaternion& this_ = static_cast<const RotationAndAccuracy_Quaternion&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RotationAndAccuracy_Quaternion::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RotationAndAccuracy_Quaternion& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.x_, this_._impl_.x_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.y_, this_._impl_.y_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.z_, this_._impl_.z_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.w_, this_._impl_.w_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RotationAndAccuracy_Quaternion::ByteSizeLong(const MessageLite& base) {
  const RotationAndAccuracy_Quaternion& this_ = static_cast<const RotationAndAccuracy_Quaternion&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RotationAndAccuracy_Quaternion::ByteSizeLong() const {
  const RotationAndAccuracy_Quaternion& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.x_);
    }
    // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.y_);
    }
    // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.z_);
    }
    // .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.w_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RotationAndAccuracy_Quaternion::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RotationAndAccuracy_Quaternion*>(&to_msg);
  auto& from = static_cast<const RotationAndAccuracy_Quaternion&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.x_ != nullptr);
      if (_this->_impl_.x_ == nullptr) {
        _this->_impl_.x_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.x_);
      } else {
        _this->_impl_.x_->MergeFrom(*from._impl_.x_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.y_ != nullptr);
      if (_this->_impl_.y_ == nullptr) {
        _this->_impl_.y_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.y_);
      } else {
        _this->_impl_.y_->MergeFrom(*from._impl_.y_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.z_ != nullptr);
      if (_this->_impl_.z_ == nullptr) {
        _this->_impl_.z_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.z_);
      } else {
        _this->_impl_.z_->MergeFrom(*from._impl_.z_);
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(from._impl_.w_ != nullptr);
      if (_this->_impl_.w_ == nullptr) {
        _this->_impl_.w_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.w_);
      } else {
        _this->_impl_.w_->MergeFrom(*from._impl_.w_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RotationAndAccuracy_Quaternion::CopyFrom(const RotationAndAccuracy_Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RotationAndAccuracy_Quaternion::InternalSwap(RotationAndAccuracy_Quaternion* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.w_)
      + sizeof(RotationAndAccuracy_Quaternion::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata RotationAndAccuracy_Quaternion::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RotationAndAccuracy_StdDev::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RotationAndAccuracy_StdDev>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_._has_bits_);
};

void RotationAndAccuracy_StdDev::clear_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.yaw_ != nullptr) _impl_.yaw_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RotationAndAccuracy_StdDev::clear_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pitch_ != nullptr) _impl_.pitch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RotationAndAccuracy_StdDev::clear_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.roll_ != nullptr) _impl_.roll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RotationAndAccuracy_StdDev::RotationAndAccuracy_StdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RotationAndAccuracy_StdDev_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
}
PROTOBUF_NDEBUG_INLINE RotationAndAccuracy_StdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RotationAndAccuracy_StdDev::RotationAndAccuracy_StdDev(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RotationAndAccuracy_StdDev& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RotationAndAccuracy_StdDev_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RotationAndAccuracy_StdDev* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.yaw_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.yaw_)
                : nullptr;
  _impl_.pitch_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.pitch_)
                : nullptr;
  _impl_.roll_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.roll_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
}
PROTOBUF_NDEBUG_INLINE RotationAndAccuracy_StdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void RotationAndAccuracy_StdDev::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, yaw_),
           0,
           offsetof(Impl_, roll_) -
               offsetof(Impl_, yaw_) +
               sizeof(Impl_::roll_));
}
RotationAndAccuracy_StdDev::~RotationAndAccuracy_StdDev() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  SharedDtor(*this);
}
inline void RotationAndAccuracy_StdDev::SharedDtor(MessageLite& self) {
  RotationAndAccuracy_StdDev& this_ = static_cast<RotationAndAccuracy_StdDev&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.yaw_;
  delete this_._impl_.pitch_;
  delete this_._impl_.roll_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RotationAndAccuracy_StdDev::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RotationAndAccuracy_StdDev(arena);
}
constexpr auto RotationAndAccuracy_StdDev::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(RotationAndAccuracy_StdDev),
                                            alignof(RotationAndAccuracy_StdDev));
}
constexpr auto RotationAndAccuracy_StdDev::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RotationAndAccuracy_StdDev_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RotationAndAccuracy_StdDev::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RotationAndAccuracy_StdDev>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RotationAndAccuracy_StdDev::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RotationAndAccuracy_StdDev>(), &RotationAndAccuracy_StdDev::ByteSizeLong,
              &RotationAndAccuracy_StdDev::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_._cached_size_),
          false,
      },
      &RotationAndAccuracy_StdDev::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RotationAndAccuracy_StdDev_class_data_ =
        RotationAndAccuracy_StdDev::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RotationAndAccuracy_StdDev::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RotationAndAccuracy_StdDev_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RotationAndAccuracy_StdDev_class_data_.tc_table);
  return RotationAndAccuracy_StdDev_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
RotationAndAccuracy_StdDev::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RotationAndAccuracy_StdDev_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.yaw_)}},
    // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.pitch_)}},
    // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.roll_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.yaw_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.pitch_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.roll_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RotationAndAccuracy_StdDev::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.yaw_ != nullptr);
      _impl_.yaw_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.pitch_ != nullptr);
      _impl_.pitch_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.roll_ != nullptr);
      _impl_.roll_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RotationAndAccuracy_StdDev::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RotationAndAccuracy_StdDev& this_ = static_cast<const RotationAndAccuracy_StdDev&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RotationAndAccuracy_StdDev::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RotationAndAccuracy_StdDev& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.yaw_, this_._impl_.yaw_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.pitch_, this_._impl_.pitch_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.roll_, this_._impl_.roll_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RotationAndAccuracy_StdDev::ByteSizeLong(const MessageLite& base) {
  const RotationAndAccuracy_StdDev& this_ = static_cast<const RotationAndAccuracy_StdDev&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RotationAndAccuracy_StdDev::ByteSizeLong() const {
  const RotationAndAccuracy_StdDev& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.yaw_);
    }
    // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.pitch_);
    }
    // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.roll_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RotationAndAccuracy_StdDev::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RotationAndAccuracy_StdDev*>(&to_msg);
  auto& from = static_cast<const RotationAndAccuracy_StdDev&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.yaw_ != nullptr);
      if (_this->_impl_.yaw_ == nullptr) {
        _this->_impl_.yaw_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.yaw_);
      } else {
        _this->_impl_.yaw_->MergeFrom(*from._impl_.yaw_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.pitch_ != nullptr);
      if (_this->_impl_.pitch_ == nullptr) {
        _this->_impl_.pitch_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.pitch_);
      } else {
        _this->_impl_.pitch_->MergeFrom(*from._impl_.pitch_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.roll_ != nullptr);
      if (_this->_impl_.roll_ == nullptr) {
        _this->_impl_.roll_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.roll_);
      } else {
        _this->_impl_.roll_->MergeFrom(*from._impl_.roll_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RotationAndAccuracy_StdDev::CopyFrom(const RotationAndAccuracy_StdDev& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RotationAndAccuracy_StdDev::InternalSwap(RotationAndAccuracy_StdDev* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.roll_)
      + sizeof(RotationAndAccuracy_StdDev::_impl_.roll_)
      - PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.yaw_)>(
          reinterpret_cast<char*>(&_impl_.yaw_),
          reinterpret_cast<char*>(&other->_impl_.yaw_));
}

::google::protobuf::Metadata RotationAndAccuracy_StdDev::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RotationAndAccuracy::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy, _impl_._oneof_case_);
};

void RotationAndAccuracy::set_allocated_euler_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE euler_vehicle) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_euler_quaternion();
  if (euler_vehicle) {
    ::google::protobuf::Arena* submessage_arena = euler_vehicle->GetArena();
    if (message_arena != submessage_arena) {
      euler_vehicle = ::google::protobuf::internal::GetOwnedMessage(message_arena, euler_vehicle, submessage_arena);
    }
    set_has_euler_vehicle();
    _impl_.euler_quaternion_.euler_vehicle_ = euler_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
}
void RotationAndAccuracy::set_allocated_euler_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE euler_event_group) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_euler_quaternion();
  if (euler_event_group) {
    ::google::protobuf::Arena* submessage_arena = euler_event_group->GetArena();
    if (message_arena != submessage_arena) {
      euler_event_group = ::google::protobuf::internal::GetOwnedMessage(message_arena, euler_event_group, submessage_arena);
    }
    set_has_euler_event_group();
    _impl_.euler_quaternion_.euler_event_group_ = euler_event_group;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
}
void RotationAndAccuracy::set_allocated_quaternion_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE quaternion_vehicle) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_euler_quaternion();
  if (quaternion_vehicle) {
    ::google::protobuf::Arena* submessage_arena = quaternion_vehicle->GetArena();
    if (message_arena != submessage_arena) {
      quaternion_vehicle = ::google::protobuf::internal::GetOwnedMessage(message_arena, quaternion_vehicle, submessage_arena);
    }
    set_has_quaternion_vehicle();
    _impl_.euler_quaternion_.quaternion_vehicle_ = quaternion_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
}
void RotationAndAccuracy::set_allocated_quaternion_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE quaternion_event_group) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_euler_quaternion();
  if (quaternion_event_group) {
    ::google::protobuf::Arena* submessage_arena = quaternion_event_group->GetArena();
    if (message_arena != submessage_arena) {
      quaternion_event_group = ::google::protobuf::internal::GetOwnedMessage(message_arena, quaternion_event_group, submessage_arena);
    }
    set_has_quaternion_event_group();
    _impl_.euler_quaternion_.quaternion_event_group_ = quaternion_event_group;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
}
void RotationAndAccuracy::set_allocated_combined_std_dev(::google::protobuf::Int64Value* PROTOBUF_NULLABLE combined_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (combined_std_dev) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(combined_std_dev)->GetArena();
    if (message_arena != submessage_arena) {
      combined_std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, combined_std_dev, submessage_arena);
    }
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = combined_std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
}
void RotationAndAccuracy::clear_combined_std_dev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kCombinedStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.combined_std_dev_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.combined_std_dev_);
    }
    clear_has_accuracy();
  }
}
void RotationAndAccuracy::set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* PROTOBUF_NULLABLE std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (std_dev) {
    ::google::protobuf::Arena* submessage_arena = std_dev->GetArena();
    if (message_arena != submessage_arena) {
      std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, std_dev, submessage_arena);
    }
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
}
void RotationAndAccuracy::set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE covariance) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (covariance) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(covariance)->GetArena();
    if (message_arena != submessage_arena) {
      covariance = ::google::protobuf::internal::GetOwnedMessage(message_arena, covariance, submessage_arena);
    }
    set_has_covariance();
    _impl_.accuracy_.covariance_ = covariance;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
}
void RotationAndAccuracy::clear_covariance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kCovariance) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.covariance_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.covariance_);
    }
    clear_has_accuracy();
  }
}
void RotationAndAccuracy::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
RotationAndAccuracy::RotationAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RotationAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE RotationAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& from_msg)
      : extension_{visibility, arena, from.extension_},
        euler_quaternion_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

RotationAndAccuracy::RotationAndAccuracy(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RotationAndAccuracy& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RotationAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RotationAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (euler_quaternion_case()) {
    case EULER_QUATERNION_NOT_SET:
      break;
      case kEulerVehicle:
        _impl_.euler_quaternion_.euler_vehicle_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.euler_quaternion_.euler_vehicle_);
        break;
      case kEulerEventGroup:
        _impl_.euler_quaternion_.euler_event_group_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.euler_quaternion_.euler_event_group_);
        break;
      case kQuaternionVehicle:
        _impl_.euler_quaternion_.quaternion_vehicle_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.euler_quaternion_.quaternion_vehicle_);
        break;
      case kQuaternionEventGroup:
        _impl_.euler_quaternion_.quaternion_event_group_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.euler_quaternion_.quaternion_event_group_);
        break;
  }
  switch (accuracy_case()) {
    case ACCURACY_NOT_SET:
      break;
      case kCombinedStdDev:
        _impl_.accuracy_.combined_std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.combined_std_dev_);
        break;
      case kStdDev:
        _impl_.accuracy_.std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.std_dev_);
        break;
      case kCovariance:
        _impl_.accuracy_.covariance_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.covariance_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE RotationAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : extension_{visibility, arena},
        euler_quaternion_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void RotationAndAccuracy::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
RotationAndAccuracy::~RotationAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  SharedDtor(*this);
}
inline void RotationAndAccuracy::SharedDtor(MessageLite& self) {
  RotationAndAccuracy& this_ = static_cast<RotationAndAccuracy&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_euler_quaternion()) {
    this_.clear_euler_quaternion();
  }
  if (this_.has_accuracy()) {
    this_.clear_accuracy();
  }
  this_._impl_.~Impl_();
}

void RotationAndAccuracy::clear_euler_quaternion() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (euler_quaternion_case()) {
    case kEulerVehicle: {
      if (GetArena() == nullptr) {
        delete _impl_.euler_quaternion_.euler_vehicle_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.euler_quaternion_.euler_vehicle_);
      }
      break;
    }
    case kEulerEventGroup: {
      if (GetArena() == nullptr) {
        delete _impl_.euler_quaternion_.euler_event_group_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.euler_quaternion_.euler_event_group_);
      }
      break;
    }
    case kQuaternionVehicle: {
      if (GetArena() == nullptr) {
        delete _impl_.euler_quaternion_.quaternion_vehicle_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.euler_quaternion_.quaternion_vehicle_);
      }
      break;
    }
    case kQuaternionEventGroup: {
      if (GetArena() == nullptr) {
        delete _impl_.euler_quaternion_.quaternion_event_group_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.euler_quaternion_.quaternion_event_group_);
      }
      break;
    }
    case EULER_QUATERNION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = EULER_QUATERNION_NOT_SET;
}

void RotationAndAccuracy::clear_accuracy() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (accuracy_case()) {
    case kCombinedStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.combined_std_dev_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.combined_std_dev_);
      }
      break;
    }
    case kStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.std_dev_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.std_dev_);
      }
      break;
    }
    case kCovariance: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.covariance_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.covariance_);
      }
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = ACCURACY_NOT_SET;
}


inline void* PROTOBUF_NONNULL RotationAndAccuracy::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RotationAndAccuracy(arena);
}
constexpr auto RotationAndAccuracy::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.extension_) +
          decltype(RotationAndAccuracy::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(RotationAndAccuracy), alignof(RotationAndAccuracy), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&RotationAndAccuracy::PlacementNew_,
                                 sizeof(RotationAndAccuracy),
                                 alignof(RotationAndAccuracy));
  }
}
constexpr auto RotationAndAccuracy::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RotationAndAccuracy_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RotationAndAccuracy::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RotationAndAccuracy>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RotationAndAccuracy::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RotationAndAccuracy>(), &RotationAndAccuracy::ByteSizeLong,
              &RotationAndAccuracy::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_._cached_size_),
          false,
      },
      &RotationAndAccuracy::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RotationAndAccuracy_class_data_ =
        RotationAndAccuracy::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RotationAndAccuracy::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RotationAndAccuracy_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RotationAndAccuracy_class_data_.tc_table);
  return RotationAndAccuracy_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 8, 8, 0, 2>
RotationAndAccuracy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    15, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    8,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RotationAndAccuracy_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 7, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_vehicle = 1;
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.euler_quaternion_.euler_vehicle_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_event_group = 2;
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.euler_quaternion_.euler_event_group_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_vehicle = 3;
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.euler_quaternion_.quaternion_vehicle_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_event_group = 4;
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.euler_quaternion_.quaternion_event_group_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.accuracy_.combined_std_dev_), _Internal::kOneofCaseOffset + 4, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev std_dev = 6;
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.accuracy_.std_dev_), _Internal::kOneofCaseOffset + 4, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 7 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.accuracy_.covariance_), _Internal::kOneofCaseOffset + 4, 6,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.extension_), 0, 7,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Matrix3x3>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RotationAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  clear_euler_quaternion();
  clear_accuracy();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RotationAndAccuracy::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RotationAndAccuracy& this_ = static_cast<const RotationAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RotationAndAccuracy::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RotationAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (this_.euler_quaternion_case()) {
    case kEulerVehicle: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          1, *this_._impl_.euler_quaternion_.euler_vehicle_, this_._impl_.euler_quaternion_.euler_vehicle_->GetCachedSize(), target,
          stream);
      break;
    }
    case kEulerEventGroup: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          2, *this_._impl_.euler_quaternion_.euler_event_group_, this_._impl_.euler_quaternion_.euler_event_group_->GetCachedSize(), target,
          stream);
      break;
    }
    case kQuaternionVehicle: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, *this_._impl_.euler_quaternion_.quaternion_vehicle_, this_._impl_.euler_quaternion_.quaternion_vehicle_->GetCachedSize(), target,
          stream);
      break;
    }
    case kQuaternionEventGroup: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *this_._impl_.euler_quaternion_.quaternion_event_group_, this_._impl_.euler_quaternion_.quaternion_event_group_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  switch (this_.accuracy_case()) {
    case kCombinedStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *this_._impl_.accuracy_.combined_std_dev_, this_._impl_.accuracy_.combined_std_dev_->GetCachedSize(), target,
          stream);
      break;
    }
    case kStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *this_._impl_.accuracy_.std_dev_, this_._impl_.accuracy_.std_dev_->GetCachedSize(), target,
          stream);
      break;
    }
    case kCovariance: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          7, *this_._impl_.accuracy_.covariance_, this_._impl_.accuracy_.covariance_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RotationAndAccuracy::ByteSizeLong(const MessageLite& base) {
  const RotationAndAccuracy& this_ = static_cast<const RotationAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RotationAndAccuracy::ByteSizeLong() const {
  const RotationAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  switch (this_.euler_quaternion_case()) {
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_vehicle = 1;
    case kEulerVehicle: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.euler_quaternion_.euler_vehicle_);
      break;
    }
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_event_group = 2;
    case kEulerEventGroup: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.euler_quaternion_.euler_event_group_);
      break;
    }
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_vehicle = 3;
    case kQuaternionVehicle: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.euler_quaternion_.quaternion_vehicle_);
      break;
    }
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_event_group = 4;
    case kQuaternionEventGroup: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.euler_quaternion_.quaternion_event_group_);
      break;
    }
    case EULER_QUATERNION_NOT_SET: {
      break;
    }
  }
  switch (this_.accuracy_case()) {
    // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 2];
    case kCombinedStdDev: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.combined_std_dev_);
      break;
    }
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev std_dev = 6;
    case kStdDev: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.std_dev_);
      break;
    }
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 7 [(.sensoris.protobuf.types.base.exponent) = 2];
    case kCovariance: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.covariance_);
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RotationAndAccuracy::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RotationAndAccuracy*>(&to_msg);
  auto& from = static_cast<const RotationAndAccuracy&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_euler_quaternion();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kEulerVehicle: {
        if (oneof_needs_init) {
          _this->_impl_.euler_quaternion_.euler_vehicle_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.euler_quaternion_.euler_vehicle_);
        } else {
          _this->_impl_.euler_quaternion_.euler_vehicle_->MergeFrom(*from._impl_.euler_quaternion_.euler_vehicle_);
        }
        break;
      }
      case kEulerEventGroup: {
        if (oneof_needs_init) {
          _this->_impl_.euler_quaternion_.euler_event_group_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.euler_quaternion_.euler_event_group_);
        } else {
          _this->_impl_.euler_quaternion_.euler_event_group_->MergeFrom(*from._impl_.euler_quaternion_.euler_event_group_);
        }
        break;
      }
      case kQuaternionVehicle: {
        if (oneof_needs_init) {
          _this->_impl_.euler_quaternion_.quaternion_vehicle_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.euler_quaternion_.quaternion_vehicle_);
        } else {
          _this->_impl_.euler_quaternion_.quaternion_vehicle_->MergeFrom(*from._impl_.euler_quaternion_.quaternion_vehicle_);
        }
        break;
      }
      case kQuaternionEventGroup: {
        if (oneof_needs_init) {
          _this->_impl_.euler_quaternion_.quaternion_event_group_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.euler_quaternion_.quaternion_event_group_);
        } else {
          _this->_impl_.euler_quaternion_.quaternion_event_group_->MergeFrom(*from._impl_.euler_quaternion_.quaternion_event_group_);
        }
        break;
      }
      case EULER_QUATERNION_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_accuracy();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kCombinedStdDev: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.combined_std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.combined_std_dev_);
        } else {
          _this->_impl_.accuracy_.combined_std_dev_->MergeFrom(*from._impl_.accuracy_.combined_std_dev_);
        }
        break;
      }
      case kStdDev: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.std_dev_);
        } else {
          _this->_impl_.accuracy_.std_dev_->MergeFrom(*from._impl_.accuracy_.std_dev_);
        }
        break;
      }
      case kCovariance: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.covariance_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.covariance_);
        } else {
          _this->_impl_.accuracy_.covariance_->MergeFrom(*from._impl_.accuracy_.covariance_);
        }
        break;
      }
      case ACCURACY_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RotationAndAccuracy::CopyFrom(const RotationAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RotationAndAccuracy::InternalSwap(RotationAndAccuracy* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  swap(_impl_.euler_quaternion_, other->_impl_.euler_quaternion_);
  swap(_impl_.accuracy_, other->_impl_.accuracy_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata RotationAndAccuracy::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RotationRateAndAccuracy_StdDev::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RotationRateAndAccuracy_StdDev>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_._has_bits_);
};

void RotationRateAndAccuracy_StdDev::clear_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.yaw_ != nullptr) _impl_.yaw_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RotationRateAndAccuracy_StdDev::clear_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pitch_ != nullptr) _impl_.pitch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RotationRateAndAccuracy_StdDev::clear_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.roll_ != nullptr) _impl_.roll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RotationRateAndAccuracy_StdDev::RotationRateAndAccuracy_StdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RotationRateAndAccuracy_StdDev_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
}
PROTOBUF_NDEBUG_INLINE RotationRateAndAccuracy_StdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RotationRateAndAccuracy_StdDev::RotationRateAndAccuracy_StdDev(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RotationRateAndAccuracy_StdDev& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RotationRateAndAccuracy_StdDev_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RotationRateAndAccuracy_StdDev* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.yaw_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.yaw_)
                : nullptr;
  _impl_.pitch_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.pitch_)
                : nullptr;
  _impl_.roll_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.roll_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
}
PROTOBUF_NDEBUG_INLINE RotationRateAndAccuracy_StdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void RotationRateAndAccuracy_StdDev::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, yaw_),
           0,
           offsetof(Impl_, roll_) -
               offsetof(Impl_, yaw_) +
               sizeof(Impl_::roll_));
}
RotationRateAndAccuracy_StdDev::~RotationRateAndAccuracy_StdDev() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  SharedDtor(*this);
}
inline void RotationRateAndAccuracy_StdDev::SharedDtor(MessageLite& self) {
  RotationRateAndAccuracy_StdDev& this_ = static_cast<RotationRateAndAccuracy_StdDev&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.yaw_;
  delete this_._impl_.pitch_;
  delete this_._impl_.roll_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RotationRateAndAccuracy_StdDev::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RotationRateAndAccuracy_StdDev(arena);
}
constexpr auto RotationRateAndAccuracy_StdDev::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(RotationRateAndAccuracy_StdDev),
                                            alignof(RotationRateAndAccuracy_StdDev));
}
constexpr auto RotationRateAndAccuracy_StdDev::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RotationRateAndAccuracy_StdDev_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RotationRateAndAccuracy_StdDev::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RotationRateAndAccuracy_StdDev>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RotationRateAndAccuracy_StdDev::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RotationRateAndAccuracy_StdDev>(), &RotationRateAndAccuracy_StdDev::ByteSizeLong,
              &RotationRateAndAccuracy_StdDev::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_._cached_size_),
          false,
      },
      &RotationRateAndAccuracy_StdDev::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RotationRateAndAccuracy_StdDev_class_data_ =
        RotationRateAndAccuracy_StdDev::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RotationRateAndAccuracy_StdDev::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RotationRateAndAccuracy_StdDev_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RotationRateAndAccuracy_StdDev_class_data_.tc_table);
  return RotationRateAndAccuracy_StdDev_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
RotationRateAndAccuracy_StdDev::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RotationRateAndAccuracy_StdDev_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.yaw_)}},
    // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.pitch_)}},
    // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.roll_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.yaw_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.pitch_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.roll_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RotationRateAndAccuracy_StdDev::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.yaw_ != nullptr);
      _impl_.yaw_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.pitch_ != nullptr);
      _impl_.pitch_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.roll_ != nullptr);
      _impl_.roll_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RotationRateAndAccuracy_StdDev::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RotationRateAndAccuracy_StdDev& this_ = static_cast<const RotationRateAndAccuracy_StdDev&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RotationRateAndAccuracy_StdDev::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RotationRateAndAccuracy_StdDev& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.yaw_, this_._impl_.yaw_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.pitch_, this_._impl_.pitch_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.roll_, this_._impl_.roll_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RotationRateAndAccuracy_StdDev::ByteSizeLong(const MessageLite& base) {
  const RotationRateAndAccuracy_StdDev& this_ = static_cast<const RotationRateAndAccuracy_StdDev&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RotationRateAndAccuracy_StdDev::ByteSizeLong() const {
  const RotationRateAndAccuracy_StdDev& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.yaw_);
    }
    // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.pitch_);
    }
    // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.roll_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RotationRateAndAccuracy_StdDev::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RotationRateAndAccuracy_StdDev*>(&to_msg);
  auto& from = static_cast<const RotationRateAndAccuracy_StdDev&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.yaw_ != nullptr);
      if (_this->_impl_.yaw_ == nullptr) {
        _this->_impl_.yaw_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.yaw_);
      } else {
        _this->_impl_.yaw_->MergeFrom(*from._impl_.yaw_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.pitch_ != nullptr);
      if (_this->_impl_.pitch_ == nullptr) {
        _this->_impl_.pitch_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.pitch_);
      } else {
        _this->_impl_.pitch_->MergeFrom(*from._impl_.pitch_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.roll_ != nullptr);
      if (_this->_impl_.roll_ == nullptr) {
        _this->_impl_.roll_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.roll_);
      } else {
        _this->_impl_.roll_->MergeFrom(*from._impl_.roll_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RotationRateAndAccuracy_StdDev::CopyFrom(const RotationRateAndAccuracy_StdDev& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RotationRateAndAccuracy_StdDev::InternalSwap(RotationRateAndAccuracy_StdDev* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.roll_)
      + sizeof(RotationRateAndAccuracy_StdDev::_impl_.roll_)
      - PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.yaw_)>(
          reinterpret_cast<char*>(&_impl_.yaw_),
          reinterpret_cast<char*>(&other->_impl_.yaw_));
}

::google::protobuf::Metadata RotationRateAndAccuracy_StdDev::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RotationRateAndAccuracy::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RotationRateAndAccuracy>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_._oneof_case_);
};

void RotationRateAndAccuracy::clear_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.yaw_ != nullptr) _impl_.yaw_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RotationRateAndAccuracy::clear_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pitch_ != nullptr) _impl_.pitch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RotationRateAndAccuracy::clear_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.roll_ != nullptr) _impl_.roll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void RotationRateAndAccuracy::set_allocated_combined_std_dev(::google::protobuf::Int64Value* PROTOBUF_NULLABLE combined_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (combined_std_dev) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(combined_std_dev)->GetArena();
    if (message_arena != submessage_arena) {
      combined_std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, combined_std_dev, submessage_arena);
    }
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = combined_std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
}
void RotationRateAndAccuracy::clear_combined_std_dev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kCombinedStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.combined_std_dev_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.combined_std_dev_);
    }
    clear_has_accuracy();
  }
}
void RotationRateAndAccuracy::set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* PROTOBUF_NULLABLE std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (std_dev) {
    ::google::protobuf::Arena* submessage_arena = std_dev->GetArena();
    if (message_arena != submessage_arena) {
      std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, std_dev, submessage_arena);
    }
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
}
void RotationRateAndAccuracy::set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE covariance) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (covariance) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(covariance)->GetArena();
    if (message_arena != submessage_arena) {
      covariance = ::google::protobuf::internal::GetOwnedMessage(message_arena, covariance, submessage_arena);
    }
    set_has_covariance();
    _impl_.accuracy_.covariance_ = covariance;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
}
void RotationRateAndAccuracy::clear_covariance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kCovariance) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.covariance_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.covariance_);
    }
    clear_has_accuracy();
  }
}
void RotationRateAndAccuracy::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
RotationRateAndAccuracy::RotationRateAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RotationRateAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE RotationRateAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_},
        accuracy_{},
        _oneof_case_{from._oneof_case_[0]} {}

RotationRateAndAccuracy::RotationRateAndAccuracy(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RotationRateAndAccuracy& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RotationRateAndAccuracy_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RotationRateAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.yaw_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.yaw_)
                : nullptr;
  _impl_.pitch_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.pitch_)
                : nullptr;
  _impl_.roll_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.roll_)
                : nullptr;
  switch (accuracy_case()) {
    case ACCURACY_NOT_SET:
      break;
      case kCombinedStdDev:
        _impl_.accuracy_.combined_std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.combined_std_dev_);
        break;
      case kStdDev:
        _impl_.accuracy_.std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.std_dev_);
        break;
      case kCovariance:
        _impl_.accuracy_.covariance_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.covariance_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
}
PROTOBUF_NDEBUG_INLINE RotationRateAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        extension_{visibility, arena},
        accuracy_{},
        _oneof_case_{} {}

inline void RotationRateAndAccuracy::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, yaw_),
           0,
           offsetof(Impl_, roll_) -
               offsetof(Impl_, yaw_) +
               sizeof(Impl_::roll_));
}
RotationRateAndAccuracy::~RotationRateAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  SharedDtor(*this);
}
inline void RotationRateAndAccuracy::SharedDtor(MessageLite& self) {
  RotationRateAndAccuracy& this_ = static_cast<RotationRateAndAccuracy&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.yaw_;
  delete this_._impl_.pitch_;
  delete this_._impl_.roll_;
  if (this_.has_accuracy()) {
    this_.clear_accuracy();
  }
  this_._impl_.~Impl_();
}

void RotationRateAndAccuracy::clear_accuracy() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (accuracy_case()) {
    case kCombinedStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.combined_std_dev_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.combined_std_dev_);
      }
      break;
    }
    case kStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.std_dev_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.std_dev_);
      }
      break;
    }
    case kCovariance: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.covariance_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.covariance_);
      }
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ACCURACY_NOT_SET;
}


inline void* PROTOBUF_NONNULL RotationRateAndAccuracy::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RotationRateAndAccuracy(arena);
}
constexpr auto RotationRateAndAccuracy::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.extension_) +
          decltype(RotationRateAndAccuracy::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(RotationRateAndAccuracy), alignof(RotationRateAndAccuracy), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&RotationRateAndAccuracy::PlacementNew_,
                                 sizeof(RotationRateAndAccuracy),
                                 alignof(RotationRateAndAccuracy));
  }
}
constexpr auto RotationRateAndAccuracy::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RotationRateAndAccuracy_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RotationRateAndAccuracy::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RotationRateAndAccuracy>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RotationRateAndAccuracy::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RotationRateAndAccuracy>(), &RotationRateAndAccuracy::ByteSizeLong,
              &RotationRateAndAccuracy::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_._cached_size_),
          false,
      },
      &RotationRateAndAccuracy::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RotationRateAndAccuracy_class_data_ =
        RotationRateAndAccuracy::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RotationRateAndAccuracy::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RotationRateAndAccuracy_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RotationRateAndAccuracy_class_data_.tc_table);
  return RotationRateAndAccuracy_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 7, 0, 2>
RotationRateAndAccuracy::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_._has_bits_),
    0, // no _extensions_
    15, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950848,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RotationRateAndAccuracy_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.yaw_)}},
    // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.pitch_)}},
    // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.roll_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 6, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.yaw_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.pitch_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.roll_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value combined_std_dev = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.accuracy_.combined_std_dev_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev std_dev = 5;
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.accuracy_.std_dev_), _Internal::kOneofCaseOffset + 0, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.accuracy_.covariance_), _Internal::kOneofCaseOffset + 0, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.extension_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Matrix3x3>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RotationRateAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.yaw_ != nullptr);
      _impl_.yaw_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.pitch_ != nullptr);
      _impl_.pitch_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.roll_ != nullptr);
      _impl_.roll_->Clear();
    }
  }
  clear_accuracy();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RotationRateAndAccuracy::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RotationRateAndAccuracy& this_ = static_cast<const RotationRateAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RotationRateAndAccuracy::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RotationRateAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.yaw_, this_._impl_.yaw_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.pitch_, this_._impl_.pitch_->GetCachedSize(), target,
        stream);
  }

  // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.roll_, this_._impl_.roll_->GetCachedSize(), target,
        stream);
  }

  switch (this_.accuracy_case()) {
    case kCombinedStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *this_._impl_.accuracy_.combined_std_dev_, this_._impl_.accuracy_.combined_std_dev_->GetCachedSize(), target,
          stream);
      break;
    }
    case kStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *this_._impl_.accuracy_.std_dev_, this_._impl_.accuracy_.std_dev_->GetCachedSize(), target,
          stream);
      break;
    }
    case kCovariance: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *this_._impl_.accuracy_.covariance_, this_._impl_.accuracy_.covariance_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RotationRateAndAccuracy::ByteSizeLong(const MessageLite& base) {
  const RotationRateAndAccuracy& this_ = static_cast<const RotationRateAndAccuracy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RotationRateAndAccuracy::ByteSizeLong() const {
  const RotationRateAndAccuracy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.yaw_);
    }
    // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.pitch_);
    }
    // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.roll_);
    }
  }
  switch (this_.accuracy_case()) {
    // .google.protobuf.Int64Value combined_std_dev = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
    case kCombinedStdDev: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.combined_std_dev_);
      break;
    }
    // .sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev std_dev = 5;
    case kStdDev: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.std_dev_);
      break;
    }
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6 [(.sensoris.protobuf.types.base.exponent) = 2];
    case kCovariance: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.accuracy_.covariance_);
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RotationRateAndAccuracy::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RotationRateAndAccuracy*>(&to_msg);
  auto& from = static_cast<const RotationRateAndAccuracy&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.yaw_ != nullptr);
      if (_this->_impl_.yaw_ == nullptr) {
        _this->_impl_.yaw_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.yaw_);
      } else {
        _this->_impl_.yaw_->MergeFrom(*from._impl_.yaw_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.pitch_ != nullptr);
      if (_this->_impl_.pitch_ == nullptr) {
        _this->_impl_.pitch_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.pitch_);
      } else {
        _this->_impl_.pitch_->MergeFrom(*from._impl_.pitch_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.roll_ != nullptr);
      if (_this->_impl_.roll_ == nullptr) {
        _this->_impl_.roll_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.roll_);
      } else {
        _this->_impl_.roll_->MergeFrom(*from._impl_.roll_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_accuracy();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kCombinedStdDev: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.combined_std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.combined_std_dev_);
        } else {
          _this->_impl_.accuracy_.combined_std_dev_->MergeFrom(*from._impl_.accuracy_.combined_std_dev_);
        }
        break;
      }
      case kStdDev: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.std_dev_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.std_dev_);
        } else {
          _this->_impl_.accuracy_.std_dev_->MergeFrom(*from._impl_.accuracy_.std_dev_);
        }
        break;
      }
      case kCovariance: {
        if (oneof_needs_init) {
          _this->_impl_.accuracy_.covariance_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.accuracy_.covariance_);
        } else {
          _this->_impl_.accuracy_.covariance_->MergeFrom(*from._impl_.accuracy_.covariance_);
        }
        break;
      }
      case ACCURACY_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RotationRateAndAccuracy::CopyFrom(const RotationRateAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RotationRateAndAccuracy::InternalSwap(RotationRateAndAccuracy* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.roll_)
      + sizeof(RotationRateAndAccuracy::_impl_.roll_)
      - PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.yaw_)>(
          reinterpret_cast<char*>(&_impl_.yaw_),
          reinterpret_cast<char*>(&other->_impl_.yaw_));
  swap(_impl_.accuracy_, other->_impl_.accuracy_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata RotationRateAndAccuracy::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MapLocationReference_TileIdLinkIdOffset::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MapLocationReference_TileIdLinkIdOffset>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_._has_bits_);
};

void MapLocationReference_TileIdLinkIdOffset::clear_tile_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tile_id_ != nullptr) _impl_.tile_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MapLocationReference_TileIdLinkIdOffset::clear_link_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.link_id_ != nullptr) _impl_.link_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MapLocationReference_TileIdLinkIdOffset::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.offset_ != nullptr) _impl_.offset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void MapLocationReference_TileIdLinkIdOffset::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
MapLocationReference_TileIdLinkIdOffset::MapLocationReference_TileIdLinkIdOffset(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MapLocationReference_TileIdLinkIdOffset_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
}
PROTOBUF_NDEBUG_INLINE MapLocationReference_TileIdLinkIdOffset::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_} {}

MapLocationReference_TileIdLinkIdOffset::MapLocationReference_TileIdLinkIdOffset(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MapLocationReference_TileIdLinkIdOffset& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MapLocationReference_TileIdLinkIdOffset_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MapLocationReference_TileIdLinkIdOffset* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.tile_id_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.tile_id_)
                : nullptr;
  _impl_.link_id_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.link_id_)
                : nullptr;
  _impl_.offset_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.offset_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
}
PROTOBUF_NDEBUG_INLINE MapLocationReference_TileIdLinkIdOffset::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        extension_{visibility, arena} {}

inline void MapLocationReference_TileIdLinkIdOffset::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, tile_id_),
           0,
           offsetof(Impl_, offset_) -
               offsetof(Impl_, tile_id_) +
               sizeof(Impl_::offset_));
}
MapLocationReference_TileIdLinkIdOffset::~MapLocationReference_TileIdLinkIdOffset() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  SharedDtor(*this);
}
inline void MapLocationReference_TileIdLinkIdOffset::SharedDtor(MessageLite& self) {
  MapLocationReference_TileIdLinkIdOffset& this_ = static_cast<MapLocationReference_TileIdLinkIdOffset&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.tile_id_;
  delete this_._impl_.link_id_;
  delete this_._impl_.offset_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MapLocationReference_TileIdLinkIdOffset::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MapLocationReference_TileIdLinkIdOffset(arena);
}
constexpr auto MapLocationReference_TileIdLinkIdOffset::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.extension_) +
          decltype(MapLocationReference_TileIdLinkIdOffset::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(MapLocationReference_TileIdLinkIdOffset), alignof(MapLocationReference_TileIdLinkIdOffset), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&MapLocationReference_TileIdLinkIdOffset::PlacementNew_,
                                 sizeof(MapLocationReference_TileIdLinkIdOffset),
                                 alignof(MapLocationReference_TileIdLinkIdOffset));
  }
}
constexpr auto MapLocationReference_TileIdLinkIdOffset::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MapLocationReference_TileIdLinkIdOffset_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MapLocationReference_TileIdLinkIdOffset::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MapLocationReference_TileIdLinkIdOffset>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MapLocationReference_TileIdLinkIdOffset::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MapLocationReference_TileIdLinkIdOffset>(), &MapLocationReference_TileIdLinkIdOffset::ByteSizeLong,
              &MapLocationReference_TileIdLinkIdOffset::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_._cached_size_),
          false,
      },
      &MapLocationReference_TileIdLinkIdOffset::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MapLocationReference_TileIdLinkIdOffset_class_data_ =
        MapLocationReference_TileIdLinkIdOffset::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MapLocationReference_TileIdLinkIdOffset::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MapLocationReference_TileIdLinkIdOffset_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MapLocationReference_TileIdLinkIdOffset_class_data_.tc_table);
  return MapLocationReference_TileIdLinkIdOffset_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 4, 4, 0, 2>
MapLocationReference_TileIdLinkIdOffset::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_._has_bits_),
    0, // no _extensions_
    15, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950904,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MapLocationReference_TileIdLinkIdOffset_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Int64Value tile_id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.tile_id_)}},
    // .google.protobuf.Int64Value link_id = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.link_id_)}},
    // .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.offset_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 3, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value tile_id = 1;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.tile_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value link_id = 2;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.link_id_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.offset_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.extension_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void MapLocationReference_TileIdLinkIdOffset::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.tile_id_ != nullptr);
      _impl_.tile_id_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.link_id_ != nullptr);
      _impl_.link_id_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.offset_ != nullptr);
      _impl_.offset_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MapLocationReference_TileIdLinkIdOffset::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MapLocationReference_TileIdLinkIdOffset& this_ = static_cast<const MapLocationReference_TileIdLinkIdOffset&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MapLocationReference_TileIdLinkIdOffset::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MapLocationReference_TileIdLinkIdOffset& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .google.protobuf.Int64Value tile_id = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.tile_id_, this_._impl_.tile_id_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value link_id = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.link_id_, this_._impl_.link_id_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.offset_, this_._impl_.offset_->GetCachedSize(), target,
        stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MapLocationReference_TileIdLinkIdOffset::ByteSizeLong(const MessageLite& base) {
  const MapLocationReference_TileIdLinkIdOffset& this_ = static_cast<const MapLocationReference_TileIdLinkIdOffset&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MapLocationReference_TileIdLinkIdOffset::ByteSizeLong() const {
  const MapLocationReference_TileIdLinkIdOffset& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // .google.protobuf.Int64Value tile_id = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.tile_id_);
    }
    // .google.protobuf.Int64Value link_id = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.link_id_);
    }
    // .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.offset_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MapLocationReference_TileIdLinkIdOffset::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<MapLocationReference_TileIdLinkIdOffset*>(&to_msg);
  auto& from = static_cast<const MapLocationReference_TileIdLinkIdOffset&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.tile_id_ != nullptr);
      if (_this->_impl_.tile_id_ == nullptr) {
        _this->_impl_.tile_id_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.tile_id_);
      } else {
        _this->_impl_.tile_id_->MergeFrom(*from._impl_.tile_id_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.link_id_ != nullptr);
      if (_this->_impl_.link_id_ == nullptr) {
        _this->_impl_.link_id_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.link_id_);
      } else {
        _this->_impl_.link_id_->MergeFrom(*from._impl_.link_id_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.offset_ != nullptr);
      if (_this->_impl_.offset_ == nullptr) {
        _this->_impl_.offset_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.offset_);
      } else {
        _this->_impl_.offset_->MergeFrom(*from._impl_.offset_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MapLocationReference_TileIdLinkIdOffset::CopyFrom(const MapLocationReference_TileIdLinkIdOffset& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MapLocationReference_TileIdLinkIdOffset::InternalSwap(MapLocationReference_TileIdLinkIdOffset* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.offset_)
      + sizeof(MapLocationReference_TileIdLinkIdOffset::_impl_.offset_)
      - PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.tile_id_)>(
          reinterpret_cast<char*>(&_impl_.tile_id_),
          reinterpret_cast<char*>(&other->_impl_.tile_id_));
}

::google::protobuf::Metadata MapLocationReference_TileIdLinkIdOffset::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MapLocationReference_TileIdObjectId::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MapLocationReference_TileIdObjectId>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_._has_bits_);
};

void MapLocationReference_TileIdObjectId::clear_tile_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tile_id_ != nullptr) _impl_.tile_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MapLocationReference_TileIdObjectId::clear_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_id_ != nullptr) _impl_.object_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MapLocationReference_TileIdObjectId::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
MapLocationReference_TileIdObjectId::MapLocationReference_TileIdObjectId(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MapLocationReference_TileIdObjectId_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
}
PROTOBUF_NDEBUG_INLINE MapLocationReference_TileIdObjectId::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_} {}

MapLocationReference_TileIdObjectId::MapLocationReference_TileIdObjectId(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MapLocationReference_TileIdObjectId& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MapLocationReference_TileIdObjectId_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MapLocationReference_TileIdObjectId* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.tile_id_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.tile_id_)
                : nullptr;
  _impl_.object_id_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.object_id_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
}
PROTOBUF_NDEBUG_INLINE MapLocationReference_TileIdObjectId::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        extension_{visibility, arena} {}

inline void MapLocationReference_TileIdObjectId::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, tile_id_),
           0,
           offsetof(Impl_, object_id_) -
               offsetof(Impl_, tile_id_) +
               sizeof(Impl_::object_id_));
}
MapLocationReference_TileIdObjectId::~MapLocationReference_TileIdObjectId() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  SharedDtor(*this);
}
inline void MapLocationReference_TileIdObjectId::SharedDtor(MessageLite& self) {
  MapLocationReference_TileIdObjectId& this_ = static_cast<MapLocationReference_TileIdObjectId&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.tile_id_;
  delete this_._impl_.object_id_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MapLocationReference_TileIdObjectId::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MapLocationReference_TileIdObjectId(arena);
}
constexpr auto MapLocationReference_TileIdObjectId::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.extension_) +
          decltype(MapLocationReference_TileIdObjectId::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(MapLocationReference_TileIdObjectId), alignof(MapLocationReference_TileIdObjectId), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&MapLocationReference_TileIdObjectId::PlacementNew_,
                                 sizeof(MapLocationReference_TileIdObjectId),
                                 alignof(MapLocationReference_TileIdObjectId));
  }
}
constexpr auto MapLocationReference_TileIdObjectId::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MapLocationReference_TileIdObjectId_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MapLocationReference_TileIdObjectId::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MapLocationReference_TileIdObjectId>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MapLocationReference_TileIdObjectId::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MapLocationReference_TileIdObjectId>(), &MapLocationReference_TileIdObjectId::ByteSizeLong,
              &MapLocationReference_TileIdObjectId::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_._cached_size_),
          false,
      },
      &MapLocationReference_TileIdObjectId::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MapLocationReference_TileIdObjectId_class_data_ =
        MapLocationReference_TileIdObjectId::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MapLocationReference_TileIdObjectId::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MapLocationReference_TileIdObjectId_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MapLocationReference_TileIdObjectId_class_data_.tc_table);
  return MapLocationReference_TileIdObjectId_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
MapLocationReference_TileIdObjectId::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_._has_bits_),
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950908,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MapLocationReference_TileIdObjectId_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Int64Value tile_id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.tile_id_)}},
    // .google.protobuf.Int64Value object_id = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.object_id_)}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 2, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value tile_id = 1;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.tile_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value object_id = 2;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.object_id_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.extension_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void MapLocationReference_TileIdObjectId::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.tile_id_ != nullptr);
      _impl_.tile_id_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.object_id_ != nullptr);
      _impl_.object_id_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MapLocationReference_TileIdObjectId::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MapLocationReference_TileIdObjectId& this_ = static_cast<const MapLocationReference_TileIdObjectId&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MapLocationReference_TileIdObjectId::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MapLocationReference_TileIdObjectId& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .google.protobuf.Int64Value tile_id = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.tile_id_, this_._impl_.tile_id_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value object_id = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.object_id_, this_._impl_.object_id_->GetCachedSize(), target,
        stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MapLocationReference_TileIdObjectId::ByteSizeLong(const MessageLite& base) {
  const MapLocationReference_TileIdObjectId& this_ = static_cast<const MapLocationReference_TileIdObjectId&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MapLocationReference_TileIdObjectId::ByteSizeLong() const {
  const MapLocationReference_TileIdObjectId& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // .google.protobuf.Int64Value tile_id = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.tile_id_);
    }
    // .google.protobuf.Int64Value object_id = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.object_id_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MapLocationReference_TileIdObjectId::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<MapLocationReference_TileIdObjectId*>(&to_msg);
  auto& from = static_cast<const MapLocationReference_TileIdObjectId&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.tile_id_ != nullptr);
      if (_this->_impl_.tile_id_ == nullptr) {
        _this->_impl_.tile_id_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.tile_id_);
      } else {
        _this->_impl_.tile_id_->MergeFrom(*from._impl_.tile_id_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.object_id_ != nullptr);
      if (_this->_impl_.object_id_ == nullptr) {
        _this->_impl_.object_id_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.object_id_);
      } else {
        _this->_impl_.object_id_->MergeFrom(*from._impl_.object_id_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MapLocationReference_TileIdObjectId::CopyFrom(const MapLocationReference_TileIdObjectId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MapLocationReference_TileIdObjectId::InternalSwap(MapLocationReference_TileIdObjectId* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.object_id_)
      + sizeof(MapLocationReference_TileIdObjectId::_impl_.object_id_)
      - PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.tile_id_)>(
          reinterpret_cast<char*>(&_impl_.tile_id_),
          reinterpret_cast<char*>(&other->_impl_.tile_id_));
}

::google::protobuf::Metadata MapLocationReference_TileIdObjectId::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MapLocationReference::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MapLocationReference>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_._oneof_case_);
};

void MapLocationReference::clear_z_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_level_ != nullptr) _impl_.z_level_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MapLocationReference::set_allocated_tile_link_offset_reference(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NULLABLE tile_link_offset_reference) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_map_based_reference();
  if (tile_link_offset_reference) {
    ::google::protobuf::Arena* submessage_arena = tile_link_offset_reference->GetArena();
    if (message_arena != submessage_arena) {
      tile_link_offset_reference = ::google::protobuf::internal::GetOwnedMessage(message_arena, tile_link_offset_reference, submessage_arena);
    }
    set_has_tile_link_offset_reference();
    _impl_.map_based_reference_.tile_link_offset_reference_ = tile_link_offset_reference;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
}
void MapLocationReference::set_allocated_map_object_id(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NULLABLE map_object_id) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_map_based_reference();
  if (map_object_id) {
    ::google::protobuf::Arena* submessage_arena = map_object_id->GetArena();
    if (message_arena != submessage_arena) {
      map_object_id = ::google::protobuf::internal::GetOwnedMessage(message_arena, map_object_id, submessage_arena);
    }
    set_has_map_object_id();
    _impl_.map_based_reference_.map_object_id_ = map_object_id;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
}
void MapLocationReference::clear_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extension_.Clear();
}
MapLocationReference::MapLocationReference(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MapLocationReference_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.MapLocationReference)
}
PROTOBUF_NDEBUG_INLINE MapLocationReference::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::sensoris::protobuf::types::spatial::MapLocationReference& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_},
        map_based_reference_{},
        _oneof_case_{from._oneof_case_[0]} {}

MapLocationReference::MapLocationReference(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MapLocationReference& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MapLocationReference_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MapLocationReference* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.position_and_accuracy_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.position_and_accuracy_)
                : nullptr;
  _impl_.z_level_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.z_level_)
                : nullptr;
  switch (map_based_reference_case()) {
    case MAP_BASED_REFERENCE_NOT_SET:
      break;
      case kTileLinkOffsetReference:
        _impl_.map_based_reference_.tile_link_offset_reference_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.map_based_reference_.tile_link_offset_reference_);
        break;
      case kMapObjectId:
        _impl_.map_based_reference_.map_object_id_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.map_based_reference_.map_object_id_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.MapLocationReference)
}
PROTOBUF_NDEBUG_INLINE MapLocationReference::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        extension_{visibility, arena},
        map_based_reference_{},
        _oneof_case_{} {}

inline void MapLocationReference::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, position_and_accuracy_),
           0,
           offsetof(Impl_, z_level_) -
               offsetof(Impl_, position_and_accuracy_) +
               sizeof(Impl_::z_level_));
}
MapLocationReference::~MapLocationReference() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.MapLocationReference)
  SharedDtor(*this);
}
inline void MapLocationReference::SharedDtor(MessageLite& self) {
  MapLocationReference& this_ = static_cast<MapLocationReference&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.position_and_accuracy_;
  delete this_._impl_.z_level_;
  if (this_.has_map_based_reference()) {
    this_.clear_map_based_reference();
  }
  this_._impl_.~Impl_();
}

void MapLocationReference::clear_map_based_reference() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.MapLocationReference)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (map_based_reference_case()) {
    case kTileLinkOffsetReference: {
      if (GetArena() == nullptr) {
        delete _impl_.map_based_reference_.tile_link_offset_reference_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.map_based_reference_.tile_link_offset_reference_);
      }
      break;
    }
    case kMapObjectId: {
      if (GetArena() == nullptr) {
        delete _impl_.map_based_reference_.map_object_id_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.map_based_reference_.map_object_id_);
      }
      break;
    }
    case MAP_BASED_REFERENCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MAP_BASED_REFERENCE_NOT_SET;
}


inline void* PROTOBUF_NONNULL MapLocationReference::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MapLocationReference(arena);
}
constexpr auto MapLocationReference::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.extension_) +
          decltype(MapLocationReference::_impl_.extension_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(MapLocationReference), alignof(MapLocationReference), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&MapLocationReference::PlacementNew_,
                                 sizeof(MapLocationReference),
                                 alignof(MapLocationReference));
  }
}
constexpr auto MapLocationReference::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MapLocationReference_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MapLocationReference::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MapLocationReference>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MapLocationReference::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MapLocationReference>(), &MapLocationReference::ByteSizeLong,
              &MapLocationReference::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_._cached_size_),
          false,
      },
      &MapLocationReference::kDescriptorMethods,
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MapLocationReference_class_data_ =
        MapLocationReference::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MapLocationReference::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MapLocationReference_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MapLocationReference_class_data_.tc_table);
  return MapLocationReference_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 5, 5, 0, 2>
MapLocationReference::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_._has_bits_),
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950896,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MapLocationReference_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::MapLocationReference>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.position_and_accuracy_)}},
    // .google.protobuf.Int64Value z_level = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.z_level_)}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 4, PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.position_and_accuracy_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value z_level = 2;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.z_level_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset tile_link_offset_reference = 3;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.map_based_reference_.tile_link_offset_reference_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId map_object_id = 4;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.map_based_reference_.map_object_id_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.extension_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset>()},
      {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId>()},
      {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void MapLocationReference::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.MapLocationReference)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.position_and_accuracy_ != nullptr);
      _impl_.position_and_accuracy_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.z_level_ != nullptr);
      _impl_.z_level_->Clear();
    }
  }
  clear_map_based_reference();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MapLocationReference::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MapLocationReference& this_ = static_cast<const MapLocationReference&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MapLocationReference::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MapLocationReference& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.MapLocationReference)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.position_and_accuracy_, this_._impl_.position_and_accuracy_->GetCachedSize(), target,
        stream);
  }

  // .google.protobuf.Int64Value z_level = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.z_level_, this_._impl_.z_level_->GetCachedSize(), target,
        stream);
  }

  switch (this_.map_based_reference_case()) {
    case kTileLinkOffsetReference: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, *this_._impl_.map_based_reference_.tile_link_offset_reference_, this_._impl_.map_based_reference_.tile_link_offset_reference_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMapObjectId: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *this_._impl_.map_based_reference_.map_object_id_, this_._impl_.map_based_reference_.map_object_id_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_extension_size());
       i < n; i++) {
    const auto& repfield = this_._internal_extension().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            15, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.MapLocationReference)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MapLocationReference::ByteSizeLong(const MessageLite& base) {
  const MapLocationReference& this_ = static_cast<const MapLocationReference&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MapLocationReference::ByteSizeLong() const {
  const MapLocationReference& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.MapLocationReference)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .google.protobuf.Any extension = 15;
    {
      total_size += 1UL * this_._internal_extension_size();
      for (const auto& msg : this_._internal_extension()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.position_and_accuracy_);
    }
    // .google.protobuf.Int64Value z_level = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.z_level_);
    }
  }
  switch (this_.map_based_reference_case()) {
    // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset tile_link_offset_reference = 3;
    case kTileLinkOffsetReference: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.map_based_reference_.tile_link_offset_reference_);
      break;
    }
    // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId map_object_id = 4;
    case kMapObjectId: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.map_based_reference_.map_object_id_);
      break;
    }
    case MAP_BASED_REFERENCE_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MapLocationReference::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<MapLocationReference*>(&to_msg);
  auto& from = static_cast<const MapLocationReference&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.MapLocationReference)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.position_and_accuracy_ != nullptr);
      if (_this->_impl_.position_and_accuracy_ == nullptr) {
        _this->_impl_.position_and_accuracy_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.position_and_accuracy_);
      } else {
        _this->_impl_.position_and_accuracy_->MergeFrom(*from._impl_.position_and_accuracy_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.z_level_ != nullptr);
      if (_this->_impl_.z_level_ == nullptr) {
        _this->_impl_.z_level_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.z_level_);
      } else {
        _this->_impl_.z_level_->MergeFrom(*from._impl_.z_level_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_map_based_reference();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTileLinkOffsetReference: {
        if (oneof_needs_init) {
          _this->_impl_.map_based_reference_.tile_link_offset_reference_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.map_based_reference_.tile_link_offset_reference_);
        } else {
          _this->_impl_.map_based_reference_.tile_link_offset_reference_->MergeFrom(*from._impl_.map_based_reference_.tile_link_offset_reference_);
        }
        break;
      }
      case kMapObjectId: {
        if (oneof_needs_init) {
          _this->_impl_.map_based_reference_.map_object_id_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.map_based_reference_.map_object_id_);
        } else {
          _this->_impl_.map_based_reference_.map_object_id_->MergeFrom(*from._impl_.map_based_reference_.map_object_id_);
        }
        break;
      }
      case MAP_BASED_REFERENCE_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MapLocationReference::CopyFrom(const MapLocationReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.MapLocationReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MapLocationReference::InternalSwap(MapLocationReference* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.z_level_)
      + sizeof(MapLocationReference::_impl_.z_level_)
      - PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.position_and_accuracy_)>(
          reinterpret_cast<char*>(&_impl_.position_and_accuracy_),
          reinterpret_cast<char*>(&other->_impl_.position_and_accuracy_));
  swap(_impl_.map_based_reference_, other->_impl_.map_based_reference_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata MapLocationReference::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace spatial
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ [[maybe_unused]] =
        (::_pbi::AddDescriptors(&descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
