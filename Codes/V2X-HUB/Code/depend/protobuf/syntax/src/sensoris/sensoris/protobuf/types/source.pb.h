// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: sensoris/protobuf/types/source.proto
// Protobuf C++ Version: 6.31.1

#ifndef sensoris_2fprotobuf_2ftypes_2fsource_2eproto_2epb_2eh
#define sensoris_2fprotobuf_2ftypes_2fsource_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/wrappers.pb.h"
#include "sensoris/protobuf/types/base.pb.h"
#include "sensoris/protobuf/types/spatial.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sensoris_2fprotobuf_2ftypes_2fsource_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sensoris_2fprotobuf_2ftypes_2fsource_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_sensoris_2fprotobuf_2ftypes_2fsource_2eproto;
}  // extern "C"
namespace sensoris {
namespace protobuf {
namespace types {
namespace source {
enum NavigationSatelliteSystem_GroundBasedAugmentationSystem : int;
extern const uint32_t NavigationSatelliteSystem_GroundBasedAugmentationSystem_internal_data_[];
enum NavigationSatelliteSystem_SatelliteBasedAugmentationSystem : int;
extern const uint32_t NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_internal_data_[];
enum NavigationSatelliteSystem_SatelliteSystem : int;
extern const uint32_t NavigationSatelliteSystem_SatelliteSystem_internal_data_[];
class NavigationSatelliteSystem;
struct NavigationSatelliteSystemDefaultTypeInternal;
extern NavigationSatelliteSystemDefaultTypeInternal _NavigationSatelliteSystem_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NavigationSatelliteSystem_class_data_;
class Sensor;
struct SensorDefaultTypeInternal;
extern SensorDefaultTypeInternal _Sensor_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Sensor_class_data_;
class SensorFusion;
struct SensorFusionDefaultTypeInternal;
extern SensorFusionDefaultTypeInternal _SensorFusion_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SensorFusion_class_data_;
class Sensor_MountingPositionAndOrientation;
struct Sensor_MountingPositionAndOrientationDefaultTypeInternal;
extern Sensor_MountingPositionAndOrientationDefaultTypeInternal _Sensor_MountingPositionAndOrientation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Sensor_MountingPositionAndOrientation_class_data_;
class Source;
struct SourceDefaultTypeInternal;
extern SourceDefaultTypeInternal _Source_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Source_class_data_;
}  // namespace source
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem>;
}  // namespace protobuf
}  // namespace google

namespace sensoris {
namespace protobuf {
namespace types {
namespace source {
enum NavigationSatelliteSystem_SatelliteSystem : int {
  NavigationSatelliteSystem_SatelliteSystem_UNKNOWN_SATELLITE_SYSTEM = 0,
  NavigationSatelliteSystem_SatelliteSystem_GPS = 1,
  NavigationSatelliteSystem_SatelliteSystem_GLONASS = 2,
  NavigationSatelliteSystem_SatelliteSystem_GALILEO = 3,
  NavigationSatelliteSystem_SatelliteSystem_BEIDOU_1 = 4,
  NavigationSatelliteSystem_SatelliteSystem_BEIDOU_2 = 5,
  NavigationSatelliteSystem_SatelliteSystem_NAVIC = 6,
  NavigationSatelliteSystem_SatelliteSystem_QZSS = 7,
  NavigationSatelliteSystem_SatelliteSystem_NavigationSatelliteSystem_SatelliteSystem_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  NavigationSatelliteSystem_SatelliteSystem_NavigationSatelliteSystem_SatelliteSystem_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t NavigationSatelliteSystem_SatelliteSystem_internal_data_[];
inline constexpr NavigationSatelliteSystem_SatelliteSystem NavigationSatelliteSystem_SatelliteSystem_SatelliteSystem_MIN =
    static_cast<NavigationSatelliteSystem_SatelliteSystem>(0);
inline constexpr NavigationSatelliteSystem_SatelliteSystem NavigationSatelliteSystem_SatelliteSystem_SatelliteSystem_MAX =
    static_cast<NavigationSatelliteSystem_SatelliteSystem>(7);
inline bool NavigationSatelliteSystem_SatelliteSystem_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int NavigationSatelliteSystem_SatelliteSystem_SatelliteSystem_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL NavigationSatelliteSystem_SatelliteSystem_descriptor();
template <typename T>
const ::std::string& NavigationSatelliteSystem_SatelliteSystem_Name(T value) {
  static_assert(::std::is_same<T, NavigationSatelliteSystem_SatelliteSystem>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SatelliteSystem_Name().");
  return NavigationSatelliteSystem_SatelliteSystem_Name(static_cast<NavigationSatelliteSystem_SatelliteSystem>(value));
}
template <>
inline const ::std::string& NavigationSatelliteSystem_SatelliteSystem_Name(NavigationSatelliteSystem_SatelliteSystem value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NavigationSatelliteSystem_SatelliteSystem_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool NavigationSatelliteSystem_SatelliteSystem_Parse(
    ::absl::string_view name, NavigationSatelliteSystem_SatelliteSystem* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<NavigationSatelliteSystem_SatelliteSystem>(NavigationSatelliteSystem_SatelliteSystem_descriptor(), name,
                                           value);
}
enum NavigationSatelliteSystem_SatelliteBasedAugmentationSystem : int {
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_UNKNOWN_SATELLITE_BASED = 0,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SATELLITE_BASED = 1,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_WAAS = 2,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_EGNOS = 3,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_MSAS = 4,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_QZSS_SATELLITE_BASED = 5,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_GAGAN = 6,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SDCM = 7,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SNAS = 8,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_WAGE = 9,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_STAR_FIRE = 10,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_STAR_FIX = 11,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_OMNI_STAR = 12,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_internal_data_[];
inline constexpr NavigationSatelliteSystem_SatelliteBasedAugmentationSystem NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SatelliteBasedAugmentationSystem_MIN =
    static_cast<NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>(0);
inline constexpr NavigationSatelliteSystem_SatelliteBasedAugmentationSystem NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SatelliteBasedAugmentationSystem_MAX =
    static_cast<NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>(12);
inline bool NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_IsValid(int value) {
  return 0 <= value && value <= 12;
}
inline constexpr int NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SatelliteBasedAugmentationSystem_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_descriptor();
template <typename T>
const ::std::string& NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_Name(T value) {
  static_assert(::std::is_same<T, NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SatelliteBasedAugmentationSystem_Name().");
  return NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_Name(static_cast<NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>(value));
}
template <>
inline const ::std::string& NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_Name(NavigationSatelliteSystem_SatelliteBasedAugmentationSystem value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_descriptor, 0, 12>(
      static_cast<int>(value));
}
inline bool NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_Parse(
    ::absl::string_view name, NavigationSatelliteSystem_SatelliteBasedAugmentationSystem* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>(NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_descriptor(), name,
                                           value);
}
enum NavigationSatelliteSystem_GroundBasedAugmentationSystem : int {
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_UNKNOWN_GROUND_BASED = 0,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_GROUND_BASED = 1,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_GBAS = 2,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_NDGPS = 3,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_SAPOS = 4,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_ALF = 5,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_AXIO_NET = 6,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_VRS_NOW = 7,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_SMART_NET = 8,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_NavigationSatelliteSystem_GroundBasedAugmentationSystem_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_NavigationSatelliteSystem_GroundBasedAugmentationSystem_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t NavigationSatelliteSystem_GroundBasedAugmentationSystem_internal_data_[];
inline constexpr NavigationSatelliteSystem_GroundBasedAugmentationSystem NavigationSatelliteSystem_GroundBasedAugmentationSystem_GroundBasedAugmentationSystem_MIN =
    static_cast<NavigationSatelliteSystem_GroundBasedAugmentationSystem>(0);
inline constexpr NavigationSatelliteSystem_GroundBasedAugmentationSystem NavigationSatelliteSystem_GroundBasedAugmentationSystem_GroundBasedAugmentationSystem_MAX =
    static_cast<NavigationSatelliteSystem_GroundBasedAugmentationSystem>(8);
inline bool NavigationSatelliteSystem_GroundBasedAugmentationSystem_IsValid(int value) {
  return 0 <= value && value <= 8;
}
inline constexpr int NavigationSatelliteSystem_GroundBasedAugmentationSystem_GroundBasedAugmentationSystem_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL NavigationSatelliteSystem_GroundBasedAugmentationSystem_descriptor();
template <typename T>
const ::std::string& NavigationSatelliteSystem_GroundBasedAugmentationSystem_Name(T value) {
  static_assert(::std::is_same<T, NavigationSatelliteSystem_GroundBasedAugmentationSystem>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GroundBasedAugmentationSystem_Name().");
  return NavigationSatelliteSystem_GroundBasedAugmentationSystem_Name(static_cast<NavigationSatelliteSystem_GroundBasedAugmentationSystem>(value));
}
template <>
inline const ::std::string& NavigationSatelliteSystem_GroundBasedAugmentationSystem_Name(NavigationSatelliteSystem_GroundBasedAugmentationSystem value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NavigationSatelliteSystem_GroundBasedAugmentationSystem_descriptor, 0, 8>(
      static_cast<int>(value));
}
inline bool NavigationSatelliteSystem_GroundBasedAugmentationSystem_Parse(
    ::absl::string_view name, NavigationSatelliteSystem_GroundBasedAugmentationSystem* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<NavigationSatelliteSystem_GroundBasedAugmentationSystem>(NavigationSatelliteSystem_GroundBasedAugmentationSystem_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class SensorFusion final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.source.SensorFusion) */ {
 public:
  inline SensorFusion() : SensorFusion(nullptr) {}
  ~SensorFusion() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SensorFusion* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SensorFusion));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorFusion(::google::protobuf::internal::ConstantInitialized);

  inline SensorFusion(const SensorFusion& from) : SensorFusion(nullptr, from) {}
  inline SensorFusion(SensorFusion&& from) noexcept
      : SensorFusion(nullptr, ::std::move(from)) {}
  inline SensorFusion& operator=(const SensorFusion& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorFusion& operator=(SensorFusion&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorFusion& default_instance() {
    return *reinterpret_cast<const SensorFusion*>(
        &_SensorFusion_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(SensorFusion& a, SensorFusion& b) { a.Swap(&b); }
  inline void Swap(SensorFusion* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorFusion* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorFusion* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SensorFusion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorFusion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorFusion& from) { SensorFusion::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SensorFusion* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.source.SensorFusion"; }

 protected:
  explicit SensorFusion(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SensorFusion(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SensorFusion& from);
  SensorFusion(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SensorFusion&& from) noexcept
      : SensorFusion(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSensorIdFieldNumber = 1,
  };
  // repeated .google.protobuf.Int64Value sensor_id = 1;
  int sensor_id_size() const;
  private:
  int _internal_sensor_id_size() const;

  public:
  void clear_sensor_id() ;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_sensor_id(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>* PROTOBUF_NONNULL mutable_sensor_id();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>& _internal_sensor_id() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>* PROTOBUF_NONNULL _internal_mutable_sensor_id();
  public:
  const ::google::protobuf::Int64Value& sensor_id(int index) const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL add_sensor_id();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>& sensor_id() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.source.SensorFusion)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SensorFusion& from_msg);
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Int64Value > sensor_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fsource_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SensorFusion_class_data_;
// -------------------------------------------------------------------

class Sensor_MountingPositionAndOrientation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation) */ {
 public:
  inline Sensor_MountingPositionAndOrientation() : Sensor_MountingPositionAndOrientation(nullptr) {}
  ~Sensor_MountingPositionAndOrientation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Sensor_MountingPositionAndOrientation* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Sensor_MountingPositionAndOrientation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Sensor_MountingPositionAndOrientation(::google::protobuf::internal::ConstantInitialized);

  inline Sensor_MountingPositionAndOrientation(const Sensor_MountingPositionAndOrientation& from) : Sensor_MountingPositionAndOrientation(nullptr, from) {}
  inline Sensor_MountingPositionAndOrientation(Sensor_MountingPositionAndOrientation&& from) noexcept
      : Sensor_MountingPositionAndOrientation(nullptr, ::std::move(from)) {}
  inline Sensor_MountingPositionAndOrientation& operator=(const Sensor_MountingPositionAndOrientation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sensor_MountingPositionAndOrientation& operator=(Sensor_MountingPositionAndOrientation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sensor_MountingPositionAndOrientation& default_instance() {
    return *reinterpret_cast<const Sensor_MountingPositionAndOrientation*>(
        &_Sensor_MountingPositionAndOrientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Sensor_MountingPositionAndOrientation& a, Sensor_MountingPositionAndOrientation& b) { a.Swap(&b); }
  inline void Swap(Sensor_MountingPositionAndOrientation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sensor_MountingPositionAndOrientation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sensor_MountingPositionAndOrientation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Sensor_MountingPositionAndOrientation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Sensor_MountingPositionAndOrientation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Sensor_MountingPositionAndOrientation& from) { Sensor_MountingPositionAndOrientation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Sensor_MountingPositionAndOrientation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation"; }

 protected:
  explicit Sensor_MountingPositionAndOrientation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Sensor_MountingPositionAndOrientation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Sensor_MountingPositionAndOrientation& from);
  Sensor_MountingPositionAndOrientation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Sensor_MountingPositionAndOrientation&& from) noexcept
      : Sensor_MountingPositionAndOrientation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTranslationAndAccuracyFieldNumber = 1,
    kOrientationAndAccuracyFieldNumber = 2,
  };
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy translation_and_accuracy = 1;
  bool has_translation_and_accuracy() const;
  void clear_translation_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& translation_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE release_translation_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL mutable_translation_and_accuracy();
  void set_allocated_translation_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_translation_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_translation_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_translation_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL _internal_mutable_translation_and_accuracy();

  public:
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
  bool has_orientation_and_accuracy() const;
  void clear_orientation_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& orientation_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE release_orientation_and_accuracy();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NONNULL mutable_orientation_and_accuracy();
  void set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_orientation_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& _internal_orientation_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NONNULL _internal_mutable_orientation_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Sensor_MountingPositionAndOrientation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE translation_and_accuracy_;
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE orientation_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fsource_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Sensor_MountingPositionAndOrientation_class_data_;
// -------------------------------------------------------------------

class NavigationSatelliteSystem final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.source.NavigationSatelliteSystem) */ {
 public:
  inline NavigationSatelliteSystem() : NavigationSatelliteSystem(nullptr) {}
  ~NavigationSatelliteSystem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NavigationSatelliteSystem* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NavigationSatelliteSystem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NavigationSatelliteSystem(::google::protobuf::internal::ConstantInitialized);

  inline NavigationSatelliteSystem(const NavigationSatelliteSystem& from) : NavigationSatelliteSystem(nullptr, from) {}
  inline NavigationSatelliteSystem(NavigationSatelliteSystem&& from) noexcept
      : NavigationSatelliteSystem(nullptr, ::std::move(from)) {}
  inline NavigationSatelliteSystem& operator=(const NavigationSatelliteSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationSatelliteSystem& operator=(NavigationSatelliteSystem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigationSatelliteSystem& default_instance() {
    return *reinterpret_cast<const NavigationSatelliteSystem*>(
        &_NavigationSatelliteSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(NavigationSatelliteSystem& a, NavigationSatelliteSystem& b) { a.Swap(&b); }
  inline void Swap(NavigationSatelliteSystem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationSatelliteSystem* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigationSatelliteSystem* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NavigationSatelliteSystem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NavigationSatelliteSystem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NavigationSatelliteSystem& from) { NavigationSatelliteSystem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NavigationSatelliteSystem* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.source.NavigationSatelliteSystem"; }

 protected:
  explicit NavigationSatelliteSystem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NavigationSatelliteSystem(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NavigationSatelliteSystem& from);
  NavigationSatelliteSystem(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NavigationSatelliteSystem&& from) noexcept
      : NavigationSatelliteSystem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using SatelliteSystem = NavigationSatelliteSystem_SatelliteSystem;
  static constexpr SatelliteSystem UNKNOWN_SATELLITE_SYSTEM = NavigationSatelliteSystem_SatelliteSystem_UNKNOWN_SATELLITE_SYSTEM;
  static constexpr SatelliteSystem GPS = NavigationSatelliteSystem_SatelliteSystem_GPS;
  static constexpr SatelliteSystem GLONASS = NavigationSatelliteSystem_SatelliteSystem_GLONASS;
  static constexpr SatelliteSystem GALILEO = NavigationSatelliteSystem_SatelliteSystem_GALILEO;
  static constexpr SatelliteSystem BEIDOU_1 = NavigationSatelliteSystem_SatelliteSystem_BEIDOU_1;
  static constexpr SatelliteSystem BEIDOU_2 = NavigationSatelliteSystem_SatelliteSystem_BEIDOU_2;
  static constexpr SatelliteSystem NAVIC = NavigationSatelliteSystem_SatelliteSystem_NAVIC;
  static constexpr SatelliteSystem QZSS = NavigationSatelliteSystem_SatelliteSystem_QZSS;
  static inline bool SatelliteSystem_IsValid(int value) {
    return NavigationSatelliteSystem_SatelliteSystem_IsValid(value);
  }
  static constexpr SatelliteSystem SatelliteSystem_MIN = NavigationSatelliteSystem_SatelliteSystem_SatelliteSystem_MIN;
  static constexpr SatelliteSystem SatelliteSystem_MAX = NavigationSatelliteSystem_SatelliteSystem_SatelliteSystem_MAX;
  static constexpr int SatelliteSystem_ARRAYSIZE = NavigationSatelliteSystem_SatelliteSystem_SatelliteSystem_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SatelliteSystem_descriptor() {
    return NavigationSatelliteSystem_SatelliteSystem_descriptor();
  }
  template <typename T>
  static inline const ::std::string& SatelliteSystem_Name(T value) {
    return NavigationSatelliteSystem_SatelliteSystem_Name(value);
  }
  static inline bool SatelliteSystem_Parse(
      ::absl::string_view name, SatelliteSystem* PROTOBUF_NONNULL value) {
    return NavigationSatelliteSystem_SatelliteSystem_Parse(name, value);
  }
  using SatelliteBasedAugmentationSystem = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem;
  static constexpr SatelliteBasedAugmentationSystem UNKNOWN_SATELLITE_BASED = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_UNKNOWN_SATELLITE_BASED;
  static constexpr SatelliteBasedAugmentationSystem SATELLITE_BASED = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SATELLITE_BASED;
  static constexpr SatelliteBasedAugmentationSystem WAAS = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_WAAS;
  static constexpr SatelliteBasedAugmentationSystem EGNOS = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_EGNOS;
  static constexpr SatelliteBasedAugmentationSystem MSAS = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_MSAS;
  static constexpr SatelliteBasedAugmentationSystem QZSS_SATELLITE_BASED = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_QZSS_SATELLITE_BASED;
  static constexpr SatelliteBasedAugmentationSystem GAGAN = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_GAGAN;
  static constexpr SatelliteBasedAugmentationSystem SDCM = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SDCM;
  static constexpr SatelliteBasedAugmentationSystem SNAS = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SNAS;
  static constexpr SatelliteBasedAugmentationSystem WAGE = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_WAGE;
  static constexpr SatelliteBasedAugmentationSystem STAR_FIRE = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_STAR_FIRE;
  static constexpr SatelliteBasedAugmentationSystem STAR_FIX = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_STAR_FIX;
  static constexpr SatelliteBasedAugmentationSystem OMNI_STAR = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_OMNI_STAR;
  static inline bool SatelliteBasedAugmentationSystem_IsValid(int value) {
    return NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_IsValid(value);
  }
  static constexpr SatelliteBasedAugmentationSystem SatelliteBasedAugmentationSystem_MIN = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SatelliteBasedAugmentationSystem_MIN;
  static constexpr SatelliteBasedAugmentationSystem SatelliteBasedAugmentationSystem_MAX = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SatelliteBasedAugmentationSystem_MAX;
  static constexpr int SatelliteBasedAugmentationSystem_ARRAYSIZE = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SatelliteBasedAugmentationSystem_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SatelliteBasedAugmentationSystem_descriptor() {
    return NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_descriptor();
  }
  template <typename T>
  static inline const ::std::string& SatelliteBasedAugmentationSystem_Name(T value) {
    return NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_Name(value);
  }
  static inline bool SatelliteBasedAugmentationSystem_Parse(
      ::absl::string_view name, SatelliteBasedAugmentationSystem* PROTOBUF_NONNULL value) {
    return NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_Parse(name, value);
  }
  using GroundBasedAugmentationSystem = NavigationSatelliteSystem_GroundBasedAugmentationSystem;
  static constexpr GroundBasedAugmentationSystem UNKNOWN_GROUND_BASED = NavigationSatelliteSystem_GroundBasedAugmentationSystem_UNKNOWN_GROUND_BASED;
  static constexpr GroundBasedAugmentationSystem GROUND_BASED = NavigationSatelliteSystem_GroundBasedAugmentationSystem_GROUND_BASED;
  static constexpr GroundBasedAugmentationSystem GBAS = NavigationSatelliteSystem_GroundBasedAugmentationSystem_GBAS;
  static constexpr GroundBasedAugmentationSystem NDGPS = NavigationSatelliteSystem_GroundBasedAugmentationSystem_NDGPS;
  static constexpr GroundBasedAugmentationSystem SAPOS = NavigationSatelliteSystem_GroundBasedAugmentationSystem_SAPOS;
  static constexpr GroundBasedAugmentationSystem ALF = NavigationSatelliteSystem_GroundBasedAugmentationSystem_ALF;
  static constexpr GroundBasedAugmentationSystem AXIO_NET = NavigationSatelliteSystem_GroundBasedAugmentationSystem_AXIO_NET;
  static constexpr GroundBasedAugmentationSystem VRS_NOW = NavigationSatelliteSystem_GroundBasedAugmentationSystem_VRS_NOW;
  static constexpr GroundBasedAugmentationSystem SMART_NET = NavigationSatelliteSystem_GroundBasedAugmentationSystem_SMART_NET;
  static inline bool GroundBasedAugmentationSystem_IsValid(int value) {
    return NavigationSatelliteSystem_GroundBasedAugmentationSystem_IsValid(value);
  }
  static constexpr GroundBasedAugmentationSystem GroundBasedAugmentationSystem_MIN = NavigationSatelliteSystem_GroundBasedAugmentationSystem_GroundBasedAugmentationSystem_MIN;
  static constexpr GroundBasedAugmentationSystem GroundBasedAugmentationSystem_MAX = NavigationSatelliteSystem_GroundBasedAugmentationSystem_GroundBasedAugmentationSystem_MAX;
  static constexpr int GroundBasedAugmentationSystem_ARRAYSIZE = NavigationSatelliteSystem_GroundBasedAugmentationSystem_GroundBasedAugmentationSystem_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GroundBasedAugmentationSystem_descriptor() {
    return NavigationSatelliteSystem_GroundBasedAugmentationSystem_descriptor();
  }
  template <typename T>
  static inline const ::std::string& GroundBasedAugmentationSystem_Name(T value) {
    return NavigationSatelliteSystem_GroundBasedAugmentationSystem_Name(value);
  }
  static inline bool GroundBasedAugmentationSystem_Parse(
      ::absl::string_view name, GroundBasedAugmentationSystem* PROTOBUF_NONNULL value) {
    return NavigationSatelliteSystem_GroundBasedAugmentationSystem_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kSatelliteSystemFieldNumber = 1,
    kSatelliteBasedAugmentationSystemFieldNumber = 2,
    kGroundBasedAugmentationSystemFieldNumber = 3,
    kExtensionFieldNumber = 15,
    kElevationMaskFieldNumber = 4,
    kAntennaOffsetAndAccuracyFieldNumber = 5,
  };
  // repeated .sensoris.protobuf.types.source.NavigationSatelliteSystem.SatelliteSystem satellite_system = 1;
  int satellite_system_size() const;
  private:
  int _internal_satellite_system_size() const;

  public:
  void clear_satellite_system() ;
  public:
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem satellite_system(int index) const;
  void set_satellite_system(int index, ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem value);
  void add_satellite_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem value);
  const ::google::protobuf::RepeatedField<int>& satellite_system() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_satellite_system();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_satellite_system() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_satellite_system();

  public:
  // repeated .sensoris.protobuf.types.source.NavigationSatelliteSystem.SatelliteBasedAugmentationSystem satellite_based_augmentation_system = 2;
  int satellite_based_augmentation_system_size() const;
  private:
  int _internal_satellite_based_augmentation_system_size() const;

  public:
  void clear_satellite_based_augmentation_system() ;
  public:
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem satellite_based_augmentation_system(int index) const;
  void set_satellite_based_augmentation_system(int index, ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem value);
  void add_satellite_based_augmentation_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem value);
  const ::google::protobuf::RepeatedField<int>& satellite_based_augmentation_system() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_satellite_based_augmentation_system();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_satellite_based_augmentation_system() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_satellite_based_augmentation_system();

  public:
  // repeated .sensoris.protobuf.types.source.NavigationSatelliteSystem.GroundBasedAugmentationSystem ground_based_augmentation_system = 3;
  int ground_based_augmentation_system_size() const;
  private:
  int _internal_ground_based_augmentation_system_size() const;

  public:
  void clear_ground_based_augmentation_system() ;
  public:
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem ground_based_augmentation_system(int index) const;
  void set_ground_based_augmentation_system(int index, ::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem value);
  void add_ground_based_augmentation_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem value);
  const ::google::protobuf::RepeatedField<int>& ground_based_augmentation_system() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_ground_based_augmentation_system();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_ground_based_augmentation_system() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_ground_based_augmentation_system();

  public:
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .google.protobuf.Int64Value elevation_mask = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_elevation_mask() const;
  void clear_elevation_mask() ;
  const ::google::protobuf::Int64Value& elevation_mask() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_elevation_mask();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_elevation_mask();
  void set_allocated_elevation_mask(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_elevation_mask(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_elevation_mask();

  private:
  const ::google::protobuf::Int64Value& _internal_elevation_mask() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_elevation_mask();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy antenna_offset_and_accuracy = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_antenna_offset_and_accuracy() const;
  void clear_antenna_offset_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& antenna_offset_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE release_antenna_offset_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL mutable_antenna_offset_and_accuracy();
  void set_allocated_antenna_offset_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_antenna_offset_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_antenna_offset_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_antenna_offset_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL _internal_mutable_antenna_offset_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.source.NavigationSatelliteSystem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NavigationSatelliteSystem& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> satellite_system_;
    ::google::protobuf::internal::CachedSize _satellite_system_cached_byte_size_;
    ::google::protobuf::RepeatedField<int> satellite_based_augmentation_system_;
    ::google::protobuf::internal::CachedSize _satellite_based_augmentation_system_cached_byte_size_;
    ::google::protobuf::RepeatedField<int> ground_based_augmentation_system_;
    ::google::protobuf::internal::CachedSize _ground_based_augmentation_system_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE elevation_mask_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE antenna_offset_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fsource_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NavigationSatelliteSystem_class_data_;
// -------------------------------------------------------------------

class Sensor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.source.Sensor) */ {
 public:
  inline Sensor() : Sensor(nullptr) {}
  ~Sensor() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Sensor* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Sensor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Sensor(::google::protobuf::internal::ConstantInitialized);

  inline Sensor(const Sensor& from) : Sensor(nullptr, from) {}
  inline Sensor(Sensor&& from) noexcept
      : Sensor(nullptr, ::std::move(from)) {}
  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sensor& operator=(Sensor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sensor& default_instance() {
    return *reinterpret_cast<const Sensor*>(
        &_Sensor_default_instance_);
  }
  enum SpecificCase {
    kNavigationSatelliteSystem = 2,
    SPECIFIC_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Sensor& a, Sensor& b) { a.Swap(&b); }
  inline void Swap(Sensor* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sensor* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sensor* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Sensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Sensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Sensor& from) { Sensor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Sensor* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.source.Sensor"; }

 protected:
  explicit Sensor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Sensor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Sensor& from);
  Sensor(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Sensor&& from) noexcept
      : Sensor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MountingPositionAndOrientation = Sensor_MountingPositionAndOrientation;

  // accessors -------------------------------------------------------
  enum : int {
    kMountingPositionAndOrientationFieldNumber = 1,
    kNavigationSatelliteSystemFieldNumber = 2,
  };
  // .sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation mounting_position_and_orientation = 1;
  bool has_mounting_position_and_orientation() const;
  void clear_mounting_position_and_orientation() ;
  const ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation& mounting_position_and_orientation() const;
  [[nodiscard]] ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NULLABLE release_mounting_position_and_orientation();
  ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NONNULL mutable_mounting_position_and_orientation();
  void set_allocated_mounting_position_and_orientation(::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_mounting_position_and_orientation(::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NULLABLE unsafe_arena_release_mounting_position_and_orientation();

  private:
  const ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation& _internal_mounting_position_and_orientation() const;
  ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NONNULL _internal_mutable_mounting_position_and_orientation();

  public:
  // .sensoris.protobuf.types.source.NavigationSatelliteSystem navigation_satellite_system = 2;
  bool has_navigation_satellite_system() const;
  private:
  bool _internal_has_navigation_satellite_system() const;

  public:
  void clear_navigation_satellite_system() ;
  const ::sensoris::protobuf::types::source::NavigationSatelliteSystem& navigation_satellite_system() const;
  [[nodiscard]] ::sensoris::protobuf::types::source::NavigationSatelliteSystem* PROTOBUF_NULLABLE release_navigation_satellite_system();
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem* PROTOBUF_NONNULL mutable_navigation_satellite_system();
  void set_allocated_navigation_satellite_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_navigation_satellite_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem* PROTOBUF_NULLABLE unsafe_arena_release_navigation_satellite_system();

  private:
  const ::sensoris::protobuf::types::source::NavigationSatelliteSystem& _internal_navigation_satellite_system() const;
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem* PROTOBUF_NONNULL _internal_mutable_navigation_satellite_system();

  public:
  void clear_specific();
  SpecificCase specific_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.source.Sensor)
 private:
  class _Internal;
  void set_has_navigation_satellite_system();
  inline bool has_specific() const;
  inline void clear_has_specific();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Sensor& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NULLABLE mounting_position_and_orientation_;
    union SpecificUnion {
      constexpr SpecificUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::source::NavigationSatelliteSystem* PROTOBUF_NULLABLE navigation_satellite_system_;
    } specific_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fsource_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Sensor_class_data_;
// -------------------------------------------------------------------

class Source final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.source.Source) */ {
 public:
  inline Source() : Source(nullptr) {}
  ~Source() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Source* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Source));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Source(::google::protobuf::internal::ConstantInitialized);

  inline Source(const Source& from) : Source(nullptr, from) {}
  inline Source(Source&& from) noexcept
      : Source(nullptr, ::std::move(from)) {}
  inline Source& operator=(const Source& from) {
    CopyFrom(from);
    return *this;
  }
  inline Source& operator=(Source&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Source& default_instance() {
    return *reinterpret_cast<const Source*>(
        &_Source_default_instance_);
  }
  enum SourceCase {
    kSensor = 4,
    kSensorFusion = 5,
    SOURCE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Source& a, Source& b) { a.Swap(&b); }
  inline void Swap(Source* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Source* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Source* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Source>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Source& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Source& from) { Source::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Source* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.source.Source"; }

 protected:
  explicit Source(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Source(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Source& from);
  Source(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Source&& from) noexcept
      : Source(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kIdFieldNumber = 1,
    kEntityFieldNumber = 2,
    kSamplingFrequencyFieldNumber = 3,
    kSensorFieldNumber = 4,
    kSensorFusionFieldNumber = 5,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .google.protobuf.Int64Value id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::google::protobuf::Int64Value& id() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_id();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_id();
  void set_allocated_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_id();

  private:
  const ::google::protobuf::Int64Value& _internal_id() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_id();

  public:
  // .sensoris.protobuf.types.base.Entity entity = 2;
  bool has_entity() const;
  void clear_entity() ;
  const ::sensoris::protobuf::types::base::Entity& entity() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Entity* PROTOBUF_NULLABLE release_entity();
  ::sensoris::protobuf::types::base::Entity* PROTOBUF_NONNULL mutable_entity();
  void set_allocated_entity(::sensoris::protobuf::types::base::Entity* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_entity(::sensoris::protobuf::types::base::Entity* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Entity* PROTOBUF_NULLABLE unsafe_arena_release_entity();

  private:
  const ::sensoris::protobuf::types::base::Entity& _internal_entity() const;
  ::sensoris::protobuf::types::base::Entity* PROTOBUF_NONNULL _internal_mutable_entity();

  public:
  // .sensoris.protobuf.types.base.Int64Value sampling_frequency = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_sampling_frequency() const;
  void clear_sampling_frequency() ;
  const ::sensoris::protobuf::types::base::Int64Value& sampling_frequency() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_sampling_frequency();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_sampling_frequency();
  void set_allocated_sampling_frequency(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sampling_frequency(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_sampling_frequency();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_sampling_frequency() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_sampling_frequency();

  public:
  // .sensoris.protobuf.types.source.Sensor sensor = 4;
  bool has_sensor() const;
  private:
  bool _internal_has_sensor() const;

  public:
  void clear_sensor() ;
  const ::sensoris::protobuf::types::source::Sensor& sensor() const;
  [[nodiscard]] ::sensoris::protobuf::types::source::Sensor* PROTOBUF_NULLABLE release_sensor();
  ::sensoris::protobuf::types::source::Sensor* PROTOBUF_NONNULL mutable_sensor();
  void set_allocated_sensor(::sensoris::protobuf::types::source::Sensor* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sensor(::sensoris::protobuf::types::source::Sensor* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::source::Sensor* PROTOBUF_NULLABLE unsafe_arena_release_sensor();

  private:
  const ::sensoris::protobuf::types::source::Sensor& _internal_sensor() const;
  ::sensoris::protobuf::types::source::Sensor* PROTOBUF_NONNULL _internal_mutable_sensor();

  public:
  // .sensoris.protobuf.types.source.SensorFusion sensor_fusion = 5;
  bool has_sensor_fusion() const;
  private:
  bool _internal_has_sensor_fusion() const;

  public:
  void clear_sensor_fusion() ;
  const ::sensoris::protobuf::types::source::SensorFusion& sensor_fusion() const;
  [[nodiscard]] ::sensoris::protobuf::types::source::SensorFusion* PROTOBUF_NULLABLE release_sensor_fusion();
  ::sensoris::protobuf::types::source::SensorFusion* PROTOBUF_NONNULL mutable_sensor_fusion();
  void set_allocated_sensor_fusion(::sensoris::protobuf::types::source::SensorFusion* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sensor_fusion(::sensoris::protobuf::types::source::SensorFusion* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::source::SensorFusion* PROTOBUF_NULLABLE unsafe_arena_release_sensor_fusion();

  private:
  const ::sensoris::protobuf::types::source::SensorFusion& _internal_sensor_fusion() const;
  ::sensoris::protobuf::types::source::SensorFusion* PROTOBUF_NONNULL _internal_mutable_sensor_fusion();

  public:
  void clear_source();
  SourceCase source_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.source.Source)
 private:
  class _Internal;
  void set_has_sensor();
  void set_has_sensor_fusion();
  inline bool has_source() const;
  inline void clear_has_source();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   6, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Source& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE id_;
    ::sensoris::protobuf::types::base::Entity* PROTOBUF_NULLABLE entity_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE sampling_frequency_;
    union SourceUnion {
      constexpr SourceUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::source::Sensor* PROTOBUF_NULLABLE sensor_;
      ::sensoris::protobuf::types::source::SensorFusion* PROTOBUF_NULLABLE sensor_fusion_;
    } source_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fsource_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Source_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NavigationSatelliteSystem

// repeated .sensoris.protobuf.types.source.NavigationSatelliteSystem.SatelliteSystem satellite_system = 1;
inline int NavigationSatelliteSystem::_internal_satellite_system_size() const {
  return _internal_satellite_system().size();
}
inline int NavigationSatelliteSystem::satellite_system_size() const {
  return _internal_satellite_system_size();
}
inline void NavigationSatelliteSystem::clear_satellite_system() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.satellite_system_.Clear();
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem NavigationSatelliteSystem::satellite_system(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_system)
  return static_cast<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem>(_internal_satellite_system().Get(index));
}
inline void NavigationSatelliteSystem::set_satellite_system(int index, ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem value) {
  _internal_mutable_satellite_system()->Set(index, value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_system)
}
inline void NavigationSatelliteSystem::add_satellite_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_satellite_system()->Add(value);
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_system)
}
inline const ::google::protobuf::RepeatedField<int>& NavigationSatelliteSystem::satellite_system() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_system)
  return _internal_satellite_system();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL NavigationSatelliteSystem::mutable_satellite_system()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_system)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_satellite_system();
}
inline const ::google::protobuf::RepeatedField<int>& NavigationSatelliteSystem::_internal_satellite_system()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.satellite_system_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
NavigationSatelliteSystem::_internal_mutable_satellite_system() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.satellite_system_;
}

// repeated .sensoris.protobuf.types.source.NavigationSatelliteSystem.SatelliteBasedAugmentationSystem satellite_based_augmentation_system = 2;
inline int NavigationSatelliteSystem::_internal_satellite_based_augmentation_system_size() const {
  return _internal_satellite_based_augmentation_system().size();
}
inline int NavigationSatelliteSystem::satellite_based_augmentation_system_size() const {
  return _internal_satellite_based_augmentation_system_size();
}
inline void NavigationSatelliteSystem::clear_satellite_based_augmentation_system() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.satellite_based_augmentation_system_.Clear();
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem NavigationSatelliteSystem::satellite_based_augmentation_system(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_based_augmentation_system)
  return static_cast<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>(_internal_satellite_based_augmentation_system().Get(index));
}
inline void NavigationSatelliteSystem::set_satellite_based_augmentation_system(int index, ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem value) {
  _internal_mutable_satellite_based_augmentation_system()->Set(index, value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_based_augmentation_system)
}
inline void NavigationSatelliteSystem::add_satellite_based_augmentation_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_satellite_based_augmentation_system()->Add(value);
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_based_augmentation_system)
}
inline const ::google::protobuf::RepeatedField<int>& NavigationSatelliteSystem::satellite_based_augmentation_system() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_based_augmentation_system)
  return _internal_satellite_based_augmentation_system();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL NavigationSatelliteSystem::mutable_satellite_based_augmentation_system()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_based_augmentation_system)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_satellite_based_augmentation_system();
}
inline const ::google::protobuf::RepeatedField<int>& NavigationSatelliteSystem::_internal_satellite_based_augmentation_system()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.satellite_based_augmentation_system_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
NavigationSatelliteSystem::_internal_mutable_satellite_based_augmentation_system() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.satellite_based_augmentation_system_;
}

// repeated .sensoris.protobuf.types.source.NavigationSatelliteSystem.GroundBasedAugmentationSystem ground_based_augmentation_system = 3;
inline int NavigationSatelliteSystem::_internal_ground_based_augmentation_system_size() const {
  return _internal_ground_based_augmentation_system().size();
}
inline int NavigationSatelliteSystem::ground_based_augmentation_system_size() const {
  return _internal_ground_based_augmentation_system_size();
}
inline void NavigationSatelliteSystem::clear_ground_based_augmentation_system() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ground_based_augmentation_system_.Clear();
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem NavigationSatelliteSystem::ground_based_augmentation_system(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.NavigationSatelliteSystem.ground_based_augmentation_system)
  return static_cast<::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem>(_internal_ground_based_augmentation_system().Get(index));
}
inline void NavigationSatelliteSystem::set_ground_based_augmentation_system(int index, ::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem value) {
  _internal_mutable_ground_based_augmentation_system()->Set(index, value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.types.source.NavigationSatelliteSystem.ground_based_augmentation_system)
}
inline void NavigationSatelliteSystem::add_ground_based_augmentation_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_ground_based_augmentation_system()->Add(value);
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.source.NavigationSatelliteSystem.ground_based_augmentation_system)
}
inline const ::google::protobuf::RepeatedField<int>& NavigationSatelliteSystem::ground_based_augmentation_system() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.ground_based_augmentation_system)
  return _internal_ground_based_augmentation_system();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL NavigationSatelliteSystem::mutable_ground_based_augmentation_system()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.ground_based_augmentation_system)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ground_based_augmentation_system();
}
inline const ::google::protobuf::RepeatedField<int>& NavigationSatelliteSystem::_internal_ground_based_augmentation_system()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ground_based_augmentation_system_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
NavigationSatelliteSystem::_internal_mutable_ground_based_augmentation_system() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ground_based_augmentation_system_;
}

// .google.protobuf.Int64Value elevation_mask = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool NavigationSatelliteSystem::has_elevation_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.elevation_mask_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& NavigationSatelliteSystem::_internal_elevation_mask() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.elevation_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& NavigationSatelliteSystem::elevation_mask() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.NavigationSatelliteSystem.elevation_mask)
  return _internal_elevation_mask();
}
inline void NavigationSatelliteSystem::unsafe_arena_set_allocated_elevation_mask(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.elevation_mask_);
  }
  _impl_.elevation_mask_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.NavigationSatelliteSystem.elevation_mask)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE NavigationSatelliteSystem::release_elevation_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.elevation_mask_;
  _impl_.elevation_mask_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE NavigationSatelliteSystem::unsafe_arena_release_elevation_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.NavigationSatelliteSystem.elevation_mask)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.elevation_mask_;
  _impl_.elevation_mask_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL NavigationSatelliteSystem::_internal_mutable_elevation_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.elevation_mask_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.elevation_mask_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.elevation_mask_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL NavigationSatelliteSystem::mutable_elevation_mask()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_elevation_mask();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.NavigationSatelliteSystem.elevation_mask)
  return _msg;
}
inline void NavigationSatelliteSystem::set_allocated_elevation_mask(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.elevation_mask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.elevation_mask_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.NavigationSatelliteSystem.elevation_mask)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy antenna_offset_and_accuracy = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool NavigationSatelliteSystem::has_antenna_offset_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.antenna_offset_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& NavigationSatelliteSystem::_internal_antenna_offset_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.antenna_offset_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& NavigationSatelliteSystem::antenna_offset_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.NavigationSatelliteSystem.antenna_offset_and_accuracy)
  return _internal_antenna_offset_and_accuracy();
}
inline void NavigationSatelliteSystem::unsafe_arena_set_allocated_antenna_offset_and_accuracy(
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.antenna_offset_and_accuracy_);
  }
  _impl_.antenna_offset_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.NavigationSatelliteSystem.antenna_offset_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE NavigationSatelliteSystem::release_antenna_offset_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.antenna_offset_and_accuracy_;
  _impl_.antenna_offset_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE NavigationSatelliteSystem::unsafe_arena_release_antenna_offset_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.NavigationSatelliteSystem.antenna_offset_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.antenna_offset_and_accuracy_;
  _impl_.antenna_offset_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL NavigationSatelliteSystem::_internal_mutable_antenna_offset_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.antenna_offset_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.antenna_offset_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.antenna_offset_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL NavigationSatelliteSystem::mutable_antenna_offset_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_antenna_offset_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.NavigationSatelliteSystem.antenna_offset_and_accuracy)
  return _msg;
}
inline void NavigationSatelliteSystem::set_allocated_antenna_offset_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.antenna_offset_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.antenna_offset_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.NavigationSatelliteSystem.antenna_offset_and_accuracy)
}

// repeated .google.protobuf.Any extension = 15;
inline int NavigationSatelliteSystem::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int NavigationSatelliteSystem::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL NavigationSatelliteSystem::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.NavigationSatelliteSystem.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL NavigationSatelliteSystem::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& NavigationSatelliteSystem::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.NavigationSatelliteSystem.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL NavigationSatelliteSystem::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.source.NavigationSatelliteSystem.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& NavigationSatelliteSystem::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
NavigationSatelliteSystem::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
NavigationSatelliteSystem::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// Sensor_MountingPositionAndOrientation

// .sensoris.protobuf.types.spatial.PositionAndAccuracy translation_and_accuracy = 1;
inline bool Sensor_MountingPositionAndOrientation::has_translation_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.translation_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& Sensor_MountingPositionAndOrientation::_internal_translation_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.translation_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& Sensor_MountingPositionAndOrientation::translation_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.translation_and_accuracy)
  return _internal_translation_and_accuracy();
}
inline void Sensor_MountingPositionAndOrientation::unsafe_arena_set_allocated_translation_and_accuracy(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.translation_and_accuracy_);
  }
  _impl_.translation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.translation_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE Sensor_MountingPositionAndOrientation::release_translation_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.translation_and_accuracy_;
  _impl_.translation_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE Sensor_MountingPositionAndOrientation::unsafe_arena_release_translation_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.translation_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.translation_and_accuracy_;
  _impl_.translation_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL Sensor_MountingPositionAndOrientation::_internal_mutable_translation_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.translation_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.translation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.translation_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL Sensor_MountingPositionAndOrientation::mutable_translation_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_translation_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.translation_and_accuracy)
  return _msg;
}
inline void Sensor_MountingPositionAndOrientation::set_allocated_translation_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.translation_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.translation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.translation_and_accuracy)
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
inline bool Sensor_MountingPositionAndOrientation::has_orientation_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& Sensor_MountingPositionAndOrientation::_internal_orientation_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy* p = _impl_.orientation_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::RotationAndAccuracy&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& Sensor_MountingPositionAndOrientation::orientation_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.orientation_and_accuracy)
  return _internal_orientation_and_accuracy();
}
inline void Sensor_MountingPositionAndOrientation::unsafe_arena_set_allocated_orientation_and_accuracy(
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_and_accuracy_);
  }
  _impl_.orientation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.orientation_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE Sensor_MountingPositionAndOrientation::release_orientation_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* released = _impl_.orientation_and_accuracy_;
  _impl_.orientation_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE Sensor_MountingPositionAndOrientation::unsafe_arena_release_orientation_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.orientation_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* temp = _impl_.orientation_and_accuracy_;
  _impl_.orientation_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NONNULL Sensor_MountingPositionAndOrientation::_internal_mutable_orientation_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::RotationAndAccuracy>(GetArena());
    _impl_.orientation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(p);
  }
  return _impl_.orientation_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NONNULL Sensor_MountingPositionAndOrientation::mutable_orientation_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* _msg = _internal_mutable_orientation_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.orientation_and_accuracy)
  return _msg;
}
inline void Sensor_MountingPositionAndOrientation::set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.orientation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.orientation_and_accuracy)
}

// -------------------------------------------------------------------

// Sensor

// .sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation mounting_position_and_orientation = 1;
inline bool Sensor::has_mounting_position_and_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mounting_position_and_orientation_ != nullptr);
  return value;
}
inline void Sensor::clear_mounting_position_and_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mounting_position_and_orientation_ != nullptr) _impl_.mounting_position_and_orientation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation& Sensor::_internal_mounting_position_and_orientation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* p = _impl_.mounting_position_and_orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation&>(::sensoris::protobuf::types::source::_Sensor_MountingPositionAndOrientation_default_instance_);
}
inline const ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation& Sensor::mounting_position_and_orientation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Sensor.mounting_position_and_orientation)
  return _internal_mounting_position_and_orientation();
}
inline void Sensor::unsafe_arena_set_allocated_mounting_position_and_orientation(
    ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mounting_position_and_orientation_);
  }
  _impl_.mounting_position_and_orientation_ = reinterpret_cast<::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Sensor.mounting_position_and_orientation)
}
inline ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NULLABLE Sensor::release_mounting_position_and_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* released = _impl_.mounting_position_and_orientation_;
  _impl_.mounting_position_and_orientation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NULLABLE Sensor::unsafe_arena_release_mounting_position_and_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Sensor.mounting_position_and_orientation)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* temp = _impl_.mounting_position_and_orientation_;
  _impl_.mounting_position_and_orientation_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NONNULL Sensor::_internal_mutable_mounting_position_and_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mounting_position_and_orientation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation>(GetArena());
    _impl_.mounting_position_and_orientation_ = reinterpret_cast<::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation*>(p);
  }
  return _impl_.mounting_position_and_orientation_;
}
inline ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NONNULL Sensor::mutable_mounting_position_and_orientation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* _msg = _internal_mutable_mounting_position_and_orientation();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Sensor.mounting_position_and_orientation)
  return _msg;
}
inline void Sensor::set_allocated_mounting_position_and_orientation(::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mounting_position_and_orientation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.mounting_position_and_orientation_ = reinterpret_cast<::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.Sensor.mounting_position_and_orientation)
}

// .sensoris.protobuf.types.source.NavigationSatelliteSystem navigation_satellite_system = 2;
inline bool Sensor::has_navigation_satellite_system() const {
  return specific_case() == kNavigationSatelliteSystem;
}
inline bool Sensor::_internal_has_navigation_satellite_system() const {
  return specific_case() == kNavigationSatelliteSystem;
}
inline void Sensor::set_has_navigation_satellite_system() {
  _impl_._oneof_case_[0] = kNavigationSatelliteSystem;
}
inline void Sensor::clear_navigation_satellite_system() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (specific_case() == kNavigationSatelliteSystem) {
    if (GetArena() == nullptr) {
      delete _impl_.specific_.navigation_satellite_system_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.specific_.navigation_satellite_system_);
    }
    clear_has_specific();
  }
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem* PROTOBUF_NULLABLE Sensor::release_navigation_satellite_system() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Sensor.navigation_satellite_system)
  if (specific_case() == kNavigationSatelliteSystem) {
    clear_has_specific();
    auto* temp = _impl_.specific_.navigation_satellite_system_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.specific_.navigation_satellite_system_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::source::NavigationSatelliteSystem& Sensor::_internal_navigation_satellite_system() const {
  return specific_case() == kNavigationSatelliteSystem ? *_impl_.specific_.navigation_satellite_system_ : reinterpret_cast<::sensoris::protobuf::types::source::NavigationSatelliteSystem&>(::sensoris::protobuf::types::source::_NavigationSatelliteSystem_default_instance_);
}
inline const ::sensoris::protobuf::types::source::NavigationSatelliteSystem& Sensor::navigation_satellite_system() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Sensor.navigation_satellite_system)
  return _internal_navigation_satellite_system();
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem* PROTOBUF_NULLABLE Sensor::unsafe_arena_release_navigation_satellite_system() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.source.Sensor.navigation_satellite_system)
  if (specific_case() == kNavigationSatelliteSystem) {
    clear_has_specific();
    auto* temp = _impl_.specific_.navigation_satellite_system_;
    _impl_.specific_.navigation_satellite_system_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Sensor::unsafe_arena_set_allocated_navigation_satellite_system(
    ::sensoris::protobuf::types::source::NavigationSatelliteSystem* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_specific();
  if (value) {
    set_has_navigation_satellite_system();
    _impl_.specific_.navigation_satellite_system_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Sensor.navigation_satellite_system)
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem* PROTOBUF_NONNULL Sensor::_internal_mutable_navigation_satellite_system() {
  if (specific_case() != kNavigationSatelliteSystem) {
    clear_specific();
    set_has_navigation_satellite_system();
    _impl_.specific_.navigation_satellite_system_ = 
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::source::NavigationSatelliteSystem>(GetArena());
  }
  return _impl_.specific_.navigation_satellite_system_;
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem* PROTOBUF_NONNULL Sensor::mutable_navigation_satellite_system()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem* _msg = _internal_mutable_navigation_satellite_system();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Sensor.navigation_satellite_system)
  return _msg;
}

inline bool Sensor::has_specific() const {
  return specific_case() != SPECIFIC_NOT_SET;
}
inline void Sensor::clear_has_specific() {
  _impl_._oneof_case_[0] = SPECIFIC_NOT_SET;
}
inline Sensor::SpecificCase Sensor::specific_case() const {
  return Sensor::SpecificCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SensorFusion

// repeated .google.protobuf.Int64Value sensor_id = 1;
inline int SensorFusion::_internal_sensor_id_size() const {
  return _internal_sensor_id().size();
}
inline int SensorFusion::sensor_id_size() const {
  return _internal_sensor_id_size();
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL SensorFusion::mutable_sensor_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.SensorFusion.sensor_id)
  return _internal_mutable_sensor_id()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>* PROTOBUF_NONNULL SensorFusion::mutable_sensor_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.source.SensorFusion.sensor_id)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sensor_id();
}
inline const ::google::protobuf::Int64Value& SensorFusion::sensor_id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.SensorFusion.sensor_id)
  return _internal_sensor_id().Get(index);
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL SensorFusion::add_sensor_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Int64Value* _add = _internal_mutable_sensor_id()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.source.SensorFusion.sensor_id)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>& SensorFusion::sensor_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.source.SensorFusion.sensor_id)
  return _internal_sensor_id();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>&
SensorFusion::_internal_sensor_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensor_id_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>* PROTOBUF_NONNULL
SensorFusion::_internal_mutable_sensor_id() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sensor_id_;
}

// -------------------------------------------------------------------

// Source

// .google.protobuf.Int64Value id = 1;
inline bool Source::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& Source::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& Source::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Source.id)
  return _internal_id();
}
inline void Source::unsafe_arena_set_allocated_id(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Source.id)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE Source::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.id_;
  _impl_.id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE Source::unsafe_arena_release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Source.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL Source::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.id_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL Source::mutable_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Source.id)
  return _msg;
}
inline void Source::set_allocated_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.Source.id)
}

// .sensoris.protobuf.types.base.Entity entity = 2;
inline bool Source::has_entity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.entity_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Entity& Source::_internal_entity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Entity* p = _impl_.entity_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Entity&>(::sensoris::protobuf::types::base::_Entity_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Entity& Source::entity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Source.entity)
  return _internal_entity();
}
inline void Source::unsafe_arena_set_allocated_entity(
    ::sensoris::protobuf::types::base::Entity* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entity_);
  }
  _impl_.entity_ = reinterpret_cast<::sensoris::protobuf::types::base::Entity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Source.entity)
}
inline ::sensoris::protobuf::types::base::Entity* PROTOBUF_NULLABLE Source::release_entity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Entity* released = _impl_.entity_;
  _impl_.entity_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Entity* PROTOBUF_NULLABLE Source::unsafe_arena_release_entity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Source.entity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Entity* temp = _impl_.entity_;
  _impl_.entity_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Entity* PROTOBUF_NONNULL Source::_internal_mutable_entity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.entity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Entity>(GetArena());
    _impl_.entity_ = reinterpret_cast<::sensoris::protobuf::types::base::Entity*>(p);
  }
  return _impl_.entity_;
}
inline ::sensoris::protobuf::types::base::Entity* PROTOBUF_NONNULL Source::mutable_entity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Entity* _msg = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Source.entity)
  return _msg;
}
inline void Source::set_allocated_entity(::sensoris::protobuf::types::base::Entity* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.entity_ = reinterpret_cast<::sensoris::protobuf::types::base::Entity*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.Source.entity)
}

// .sensoris.protobuf.types.base.Int64Value sampling_frequency = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool Source::has_sampling_frequency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sampling_frequency_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& Source::_internal_sampling_frequency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.sampling_frequency_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& Source::sampling_frequency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Source.sampling_frequency)
  return _internal_sampling_frequency();
}
inline void Source::unsafe_arena_set_allocated_sampling_frequency(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sampling_frequency_);
  }
  _impl_.sampling_frequency_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Source.sampling_frequency)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE Source::release_sampling_frequency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.sampling_frequency_;
  _impl_.sampling_frequency_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE Source::unsafe_arena_release_sampling_frequency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Source.sampling_frequency)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.sampling_frequency_;
  _impl_.sampling_frequency_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL Source::_internal_mutable_sampling_frequency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sampling_frequency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.sampling_frequency_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.sampling_frequency_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL Source::mutable_sampling_frequency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_sampling_frequency();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Source.sampling_frequency)
  return _msg;
}
inline void Source::set_allocated_sampling_frequency(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sampling_frequency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.sampling_frequency_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.Source.sampling_frequency)
}

// .sensoris.protobuf.types.source.Sensor sensor = 4;
inline bool Source::has_sensor() const {
  return source_case() == kSensor;
}
inline bool Source::_internal_has_sensor() const {
  return source_case() == kSensor;
}
inline void Source::set_has_sensor() {
  _impl_._oneof_case_[0] = kSensor;
}
inline void Source::clear_sensor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (source_case() == kSensor) {
    if (GetArena() == nullptr) {
      delete _impl_.source_.sensor_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.source_.sensor_);
    }
    clear_has_source();
  }
}
inline ::sensoris::protobuf::types::source::Sensor* PROTOBUF_NULLABLE Source::release_sensor() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Source.sensor)
  if (source_case() == kSensor) {
    clear_has_source();
    auto* temp = _impl_.source_.sensor_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.source_.sensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::source::Sensor& Source::_internal_sensor() const {
  return source_case() == kSensor ? *_impl_.source_.sensor_ : reinterpret_cast<::sensoris::protobuf::types::source::Sensor&>(::sensoris::protobuf::types::source::_Sensor_default_instance_);
}
inline const ::sensoris::protobuf::types::source::Sensor& Source::sensor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Source.sensor)
  return _internal_sensor();
}
inline ::sensoris::protobuf::types::source::Sensor* PROTOBUF_NULLABLE Source::unsafe_arena_release_sensor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.source.Source.sensor)
  if (source_case() == kSensor) {
    clear_has_source();
    auto* temp = _impl_.source_.sensor_;
    _impl_.source_.sensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Source::unsafe_arena_set_allocated_sensor(
    ::sensoris::protobuf::types::source::Sensor* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_source();
  if (value) {
    set_has_sensor();
    _impl_.source_.sensor_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Source.sensor)
}
inline ::sensoris::protobuf::types::source::Sensor* PROTOBUF_NONNULL Source::_internal_mutable_sensor() {
  if (source_case() != kSensor) {
    clear_source();
    set_has_sensor();
    _impl_.source_.sensor_ = 
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::source::Sensor>(GetArena());
  }
  return _impl_.source_.sensor_;
}
inline ::sensoris::protobuf::types::source::Sensor* PROTOBUF_NONNULL Source::mutable_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::source::Sensor* _msg = _internal_mutable_sensor();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Source.sensor)
  return _msg;
}

// .sensoris.protobuf.types.source.SensorFusion sensor_fusion = 5;
inline bool Source::has_sensor_fusion() const {
  return source_case() == kSensorFusion;
}
inline bool Source::_internal_has_sensor_fusion() const {
  return source_case() == kSensorFusion;
}
inline void Source::set_has_sensor_fusion() {
  _impl_._oneof_case_[0] = kSensorFusion;
}
inline void Source::clear_sensor_fusion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (source_case() == kSensorFusion) {
    if (GetArena() == nullptr) {
      delete _impl_.source_.sensor_fusion_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.source_.sensor_fusion_);
    }
    clear_has_source();
  }
}
inline ::sensoris::protobuf::types::source::SensorFusion* PROTOBUF_NULLABLE Source::release_sensor_fusion() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Source.sensor_fusion)
  if (source_case() == kSensorFusion) {
    clear_has_source();
    auto* temp = _impl_.source_.sensor_fusion_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.source_.sensor_fusion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::source::SensorFusion& Source::_internal_sensor_fusion() const {
  return source_case() == kSensorFusion ? *_impl_.source_.sensor_fusion_ : reinterpret_cast<::sensoris::protobuf::types::source::SensorFusion&>(::sensoris::protobuf::types::source::_SensorFusion_default_instance_);
}
inline const ::sensoris::protobuf::types::source::SensorFusion& Source::sensor_fusion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Source.sensor_fusion)
  return _internal_sensor_fusion();
}
inline ::sensoris::protobuf::types::source::SensorFusion* PROTOBUF_NULLABLE Source::unsafe_arena_release_sensor_fusion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.source.Source.sensor_fusion)
  if (source_case() == kSensorFusion) {
    clear_has_source();
    auto* temp = _impl_.source_.sensor_fusion_;
    _impl_.source_.sensor_fusion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Source::unsafe_arena_set_allocated_sensor_fusion(
    ::sensoris::protobuf::types::source::SensorFusion* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_source();
  if (value) {
    set_has_sensor_fusion();
    _impl_.source_.sensor_fusion_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Source.sensor_fusion)
}
inline ::sensoris::protobuf::types::source::SensorFusion* PROTOBUF_NONNULL Source::_internal_mutable_sensor_fusion() {
  if (source_case() != kSensorFusion) {
    clear_source();
    set_has_sensor_fusion();
    _impl_.source_.sensor_fusion_ = 
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::source::SensorFusion>(GetArena());
  }
  return _impl_.source_.sensor_fusion_;
}
inline ::sensoris::protobuf::types::source::SensorFusion* PROTOBUF_NONNULL Source::mutable_sensor_fusion()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::source::SensorFusion* _msg = _internal_mutable_sensor_fusion();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Source.sensor_fusion)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int Source::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int Source::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL Source::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Source.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL Source::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.source.Source.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& Source::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Source.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL Source::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.source.Source.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& Source::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.source.Source.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
Source::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
Source::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

inline bool Source::has_source() const {
  return source_case() != SOURCE_NOT_SET;
}
inline void Source::clear_has_source() {
  _impl_._oneof_case_[0] = SOURCE_NOT_SET;
}
inline Source::SourceCase Source::source_case() const {
  return Source::SourceCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace source
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem>() {
  return ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>() {
  return ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem>() {
  return ::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // sensoris_2fprotobuf_2ftypes_2fsource_2eproto_2epb_2eh
