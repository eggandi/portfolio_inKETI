// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: sensoris/protobuf/categories/traffic_events.proto
// Protobuf C++ Version: 6.31.1

#ifndef sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto_2epb_2eh
#define sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/wrappers.pb.h"
#include "sensoris/protobuf/types/base.pb.h"
#include "sensoris/protobuf/types/spatial.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
}  // extern "C"
namespace sensoris {
namespace protobuf {
namespace categories {
namespace trafficevents {
enum ECallStatus_ActivationType : int;
extern const uint32_t ECallStatus_ActivationType_internal_data_[];
enum ECallStatus_Availability : int;
extern const uint32_t ECallStatus_Availability_internal_data_[];
enum Hazard_Direction : int;
extern const uint32_t Hazard_Direction_internal_data_[];
enum Hazard_TypeAndConfidence_Type : int;
extern const uint32_t Hazard_TypeAndConfidence_Type_internal_data_[];
enum RoadObstructionCondition_TypeAndConfidence_Type : int;
extern const uint32_t RoadObstructionCondition_TypeAndConfidence_Type_internal_data_[];
enum RoadSurfaceCondition_TypeAndConfidence_Type : int;
extern const uint32_t RoadSurfaceCondition_TypeAndConfidence_Type_internal_data_[];
enum RoadWeatherCondition_TypeAndConfidence_Type : int;
extern const uint32_t RoadWeatherCondition_TypeAndConfidence_Type_internal_data_[];
enum RoadWorks_TypeAndConfidence_Type : int;
extern const uint32_t RoadWorks_TypeAndConfidence_Type_internal_data_[];
enum TrafficCondition_TypeAndConfidence_Type : int;
extern const uint32_t TrafficCondition_TypeAndConfidence_Type_internal_data_[];
enum VulnerableRoadUserCondition_TypeAndConfidence_Type : int;
extern const uint32_t VulnerableRoadUserCondition_TypeAndConfidence_Type_internal_data_[];
class DangerousSlowDown;
struct DangerousSlowDownDefaultTypeInternal;
extern DangerousSlowDownDefaultTypeInternal _DangerousSlowDown_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DangerousSlowDown_class_data_;
class ECallStatus;
struct ECallStatusDefaultTypeInternal;
extern ECallStatusDefaultTypeInternal _ECallStatus_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ECallStatus_class_data_;
class Hazard;
struct HazardDefaultTypeInternal;
extern HazardDefaultTypeInternal _Hazard_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Hazard_class_data_;
class Hazard_TypeAndConfidence;
struct Hazard_TypeAndConfidenceDefaultTypeInternal;
extern Hazard_TypeAndConfidenceDefaultTypeInternal _Hazard_TypeAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Hazard_TypeAndConfidence_class_data_;
class RoadFriction;
struct RoadFrictionDefaultTypeInternal;
extern RoadFrictionDefaultTypeInternal _RoadFriction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadFriction_class_data_;
class RoadObstructionCondition;
struct RoadObstructionConditionDefaultTypeInternal;
extern RoadObstructionConditionDefaultTypeInternal _RoadObstructionCondition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadObstructionCondition_class_data_;
class RoadObstructionCondition_TypeAndConfidence;
struct RoadObstructionCondition_TypeAndConfidenceDefaultTypeInternal;
extern RoadObstructionCondition_TypeAndConfidenceDefaultTypeInternal _RoadObstructionCondition_TypeAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadObstructionCondition_TypeAndConfidence_class_data_;
class RoadSurfaceCondition;
struct RoadSurfaceConditionDefaultTypeInternal;
extern RoadSurfaceConditionDefaultTypeInternal _RoadSurfaceCondition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadSurfaceCondition_class_data_;
class RoadSurfaceCondition_TypeAndConfidence;
struct RoadSurfaceCondition_TypeAndConfidenceDefaultTypeInternal;
extern RoadSurfaceCondition_TypeAndConfidenceDefaultTypeInternal _RoadSurfaceCondition_TypeAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadSurfaceCondition_TypeAndConfidence_class_data_;
class RoadWeatherCondition;
struct RoadWeatherConditionDefaultTypeInternal;
extern RoadWeatherConditionDefaultTypeInternal _RoadWeatherCondition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadWeatherCondition_class_data_;
class RoadWeatherCondition_TypeAndConfidence;
struct RoadWeatherCondition_TypeAndConfidenceDefaultTypeInternal;
extern RoadWeatherCondition_TypeAndConfidenceDefaultTypeInternal _RoadWeatherCondition_TypeAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadWeatherCondition_TypeAndConfidence_class_data_;
class RoadWorks;
struct RoadWorksDefaultTypeInternal;
extern RoadWorksDefaultTypeInternal _RoadWorks_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadWorks_class_data_;
class RoadWorks_TypeAndConfidence;
struct RoadWorks_TypeAndConfidenceDefaultTypeInternal;
extern RoadWorks_TypeAndConfidenceDefaultTypeInternal _RoadWorks_TypeAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoadWorks_TypeAndConfidence_class_data_;
class TrafficCondition;
struct TrafficConditionDefaultTypeInternal;
extern TrafficConditionDefaultTypeInternal _TrafficCondition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TrafficCondition_class_data_;
class TrafficCondition_TypeAndConfidence;
struct TrafficCondition_TypeAndConfidenceDefaultTypeInternal;
extern TrafficCondition_TypeAndConfidenceDefaultTypeInternal _TrafficCondition_TypeAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TrafficCondition_TypeAndConfidence_class_data_;
class TrafficEventsCategory;
struct TrafficEventsCategoryDefaultTypeInternal;
extern TrafficEventsCategoryDefaultTypeInternal _TrafficEventsCategory_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TrafficEventsCategory_class_data_;
class VulnerableRoadUserCondition;
struct VulnerableRoadUserConditionDefaultTypeInternal;
extern VulnerableRoadUserConditionDefaultTypeInternal _VulnerableRoadUserCondition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VulnerableRoadUserCondition_class_data_;
class VulnerableRoadUserCondition_TypeAndConfidence;
struct VulnerableRoadUserCondition_TypeAndConfidenceDefaultTypeInternal;
extern VulnerableRoadUserCondition_TypeAndConfidenceDefaultTypeInternal _VulnerableRoadUserCondition_TypeAndConfidence_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VulnerableRoadUserCondition_TypeAndConfidence_class_data_;
}  // namespace trafficevents
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::trafficevents::Hazard_Direction_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::trafficevents::Hazard_Direction>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type>;
template <>
internal::EnumTraitsT<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type_internal_data_>
    internal::EnumTraitsImpl::value<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type>;
}  // namespace protobuf
}  // namespace google

namespace sensoris {
namespace protobuf {
namespace categories {
namespace trafficevents {
enum Hazard_TypeAndConfidence_Type : int {
  Hazard_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  Hazard_TypeAndConfidence_Type_OBSTRUCTION = 1,
  Hazard_TypeAndConfidence_Type_ACCIDENT = 2,
  Hazard_TypeAndConfidence_Type_BROKEN_DOWN_VEHICLE = 3,
  Hazard_TypeAndConfidence_Type_SLOW_VEHICLE = 4,
  Hazard_TypeAndConfidence_Type_WRONG_WAY_VEHICLE = 5,
  Hazard_TypeAndConfidence_Type_ROADWORKS = 6,
  Hazard_TypeAndConfidence_Type_SLIPPERY_ROAD = 7,
  Hazard_TypeAndConfidence_Type_PEOPLE_THROWING_OBJECTS = 8,
  Hazard_TypeAndConfidence_Type_VEHICLE_ON_FIRE = 9,
  Hazard_TypeAndConfidence_Type_STATIONARY_VEHICLE = 10,
  Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_LOW_VISIBILITY = 11,
  Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_PRECIPITATION = 12,
  Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_WIND = 13,
  Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_ROAD_SURFACE = 14,
  Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_VULNERABLE_ROAD_USER = 15,
  Hazard_TypeAndConfidence_Type_Hazard_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Hazard_TypeAndConfidence_Type_Hazard_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Hazard_TypeAndConfidence_Type_internal_data_[];
inline constexpr Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence_Type_Type_MIN =
    static_cast<Hazard_TypeAndConfidence_Type>(0);
inline constexpr Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence_Type_Type_MAX =
    static_cast<Hazard_TypeAndConfidence_Type>(15);
inline bool Hazard_TypeAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 15;
}
inline constexpr int Hazard_TypeAndConfidence_Type_Type_ARRAYSIZE = 15 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Hazard_TypeAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& Hazard_TypeAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, Hazard_TypeAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Hazard_TypeAndConfidence_Type_Name(static_cast<Hazard_TypeAndConfidence_Type>(value));
}
template <>
inline const ::std::string& Hazard_TypeAndConfidence_Type_Name(Hazard_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Hazard_TypeAndConfidence_Type_descriptor, 0, 15>(
      static_cast<int>(value));
}
inline bool Hazard_TypeAndConfidence_Type_Parse(
    ::absl::string_view name, Hazard_TypeAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Hazard_TypeAndConfidence_Type>(Hazard_TypeAndConfidence_Type_descriptor(), name,
                                           value);
}
enum Hazard_Direction : int {
  Hazard_Direction_UNKNOWN_DIRECTION = 0,
  Hazard_Direction_EGO_DIRECTION = 1,
  Hazard_Direction_OPPOSITE_DIRECTION = 2,
  Hazard_Direction_BOTH = 3,
  Hazard_Direction_Hazard_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Hazard_Direction_Hazard_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Hazard_Direction_internal_data_[];
inline constexpr Hazard_Direction Hazard_Direction_Direction_MIN =
    static_cast<Hazard_Direction>(0);
inline constexpr Hazard_Direction Hazard_Direction_Direction_MAX =
    static_cast<Hazard_Direction>(3);
inline bool Hazard_Direction_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int Hazard_Direction_Direction_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Hazard_Direction_descriptor();
template <typename T>
const ::std::string& Hazard_Direction_Name(T value) {
  static_assert(::std::is_same<T, Hazard_Direction>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Direction_Name().");
  return Hazard_Direction_Name(static_cast<Hazard_Direction>(value));
}
template <>
inline const ::std::string& Hazard_Direction_Name(Hazard_Direction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Hazard_Direction_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool Hazard_Direction_Parse(
    ::absl::string_view name, Hazard_Direction* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Hazard_Direction>(Hazard_Direction_descriptor(), name,
                                           value);
}
enum TrafficCondition_TypeAndConfidence_Type : int {
  TrafficCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficCondition_TypeAndConfidence_Type_FREE_FLOW = 1,
  TrafficCondition_TypeAndConfidence_Type_HEAVY = 2,
  TrafficCondition_TypeAndConfidence_Type_SLOW = 3,
  TrafficCondition_TypeAndConfidence_Type_QUEUING = 4,
  TrafficCondition_TypeAndConfidence_Type_STATIONARY = 5,
  TrafficCondition_TypeAndConfidence_Type_TrafficCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TrafficCondition_TypeAndConfidence_Type_TrafficCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TrafficCondition_TypeAndConfidence_Type_internal_data_[];
inline constexpr TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence_Type_Type_MIN =
    static_cast<TrafficCondition_TypeAndConfidence_Type>(0);
inline constexpr TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence_Type_Type_MAX =
    static_cast<TrafficCondition_TypeAndConfidence_Type>(5);
inline bool TrafficCondition_TypeAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int TrafficCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TrafficCondition_TypeAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& TrafficCondition_TypeAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, TrafficCondition_TypeAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TrafficCondition_TypeAndConfidence_Type_Name(static_cast<TrafficCondition_TypeAndConfidence_Type>(value));
}
template <>
inline const ::std::string& TrafficCondition_TypeAndConfidence_Type_Name(TrafficCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficCondition_TypeAndConfidence_Type_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool TrafficCondition_TypeAndConfidence_Type_Parse(
    ::absl::string_view name, TrafficCondition_TypeAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficCondition_TypeAndConfidence_Type>(TrafficCondition_TypeAndConfidence_Type_descriptor(), name,
                                           value);
}
enum RoadWorks_TypeAndConfidence_Type : int {
  RoadWorks_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadWorks_TypeAndConfidence_Type_START = 1,
  RoadWorks_TypeAndConfidence_Type_END = 2,
  RoadWorks_TypeAndConfidence_Type_RoadWorks_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RoadWorks_TypeAndConfidence_Type_RoadWorks_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RoadWorks_TypeAndConfidence_Type_internal_data_[];
inline constexpr RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence_Type_Type_MIN =
    static_cast<RoadWorks_TypeAndConfidence_Type>(0);
inline constexpr RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence_Type_Type_MAX =
    static_cast<RoadWorks_TypeAndConfidence_Type>(2);
inline bool RoadWorks_TypeAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int RoadWorks_TypeAndConfidence_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RoadWorks_TypeAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& RoadWorks_TypeAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, RoadWorks_TypeAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadWorks_TypeAndConfidence_Type_Name(static_cast<RoadWorks_TypeAndConfidence_Type>(value));
}
template <>
inline const ::std::string& RoadWorks_TypeAndConfidence_Type_Name(RoadWorks_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadWorks_TypeAndConfidence_Type_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool RoadWorks_TypeAndConfidence_Type_Parse(
    ::absl::string_view name, RoadWorks_TypeAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadWorks_TypeAndConfidence_Type>(RoadWorks_TypeAndConfidence_Type_descriptor(), name,
                                           value);
}
enum RoadWeatherCondition_TypeAndConfidence_Type : int {
  RoadWeatherCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadWeatherCondition_TypeAndConfidence_Type_SNOW = 1,
  RoadWeatherCondition_TypeAndConfidence_Type_ICE = 2,
  RoadWeatherCondition_TypeAndConfidence_Type_FREEZING_RAIN = 3,
  RoadWeatherCondition_TypeAndConfidence_Type_FROST = 4,
  RoadWeatherCondition_TypeAndConfidence_Type_HYDROPLANING = 5,
  RoadWeatherCondition_TypeAndConfidence_Type_FLOODING = 6,
  RoadWeatherCondition_TypeAndConfidence_Type_WATER = 7,
  RoadWeatherCondition_TypeAndConfidence_Type_RoadWeatherCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RoadWeatherCondition_TypeAndConfidence_Type_RoadWeatherCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RoadWeatherCondition_TypeAndConfidence_Type_internal_data_[];
inline constexpr RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence_Type_Type_MIN =
    static_cast<RoadWeatherCondition_TypeAndConfidence_Type>(0);
inline constexpr RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence_Type_Type_MAX =
    static_cast<RoadWeatherCondition_TypeAndConfidence_Type>(7);
inline bool RoadWeatherCondition_TypeAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int RoadWeatherCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RoadWeatherCondition_TypeAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& RoadWeatherCondition_TypeAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, RoadWeatherCondition_TypeAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadWeatherCondition_TypeAndConfidence_Type_Name(static_cast<RoadWeatherCondition_TypeAndConfidence_Type>(value));
}
template <>
inline const ::std::string& RoadWeatherCondition_TypeAndConfidence_Type_Name(RoadWeatherCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadWeatherCondition_TypeAndConfidence_Type_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool RoadWeatherCondition_TypeAndConfidence_Type_Parse(
    ::absl::string_view name, RoadWeatherCondition_TypeAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadWeatherCondition_TypeAndConfidence_Type>(RoadWeatherCondition_TypeAndConfidence_Type_descriptor(), name,
                                           value);
}
enum RoadSurfaceCondition_TypeAndConfidence_Type : int {
  RoadSurfaceCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadSurfaceCondition_TypeAndConfidence_Type_MUD = 1,
  RoadSurfaceCondition_TypeAndConfidence_Type_CHIPPINGS = 2,
  RoadSurfaceCondition_TypeAndConfidence_Type_OIL = 3,
  RoadSurfaceCondition_TypeAndConfidence_Type_FUEL = 4,
  RoadSurfaceCondition_TypeAndConfidence_Type_RoadSurfaceCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RoadSurfaceCondition_TypeAndConfidence_Type_RoadSurfaceCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RoadSurfaceCondition_TypeAndConfidence_Type_internal_data_[];
inline constexpr RoadSurfaceCondition_TypeAndConfidence_Type RoadSurfaceCondition_TypeAndConfidence_Type_Type_MIN =
    static_cast<RoadSurfaceCondition_TypeAndConfidence_Type>(0);
inline constexpr RoadSurfaceCondition_TypeAndConfidence_Type RoadSurfaceCondition_TypeAndConfidence_Type_Type_MAX =
    static_cast<RoadSurfaceCondition_TypeAndConfidence_Type>(4);
inline bool RoadSurfaceCondition_TypeAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int RoadSurfaceCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RoadSurfaceCondition_TypeAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& RoadSurfaceCondition_TypeAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, RoadSurfaceCondition_TypeAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadSurfaceCondition_TypeAndConfidence_Type_Name(static_cast<RoadSurfaceCondition_TypeAndConfidence_Type>(value));
}
template <>
inline const ::std::string& RoadSurfaceCondition_TypeAndConfidence_Type_Name(RoadSurfaceCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadSurfaceCondition_TypeAndConfidence_Type_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool RoadSurfaceCondition_TypeAndConfidence_Type_Parse(
    ::absl::string_view name, RoadSurfaceCondition_TypeAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadSurfaceCondition_TypeAndConfidence_Type>(RoadSurfaceCondition_TypeAndConfidence_Type_descriptor(), name,
                                           value);
}
enum RoadObstructionCondition_TypeAndConfidence_Type : int {
  RoadObstructionCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadObstructionCondition_TypeAndConfidence_Type_TREE = 1,
  RoadObstructionCondition_TypeAndConfidence_Type_AVALANCHE = 2,
  RoadObstructionCondition_TypeAndConfidence_Type_ROCKFALLS = 3,
  RoadObstructionCondition_TypeAndConfidence_Type_SHED_LOAD = 4,
  RoadObstructionCondition_TypeAndConfidence_Type_LAND_SLIP = 5,
  RoadObstructionCondition_TypeAndConfidence_Type_ANIMAL = 6,
  RoadObstructionCondition_TypeAndConfidence_Type_ANIMAL_LARGE = 7,
  RoadObstructionCondition_TypeAndConfidence_Type_ANIMAL_HERD = 8,
  RoadObstructionCondition_TypeAndConfidence_Type_RoadObstructionCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RoadObstructionCondition_TypeAndConfidence_Type_RoadObstructionCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RoadObstructionCondition_TypeAndConfidence_Type_internal_data_[];
inline constexpr RoadObstructionCondition_TypeAndConfidence_Type RoadObstructionCondition_TypeAndConfidence_Type_Type_MIN =
    static_cast<RoadObstructionCondition_TypeAndConfidence_Type>(0);
inline constexpr RoadObstructionCondition_TypeAndConfidence_Type RoadObstructionCondition_TypeAndConfidence_Type_Type_MAX =
    static_cast<RoadObstructionCondition_TypeAndConfidence_Type>(8);
inline bool RoadObstructionCondition_TypeAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 8;
}
inline constexpr int RoadObstructionCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RoadObstructionCondition_TypeAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& RoadObstructionCondition_TypeAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, RoadObstructionCondition_TypeAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadObstructionCondition_TypeAndConfidence_Type_Name(static_cast<RoadObstructionCondition_TypeAndConfidence_Type>(value));
}
template <>
inline const ::std::string& RoadObstructionCondition_TypeAndConfidence_Type_Name(RoadObstructionCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadObstructionCondition_TypeAndConfidence_Type_descriptor, 0, 8>(
      static_cast<int>(value));
}
inline bool RoadObstructionCondition_TypeAndConfidence_Type_Parse(
    ::absl::string_view name, RoadObstructionCondition_TypeAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadObstructionCondition_TypeAndConfidence_Type>(RoadObstructionCondition_TypeAndConfidence_Type_descriptor(), name,
                                           value);
}
enum VulnerableRoadUserCondition_TypeAndConfidence_Type : int {
  VulnerableRoadUserCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  VulnerableRoadUserCondition_TypeAndConfidence_Type_PEOPLE = 1,
  VulnerableRoadUserCondition_TypeAndConfidence_Type_CHILDREN = 2,
  VulnerableRoadUserCondition_TypeAndConfidence_Type_CYCLIST = 3,
  VulnerableRoadUserCondition_TypeAndConfidence_Type_VulnerableRoadUserCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  VulnerableRoadUserCondition_TypeAndConfidence_Type_VulnerableRoadUserCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t VulnerableRoadUserCondition_TypeAndConfidence_Type_internal_data_[];
inline constexpr VulnerableRoadUserCondition_TypeAndConfidence_Type VulnerableRoadUserCondition_TypeAndConfidence_Type_Type_MIN =
    static_cast<VulnerableRoadUserCondition_TypeAndConfidence_Type>(0);
inline constexpr VulnerableRoadUserCondition_TypeAndConfidence_Type VulnerableRoadUserCondition_TypeAndConfidence_Type_Type_MAX =
    static_cast<VulnerableRoadUserCondition_TypeAndConfidence_Type>(3);
inline bool VulnerableRoadUserCondition_TypeAndConfidence_Type_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int VulnerableRoadUserCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL VulnerableRoadUserCondition_TypeAndConfidence_Type_descriptor();
template <typename T>
const ::std::string& VulnerableRoadUserCondition_TypeAndConfidence_Type_Name(T value) {
  static_assert(::std::is_same<T, VulnerableRoadUserCondition_TypeAndConfidence_Type>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return VulnerableRoadUserCondition_TypeAndConfidence_Type_Name(static_cast<VulnerableRoadUserCondition_TypeAndConfidence_Type>(value));
}
template <>
inline const ::std::string& VulnerableRoadUserCondition_TypeAndConfidence_Type_Name(VulnerableRoadUserCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VulnerableRoadUserCondition_TypeAndConfidence_Type_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool VulnerableRoadUserCondition_TypeAndConfidence_Type_Parse(
    ::absl::string_view name, VulnerableRoadUserCondition_TypeAndConfidence_Type* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<VulnerableRoadUserCondition_TypeAndConfidence_Type>(VulnerableRoadUserCondition_TypeAndConfidence_Type_descriptor(), name,
                                           value);
}
enum ECallStatus_ActivationType : int {
  ECallStatus_ActivationType_UNKNOWN_ACTIVATION_TYPE = 0,
  ECallStatus_ActivationType_NONE = 1,
  ECallStatus_ActivationType_MANUAL = 2,
  ECallStatus_ActivationType_AUTOMATIC = 3,
  ECallStatus_ActivationType_ECallStatus_ActivationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ECallStatus_ActivationType_ECallStatus_ActivationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ECallStatus_ActivationType_internal_data_[];
inline constexpr ECallStatus_ActivationType ECallStatus_ActivationType_ActivationType_MIN =
    static_cast<ECallStatus_ActivationType>(0);
inline constexpr ECallStatus_ActivationType ECallStatus_ActivationType_ActivationType_MAX =
    static_cast<ECallStatus_ActivationType>(3);
inline bool ECallStatus_ActivationType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ECallStatus_ActivationType_ActivationType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ECallStatus_ActivationType_descriptor();
template <typename T>
const ::std::string& ECallStatus_ActivationType_Name(T value) {
  static_assert(::std::is_same<T, ECallStatus_ActivationType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ActivationType_Name().");
  return ECallStatus_ActivationType_Name(static_cast<ECallStatus_ActivationType>(value));
}
template <>
inline const ::std::string& ECallStatus_ActivationType_Name(ECallStatus_ActivationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ECallStatus_ActivationType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ECallStatus_ActivationType_Parse(
    ::absl::string_view name, ECallStatus_ActivationType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECallStatus_ActivationType>(ECallStatus_ActivationType_descriptor(), name,
                                           value);
}
enum ECallStatus_Availability : int {
  ECallStatus_Availability_UNKNOWN_AVAILABILITY = 0,
  ECallStatus_Availability_AVAILABLE = 1,
  ECallStatus_Availability_UNAVAILABLE = 2,
  ECallStatus_Availability_ECallStatus_Availability_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ECallStatus_Availability_ECallStatus_Availability_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ECallStatus_Availability_internal_data_[];
inline constexpr ECallStatus_Availability ECallStatus_Availability_Availability_MIN =
    static_cast<ECallStatus_Availability>(0);
inline constexpr ECallStatus_Availability ECallStatus_Availability_Availability_MAX =
    static_cast<ECallStatus_Availability>(2);
inline bool ECallStatus_Availability_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ECallStatus_Availability_Availability_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ECallStatus_Availability_descriptor();
template <typename T>
const ::std::string& ECallStatus_Availability_Name(T value) {
  static_assert(::std::is_same<T, ECallStatus_Availability>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Availability_Name().");
  return ECallStatus_Availability_Name(static_cast<ECallStatus_Availability>(value));
}
template <>
inline const ::std::string& ECallStatus_Availability_Name(ECallStatus_Availability value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ECallStatus_Availability_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool ECallStatus_Availability_Parse(
    ::absl::string_view name, ECallStatus_Availability* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECallStatus_Availability>(ECallStatus_Availability_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class VulnerableRoadUserCondition_TypeAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence) */ {
 public:
  inline VulnerableRoadUserCondition_TypeAndConfidence() : VulnerableRoadUserCondition_TypeAndConfidence(nullptr) {}
  ~VulnerableRoadUserCondition_TypeAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VulnerableRoadUserCondition_TypeAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VulnerableRoadUserCondition_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline VulnerableRoadUserCondition_TypeAndConfidence(const VulnerableRoadUserCondition_TypeAndConfidence& from) : VulnerableRoadUserCondition_TypeAndConfidence(nullptr, from) {}
  inline VulnerableRoadUserCondition_TypeAndConfidence(VulnerableRoadUserCondition_TypeAndConfidence&& from) noexcept
      : VulnerableRoadUserCondition_TypeAndConfidence(nullptr, ::std::move(from)) {}
  inline VulnerableRoadUserCondition_TypeAndConfidence& operator=(const VulnerableRoadUserCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline VulnerableRoadUserCondition_TypeAndConfidence& operator=(VulnerableRoadUserCondition_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VulnerableRoadUserCondition_TypeAndConfidence& default_instance() {
    return *reinterpret_cast<const VulnerableRoadUserCondition_TypeAndConfidence*>(
        &_VulnerableRoadUserCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(VulnerableRoadUserCondition_TypeAndConfidence& a, VulnerableRoadUserCondition_TypeAndConfidence& b) { a.Swap(&b); }
  inline void Swap(VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VulnerableRoadUserCondition_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VulnerableRoadUserCondition_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VulnerableRoadUserCondition_TypeAndConfidence& from) { VulnerableRoadUserCondition_TypeAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence"; }

 protected:
  explicit VulnerableRoadUserCondition_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VulnerableRoadUserCondition_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VulnerableRoadUserCondition_TypeAndConfidence& from);
  VulnerableRoadUserCondition_TypeAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VulnerableRoadUserCondition_TypeAndConfidence&& from) noexcept
      : VulnerableRoadUserCondition_TypeAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = VulnerableRoadUserCondition_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = VulnerableRoadUserCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type PEOPLE = VulnerableRoadUserCondition_TypeAndConfidence_Type_PEOPLE;
  static constexpr Type CHILDREN = VulnerableRoadUserCondition_TypeAndConfidence_Type_CHILDREN;
  static constexpr Type CYCLIST = VulnerableRoadUserCondition_TypeAndConfidence_Type_CYCLIST;
  static inline bool Type_IsValid(int value) {
    return VulnerableRoadUserCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = VulnerableRoadUserCondition_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = VulnerableRoadUserCondition_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = VulnerableRoadUserCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return VulnerableRoadUserCondition_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return VulnerableRoadUserCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return VulnerableRoadUserCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VulnerableRoadUserCondition_TypeAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VulnerableRoadUserCondition_TypeAndConfidence_class_data_;
// -------------------------------------------------------------------

class TrafficCondition_TypeAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence) */ {
 public:
  inline TrafficCondition_TypeAndConfidence() : TrafficCondition_TypeAndConfidence(nullptr) {}
  ~TrafficCondition_TypeAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrafficCondition_TypeAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrafficCondition_TypeAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficCondition_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline TrafficCondition_TypeAndConfidence(const TrafficCondition_TypeAndConfidence& from) : TrafficCondition_TypeAndConfidence(nullptr, from) {}
  inline TrafficCondition_TypeAndConfidence(TrafficCondition_TypeAndConfidence&& from) noexcept
      : TrafficCondition_TypeAndConfidence(nullptr, ::std::move(from)) {}
  inline TrafficCondition_TypeAndConfidence& operator=(const TrafficCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficCondition_TypeAndConfidence& operator=(TrafficCondition_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficCondition_TypeAndConfidence& default_instance() {
    return *reinterpret_cast<const TrafficCondition_TypeAndConfidence*>(
        &_TrafficCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(TrafficCondition_TypeAndConfidence& a, TrafficCondition_TypeAndConfidence& b) { a.Swap(&b); }
  inline void Swap(TrafficCondition_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficCondition_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficCondition_TypeAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrafficCondition_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficCondition_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrafficCondition_TypeAndConfidence& from) { TrafficCondition_TypeAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrafficCondition_TypeAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence"; }

 protected:
  explicit TrafficCondition_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TrafficCondition_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TrafficCondition_TypeAndConfidence& from);
  TrafficCondition_TypeAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TrafficCondition_TypeAndConfidence&& from) noexcept
      : TrafficCondition_TypeAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = TrafficCondition_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = TrafficCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type FREE_FLOW = TrafficCondition_TypeAndConfidence_Type_FREE_FLOW;
  static constexpr Type HEAVY = TrafficCondition_TypeAndConfidence_Type_HEAVY;
  static constexpr Type SLOW = TrafficCondition_TypeAndConfidence_Type_SLOW;
  static constexpr Type QUEUING = TrafficCondition_TypeAndConfidence_Type_QUEUING;
  static constexpr Type STATIONARY = TrafficCondition_TypeAndConfidence_Type_STATIONARY;
  static inline bool Type_IsValid(int value) {
    return TrafficCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TrafficCondition_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = TrafficCondition_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TrafficCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return TrafficCondition_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return TrafficCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return TrafficCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TrafficCondition_TypeAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TrafficCondition_TypeAndConfidence_class_data_;
// -------------------------------------------------------------------

class RoadWorks_TypeAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence) */ {
 public:
  inline RoadWorks_TypeAndConfidence() : RoadWorks_TypeAndConfidence(nullptr) {}
  ~RoadWorks_TypeAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadWorks_TypeAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadWorks_TypeAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadWorks_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadWorks_TypeAndConfidence(const RoadWorks_TypeAndConfidence& from) : RoadWorks_TypeAndConfidence(nullptr, from) {}
  inline RoadWorks_TypeAndConfidence(RoadWorks_TypeAndConfidence&& from) noexcept
      : RoadWorks_TypeAndConfidence(nullptr, ::std::move(from)) {}
  inline RoadWorks_TypeAndConfidence& operator=(const RoadWorks_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadWorks_TypeAndConfidence& operator=(RoadWorks_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadWorks_TypeAndConfidence& default_instance() {
    return *reinterpret_cast<const RoadWorks_TypeAndConfidence*>(
        &_RoadWorks_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(RoadWorks_TypeAndConfidence& a, RoadWorks_TypeAndConfidence& b) { a.Swap(&b); }
  inline void Swap(RoadWorks_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadWorks_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadWorks_TypeAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadWorks_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadWorks_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadWorks_TypeAndConfidence& from) { RoadWorks_TypeAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadWorks_TypeAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence"; }

 protected:
  explicit RoadWorks_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadWorks_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadWorks_TypeAndConfidence& from);
  RoadWorks_TypeAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadWorks_TypeAndConfidence&& from) noexcept
      : RoadWorks_TypeAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = RoadWorks_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadWorks_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type START = RoadWorks_TypeAndConfidence_Type_START;
  static constexpr Type END = RoadWorks_TypeAndConfidence_Type_END;
  static inline bool Type_IsValid(int value) {
    return RoadWorks_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadWorks_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadWorks_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadWorks_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return RoadWorks_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return RoadWorks_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return RoadWorks_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadWorks_TypeAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadWorks_TypeAndConfidence_class_data_;
// -------------------------------------------------------------------

class RoadWeatherCondition_TypeAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence) */ {
 public:
  inline RoadWeatherCondition_TypeAndConfidence() : RoadWeatherCondition_TypeAndConfidence(nullptr) {}
  ~RoadWeatherCondition_TypeAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadWeatherCondition_TypeAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadWeatherCondition_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadWeatherCondition_TypeAndConfidence(const RoadWeatherCondition_TypeAndConfidence& from) : RoadWeatherCondition_TypeAndConfidence(nullptr, from) {}
  inline RoadWeatherCondition_TypeAndConfidence(RoadWeatherCondition_TypeAndConfidence&& from) noexcept
      : RoadWeatherCondition_TypeAndConfidence(nullptr, ::std::move(from)) {}
  inline RoadWeatherCondition_TypeAndConfidence& operator=(const RoadWeatherCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadWeatherCondition_TypeAndConfidence& operator=(RoadWeatherCondition_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadWeatherCondition_TypeAndConfidence& default_instance() {
    return *reinterpret_cast<const RoadWeatherCondition_TypeAndConfidence*>(
        &_RoadWeatherCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(RoadWeatherCondition_TypeAndConfidence& a, RoadWeatherCondition_TypeAndConfidence& b) { a.Swap(&b); }
  inline void Swap(RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadWeatherCondition_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadWeatherCondition_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadWeatherCondition_TypeAndConfidence& from) { RoadWeatherCondition_TypeAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence"; }

 protected:
  explicit RoadWeatherCondition_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadWeatherCondition_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadWeatherCondition_TypeAndConfidence& from);
  RoadWeatherCondition_TypeAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadWeatherCondition_TypeAndConfidence&& from) noexcept
      : RoadWeatherCondition_TypeAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = RoadWeatherCondition_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadWeatherCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type SNOW = RoadWeatherCondition_TypeAndConfidence_Type_SNOW;
  static constexpr Type ICE = RoadWeatherCondition_TypeAndConfidence_Type_ICE;
  static constexpr Type FREEZING_RAIN = RoadWeatherCondition_TypeAndConfidence_Type_FREEZING_RAIN;
  static constexpr Type FROST = RoadWeatherCondition_TypeAndConfidence_Type_FROST;
  static constexpr Type HYDROPLANING = RoadWeatherCondition_TypeAndConfidence_Type_HYDROPLANING;
  static constexpr Type FLOODING = RoadWeatherCondition_TypeAndConfidence_Type_FLOODING;
  static constexpr Type WATER = RoadWeatherCondition_TypeAndConfidence_Type_WATER;
  static inline bool Type_IsValid(int value) {
    return RoadWeatherCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadWeatherCondition_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadWeatherCondition_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadWeatherCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return RoadWeatherCondition_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return RoadWeatherCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return RoadWeatherCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadWeatherCondition_TypeAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadWeatherCondition_TypeAndConfidence_class_data_;
// -------------------------------------------------------------------

class RoadSurfaceCondition_TypeAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence) */ {
 public:
  inline RoadSurfaceCondition_TypeAndConfidence() : RoadSurfaceCondition_TypeAndConfidence(nullptr) {}
  ~RoadSurfaceCondition_TypeAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadSurfaceCondition_TypeAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadSurfaceCondition_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadSurfaceCondition_TypeAndConfidence(const RoadSurfaceCondition_TypeAndConfidence& from) : RoadSurfaceCondition_TypeAndConfidence(nullptr, from) {}
  inline RoadSurfaceCondition_TypeAndConfidence(RoadSurfaceCondition_TypeAndConfidence&& from) noexcept
      : RoadSurfaceCondition_TypeAndConfidence(nullptr, ::std::move(from)) {}
  inline RoadSurfaceCondition_TypeAndConfidence& operator=(const RoadSurfaceCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadSurfaceCondition_TypeAndConfidence& operator=(RoadSurfaceCondition_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadSurfaceCondition_TypeAndConfidence& default_instance() {
    return *reinterpret_cast<const RoadSurfaceCondition_TypeAndConfidence*>(
        &_RoadSurfaceCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(RoadSurfaceCondition_TypeAndConfidence& a, RoadSurfaceCondition_TypeAndConfidence& b) { a.Swap(&b); }
  inline void Swap(RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadSurfaceCondition_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadSurfaceCondition_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadSurfaceCondition_TypeAndConfidence& from) { RoadSurfaceCondition_TypeAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence"; }

 protected:
  explicit RoadSurfaceCondition_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadSurfaceCondition_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadSurfaceCondition_TypeAndConfidence& from);
  RoadSurfaceCondition_TypeAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadSurfaceCondition_TypeAndConfidence&& from) noexcept
      : RoadSurfaceCondition_TypeAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = RoadSurfaceCondition_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadSurfaceCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type MUD = RoadSurfaceCondition_TypeAndConfidence_Type_MUD;
  static constexpr Type CHIPPINGS = RoadSurfaceCondition_TypeAndConfidence_Type_CHIPPINGS;
  static constexpr Type OIL = RoadSurfaceCondition_TypeAndConfidence_Type_OIL;
  static constexpr Type FUEL = RoadSurfaceCondition_TypeAndConfidence_Type_FUEL;
  static inline bool Type_IsValid(int value) {
    return RoadSurfaceCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadSurfaceCondition_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadSurfaceCondition_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadSurfaceCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return RoadSurfaceCondition_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return RoadSurfaceCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return RoadSurfaceCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadSurfaceCondition_TypeAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadSurfaceCondition_TypeAndConfidence_class_data_;
// -------------------------------------------------------------------

class RoadObstructionCondition_TypeAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence) */ {
 public:
  inline RoadObstructionCondition_TypeAndConfidence() : RoadObstructionCondition_TypeAndConfidence(nullptr) {}
  ~RoadObstructionCondition_TypeAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadObstructionCondition_TypeAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadObstructionCondition_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadObstructionCondition_TypeAndConfidence(const RoadObstructionCondition_TypeAndConfidence& from) : RoadObstructionCondition_TypeAndConfidence(nullptr, from) {}
  inline RoadObstructionCondition_TypeAndConfidence(RoadObstructionCondition_TypeAndConfidence&& from) noexcept
      : RoadObstructionCondition_TypeAndConfidence(nullptr, ::std::move(from)) {}
  inline RoadObstructionCondition_TypeAndConfidence& operator=(const RoadObstructionCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadObstructionCondition_TypeAndConfidence& operator=(RoadObstructionCondition_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadObstructionCondition_TypeAndConfidence& default_instance() {
    return *reinterpret_cast<const RoadObstructionCondition_TypeAndConfidence*>(
        &_RoadObstructionCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(RoadObstructionCondition_TypeAndConfidence& a, RoadObstructionCondition_TypeAndConfidence& b) { a.Swap(&b); }
  inline void Swap(RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadObstructionCondition_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadObstructionCondition_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadObstructionCondition_TypeAndConfidence& from) { RoadObstructionCondition_TypeAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence"; }

 protected:
  explicit RoadObstructionCondition_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadObstructionCondition_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadObstructionCondition_TypeAndConfidence& from);
  RoadObstructionCondition_TypeAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadObstructionCondition_TypeAndConfidence&& from) noexcept
      : RoadObstructionCondition_TypeAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = RoadObstructionCondition_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadObstructionCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type TREE = RoadObstructionCondition_TypeAndConfidence_Type_TREE;
  static constexpr Type AVALANCHE = RoadObstructionCondition_TypeAndConfidence_Type_AVALANCHE;
  static constexpr Type ROCKFALLS = RoadObstructionCondition_TypeAndConfidence_Type_ROCKFALLS;
  static constexpr Type SHED_LOAD = RoadObstructionCondition_TypeAndConfidence_Type_SHED_LOAD;
  static constexpr Type LAND_SLIP = RoadObstructionCondition_TypeAndConfidence_Type_LAND_SLIP;
  static constexpr Type ANIMAL = RoadObstructionCondition_TypeAndConfidence_Type_ANIMAL;
  static constexpr Type ANIMAL_LARGE = RoadObstructionCondition_TypeAndConfidence_Type_ANIMAL_LARGE;
  static constexpr Type ANIMAL_HERD = RoadObstructionCondition_TypeAndConfidence_Type_ANIMAL_HERD;
  static inline bool Type_IsValid(int value) {
    return RoadObstructionCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadObstructionCondition_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadObstructionCondition_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadObstructionCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return RoadObstructionCondition_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return RoadObstructionCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return RoadObstructionCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadObstructionCondition_TypeAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadObstructionCondition_TypeAndConfidence_class_data_;
// -------------------------------------------------------------------

class Hazard_TypeAndConfidence final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence) */ {
 public:
  inline Hazard_TypeAndConfidence() : Hazard_TypeAndConfidence(nullptr) {}
  ~Hazard_TypeAndConfidence() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Hazard_TypeAndConfidence* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Hazard_TypeAndConfidence));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Hazard_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline Hazard_TypeAndConfidence(const Hazard_TypeAndConfidence& from) : Hazard_TypeAndConfidence(nullptr, from) {}
  inline Hazard_TypeAndConfidence(Hazard_TypeAndConfidence&& from) noexcept
      : Hazard_TypeAndConfidence(nullptr, ::std::move(from)) {}
  inline Hazard_TypeAndConfidence& operator=(const Hazard_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hazard_TypeAndConfidence& operator=(Hazard_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hazard_TypeAndConfidence& default_instance() {
    return *reinterpret_cast<const Hazard_TypeAndConfidence*>(
        &_Hazard_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Hazard_TypeAndConfidence& a, Hazard_TypeAndConfidence& b) { a.Swap(&b); }
  inline void Swap(Hazard_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hazard_TypeAndConfidence* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hazard_TypeAndConfidence* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Hazard_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Hazard_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Hazard_TypeAndConfidence& from) { Hazard_TypeAndConfidence::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Hazard_TypeAndConfidence* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence"; }

 protected:
  explicit Hazard_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Hazard_TypeAndConfidence(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Hazard_TypeAndConfidence& from);
  Hazard_TypeAndConfidence(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Hazard_TypeAndConfidence&& from) noexcept
      : Hazard_TypeAndConfidence(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = Hazard_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = Hazard_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type OBSTRUCTION = Hazard_TypeAndConfidence_Type_OBSTRUCTION;
  static constexpr Type ACCIDENT = Hazard_TypeAndConfidence_Type_ACCIDENT;
  static constexpr Type BROKEN_DOWN_VEHICLE = Hazard_TypeAndConfidence_Type_BROKEN_DOWN_VEHICLE;
  static constexpr Type SLOW_VEHICLE = Hazard_TypeAndConfidence_Type_SLOW_VEHICLE;
  static constexpr Type WRONG_WAY_VEHICLE = Hazard_TypeAndConfidence_Type_WRONG_WAY_VEHICLE;
  static constexpr Type ROADWORKS = Hazard_TypeAndConfidence_Type_ROADWORKS;
  static constexpr Type SLIPPERY_ROAD = Hazard_TypeAndConfidence_Type_SLIPPERY_ROAD;
  static constexpr Type PEOPLE_THROWING_OBJECTS = Hazard_TypeAndConfidence_Type_PEOPLE_THROWING_OBJECTS;
  static constexpr Type VEHICLE_ON_FIRE = Hazard_TypeAndConfidence_Type_VEHICLE_ON_FIRE;
  static constexpr Type STATIONARY_VEHICLE = Hazard_TypeAndConfidence_Type_STATIONARY_VEHICLE;
  static constexpr Type EXCEPTIONAL_CONDITION_LOW_VISIBILITY = Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_LOW_VISIBILITY;
  static constexpr Type EXCEPTIONAL_CONDITION_PRECIPITATION = Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_PRECIPITATION;
  static constexpr Type EXCEPTIONAL_CONDITION_WIND = Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_WIND;
  static constexpr Type EXCEPTIONAL_CONDITION_ROAD_SURFACE = Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_ROAD_SURFACE;
  static constexpr Type EXCEPTIONAL_CONDITION_VULNERABLE_ROAD_USER = Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_VULNERABLE_ROAD_USER;
  static inline bool Type_IsValid(int value) {
    return Hazard_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Hazard_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = Hazard_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Hazard_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Type_descriptor() {
    return Hazard_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Type_Name(T value) {
    return Hazard_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(
      ::absl::string_view name, Type* PROTOBUF_NONNULL value) {
    return Hazard_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE release_confidence();
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Hazard_TypeAndConfidence& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Hazard_TypeAndConfidence_class_data_;
// -------------------------------------------------------------------

class VulnerableRoadUserCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition) */ {
 public:
  inline VulnerableRoadUserCondition() : VulnerableRoadUserCondition(nullptr) {}
  ~VulnerableRoadUserCondition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VulnerableRoadUserCondition* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VulnerableRoadUserCondition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VulnerableRoadUserCondition(::google::protobuf::internal::ConstantInitialized);

  inline VulnerableRoadUserCondition(const VulnerableRoadUserCondition& from) : VulnerableRoadUserCondition(nullptr, from) {}
  inline VulnerableRoadUserCondition(VulnerableRoadUserCondition&& from) noexcept
      : VulnerableRoadUserCondition(nullptr, ::std::move(from)) {}
  inline VulnerableRoadUserCondition& operator=(const VulnerableRoadUserCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline VulnerableRoadUserCondition& operator=(VulnerableRoadUserCondition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VulnerableRoadUserCondition& default_instance() {
    return *reinterpret_cast<const VulnerableRoadUserCondition*>(
        &_VulnerableRoadUserCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(VulnerableRoadUserCondition& a, VulnerableRoadUserCondition& b) { a.Swap(&b); }
  inline void Swap(VulnerableRoadUserCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VulnerableRoadUserCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VulnerableRoadUserCondition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VulnerableRoadUserCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VulnerableRoadUserCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VulnerableRoadUserCondition& from) { VulnerableRoadUserCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VulnerableRoadUserCondition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition"; }

 protected:
  explicit VulnerableRoadUserCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VulnerableRoadUserCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VulnerableRoadUserCondition& from);
  VulnerableRoadUserCondition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VulnerableRoadUserCondition&& from) noexcept
      : VulnerableRoadUserCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeAndConfidence = VulnerableRoadUserCondition_TypeAndConfidence;

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence& type_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NULLABLE release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NONNULL mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NONNULL _internal_mutable_type_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VulnerableRoadUserCondition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE detection_status_;
    ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NULLABLE type_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VulnerableRoadUserCondition_class_data_;
// -------------------------------------------------------------------

class TrafficCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.TrafficCondition) */ {
 public:
  inline TrafficCondition() : TrafficCondition(nullptr) {}
  ~TrafficCondition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrafficCondition* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrafficCondition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficCondition(::google::protobuf::internal::ConstantInitialized);

  inline TrafficCondition(const TrafficCondition& from) : TrafficCondition(nullptr, from) {}
  inline TrafficCondition(TrafficCondition&& from) noexcept
      : TrafficCondition(nullptr, ::std::move(from)) {}
  inline TrafficCondition& operator=(const TrafficCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficCondition& operator=(TrafficCondition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficCondition& default_instance() {
    return *reinterpret_cast<const TrafficCondition*>(
        &_TrafficCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(TrafficCondition& a, TrafficCondition& b) { a.Swap(&b); }
  inline void Swap(TrafficCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficCondition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrafficCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrafficCondition& from) { TrafficCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrafficCondition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.TrafficCondition"; }

 protected:
  explicit TrafficCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TrafficCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TrafficCondition& from);
  TrafficCondition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TrafficCondition&& from) noexcept
      : TrafficCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeAndConfidence = TrafficCondition_TypeAndConfidence;

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& type_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NULLABLE release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NONNULL mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NONNULL _internal_mutable_type_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.TrafficCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TrafficCondition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE detection_status_;
    ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NULLABLE type_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TrafficCondition_class_data_;
// -------------------------------------------------------------------

class RoadWorks final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWorks) */ {
 public:
  inline RoadWorks() : RoadWorks(nullptr) {}
  ~RoadWorks() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadWorks* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadWorks));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadWorks(::google::protobuf::internal::ConstantInitialized);

  inline RoadWorks(const RoadWorks& from) : RoadWorks(nullptr, from) {}
  inline RoadWorks(RoadWorks&& from) noexcept
      : RoadWorks(nullptr, ::std::move(from)) {}
  inline RoadWorks& operator=(const RoadWorks& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadWorks& operator=(RoadWorks&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadWorks& default_instance() {
    return *reinterpret_cast<const RoadWorks*>(
        &_RoadWorks_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(RoadWorks& a, RoadWorks& b) { a.Swap(&b); }
  inline void Swap(RoadWorks* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadWorks* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadWorks* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadWorks>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadWorks& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadWorks& from) { RoadWorks::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadWorks* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.RoadWorks"; }

 protected:
  explicit RoadWorks(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadWorks(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadWorks& from);
  RoadWorks(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadWorks&& from) noexcept
      : RoadWorks(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeAndConfidence = RoadWorks_TypeAndConfidence;

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
    kLanesClosedAndConfidenceFieldNumber = 5,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& type_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NULLABLE release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NONNULL mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NONNULL _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.types.base.CountAndConfidence lanes_closed_and_confidence = 5;
  bool has_lanes_closed_and_confidence() const;
  void clear_lanes_closed_and_confidence() ;
  const ::sensoris::protobuf::types::base::CountAndConfidence& lanes_closed_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE release_lanes_closed_and_confidence();
  ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NONNULL mutable_lanes_closed_and_confidence();
  void set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_lanes_closed_and_confidence();

  private:
  const ::sensoris::protobuf::types::base::CountAndConfidence& _internal_lanes_closed_and_confidence() const;
  ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NONNULL _internal_mutable_lanes_closed_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWorks)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadWorks& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE detection_status_;
    ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NULLABLE type_and_confidence_;
    ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE lanes_closed_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadWorks_class_data_;
// -------------------------------------------------------------------

class RoadSurfaceCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition) */ {
 public:
  inline RoadSurfaceCondition() : RoadSurfaceCondition(nullptr) {}
  ~RoadSurfaceCondition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadSurfaceCondition* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadSurfaceCondition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadSurfaceCondition(::google::protobuf::internal::ConstantInitialized);

  inline RoadSurfaceCondition(const RoadSurfaceCondition& from) : RoadSurfaceCondition(nullptr, from) {}
  inline RoadSurfaceCondition(RoadSurfaceCondition&& from) noexcept
      : RoadSurfaceCondition(nullptr, ::std::move(from)) {}
  inline RoadSurfaceCondition& operator=(const RoadSurfaceCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadSurfaceCondition& operator=(RoadSurfaceCondition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadSurfaceCondition& default_instance() {
    return *reinterpret_cast<const RoadSurfaceCondition*>(
        &_RoadSurfaceCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(RoadSurfaceCondition& a, RoadSurfaceCondition& b) { a.Swap(&b); }
  inline void Swap(RoadSurfaceCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadSurfaceCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadSurfaceCondition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadSurfaceCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadSurfaceCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadSurfaceCondition& from) { RoadSurfaceCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadSurfaceCondition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition"; }

 protected:
  explicit RoadSurfaceCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadSurfaceCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadSurfaceCondition& from);
  RoadSurfaceCondition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadSurfaceCondition&& from) noexcept
      : RoadSurfaceCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeAndConfidence = RoadSurfaceCondition_TypeAndConfidence;

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence& type_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NULLABLE release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NONNULL mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NONNULL _internal_mutable_type_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadSurfaceCondition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE detection_status_;
    ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NULLABLE type_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadSurfaceCondition_class_data_;
// -------------------------------------------------------------------

class RoadObstructionCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition) */ {
 public:
  inline RoadObstructionCondition() : RoadObstructionCondition(nullptr) {}
  ~RoadObstructionCondition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadObstructionCondition* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadObstructionCondition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadObstructionCondition(::google::protobuf::internal::ConstantInitialized);

  inline RoadObstructionCondition(const RoadObstructionCondition& from) : RoadObstructionCondition(nullptr, from) {}
  inline RoadObstructionCondition(RoadObstructionCondition&& from) noexcept
      : RoadObstructionCondition(nullptr, ::std::move(from)) {}
  inline RoadObstructionCondition& operator=(const RoadObstructionCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadObstructionCondition& operator=(RoadObstructionCondition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadObstructionCondition& default_instance() {
    return *reinterpret_cast<const RoadObstructionCondition*>(
        &_RoadObstructionCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(RoadObstructionCondition& a, RoadObstructionCondition& b) { a.Swap(&b); }
  inline void Swap(RoadObstructionCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadObstructionCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadObstructionCondition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadObstructionCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadObstructionCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadObstructionCondition& from) { RoadObstructionCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadObstructionCondition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.RoadObstructionCondition"; }

 protected:
  explicit RoadObstructionCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadObstructionCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadObstructionCondition& from);
  RoadObstructionCondition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadObstructionCondition&& from) noexcept
      : RoadObstructionCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeAndConfidence = RoadObstructionCondition_TypeAndConfidence;

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence& type_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NULLABLE release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NONNULL mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NONNULL _internal_mutable_type_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadObstructionCondition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE detection_status_;
    ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NULLABLE type_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadObstructionCondition_class_data_;
// -------------------------------------------------------------------

class Hazard final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.Hazard) */ {
 public:
  inline Hazard() : Hazard(nullptr) {}
  ~Hazard() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Hazard* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Hazard));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Hazard(::google::protobuf::internal::ConstantInitialized);

  inline Hazard(const Hazard& from) : Hazard(nullptr, from) {}
  inline Hazard(Hazard&& from) noexcept
      : Hazard(nullptr, ::std::move(from)) {}
  inline Hazard& operator=(const Hazard& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hazard& operator=(Hazard&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hazard& default_instance() {
    return *reinterpret_cast<const Hazard*>(
        &_Hazard_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Hazard& a, Hazard& b) { a.Swap(&b); }
  inline void Swap(Hazard* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hazard* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hazard* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Hazard>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Hazard& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Hazard& from) { Hazard::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Hazard* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.Hazard"; }

 protected:
  explicit Hazard(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Hazard(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Hazard& from);
  Hazard(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Hazard&& from) noexcept
      : Hazard(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeAndConfidence = Hazard_TypeAndConfidence;
  using Direction = Hazard_Direction;
  static constexpr Direction UNKNOWN_DIRECTION = Hazard_Direction_UNKNOWN_DIRECTION;
  static constexpr Direction EGO_DIRECTION = Hazard_Direction_EGO_DIRECTION;
  static constexpr Direction OPPOSITE_DIRECTION = Hazard_Direction_OPPOSITE_DIRECTION;
  static constexpr Direction BOTH = Hazard_Direction_BOTH;
  static inline bool Direction_IsValid(int value) {
    return Hazard_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN = Hazard_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX = Hazard_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE = Hazard_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Direction_descriptor() {
    return Hazard_Direction_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Direction_Name(T value) {
    return Hazard_Direction_Name(value);
  }
  static inline bool Direction_Parse(
      ::absl::string_view name, Direction* PROTOBUF_NONNULL value) {
    return Hazard_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
    kDirectionFieldNumber = 4,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& type_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NULLABLE release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NONNULL mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NONNULL _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.Hazard.Direction direction = 4;
  void clear_direction() ;
  ::sensoris::protobuf::categories::trafficevents::Hazard_Direction direction() const;
  void set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value);

  private:
  ::sensoris::protobuf::categories::trafficevents::Hazard_Direction _internal_direction() const;
  void _internal_set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.Hazard)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Hazard& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE detection_status_;
    ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NULLABLE type_and_confidence_;
    int direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Hazard_class_data_;
// -------------------------------------------------------------------

class ECallStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.ECallStatus) */ {
 public:
  inline ECallStatus() : ECallStatus(nullptr) {}
  ~ECallStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ECallStatus* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ECallStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ECallStatus(::google::protobuf::internal::ConstantInitialized);

  inline ECallStatus(const ECallStatus& from) : ECallStatus(nullptr, from) {}
  inline ECallStatus(ECallStatus&& from) noexcept
      : ECallStatus(nullptr, ::std::move(from)) {}
  inline ECallStatus& operator=(const ECallStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ECallStatus& operator=(ECallStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ECallStatus& default_instance() {
    return *reinterpret_cast<const ECallStatus*>(
        &_ECallStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ECallStatus& a, ECallStatus& b) { a.Swap(&b); }
  inline void Swap(ECallStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ECallStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ECallStatus* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ECallStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ECallStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ECallStatus& from) { ECallStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ECallStatus* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.ECallStatus"; }

 protected:
  explicit ECallStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ECallStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ECallStatus& from);
  ECallStatus(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ECallStatus&& from) noexcept
      : ECallStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ActivationType = ECallStatus_ActivationType;
  static constexpr ActivationType UNKNOWN_ACTIVATION_TYPE = ECallStatus_ActivationType_UNKNOWN_ACTIVATION_TYPE;
  static constexpr ActivationType NONE = ECallStatus_ActivationType_NONE;
  static constexpr ActivationType MANUAL = ECallStatus_ActivationType_MANUAL;
  static constexpr ActivationType AUTOMATIC = ECallStatus_ActivationType_AUTOMATIC;
  static inline bool ActivationType_IsValid(int value) {
    return ECallStatus_ActivationType_IsValid(value);
  }
  static constexpr ActivationType ActivationType_MIN = ECallStatus_ActivationType_ActivationType_MIN;
  static constexpr ActivationType ActivationType_MAX = ECallStatus_ActivationType_ActivationType_MAX;
  static constexpr int ActivationType_ARRAYSIZE = ECallStatus_ActivationType_ActivationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ActivationType_descriptor() {
    return ECallStatus_ActivationType_descriptor();
  }
  template <typename T>
  static inline const ::std::string& ActivationType_Name(T value) {
    return ECallStatus_ActivationType_Name(value);
  }
  static inline bool ActivationType_Parse(
      ::absl::string_view name, ActivationType* PROTOBUF_NONNULL value) {
    return ECallStatus_ActivationType_Parse(name, value);
  }
  using Availability = ECallStatus_Availability;
  static constexpr Availability UNKNOWN_AVAILABILITY = ECallStatus_Availability_UNKNOWN_AVAILABILITY;
  static constexpr Availability AVAILABLE = ECallStatus_Availability_AVAILABLE;
  static constexpr Availability UNAVAILABLE = ECallStatus_Availability_UNAVAILABLE;
  static inline bool Availability_IsValid(int value) {
    return ECallStatus_Availability_IsValid(value);
  }
  static constexpr Availability Availability_MIN = ECallStatus_Availability_Availability_MIN;
  static constexpr Availability Availability_MAX = ECallStatus_Availability_Availability_MAX;
  static constexpr int Availability_ARRAYSIZE = ECallStatus_Availability_Availability_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Availability_descriptor() {
    return ECallStatus_Availability_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Availability_Name(T value) {
    return ECallStatus_Availability_Name(value);
  }
  static inline bool Availability_Parse(
      ::absl::string_view name, Availability* PROTOBUF_NONNULL value) {
    return ECallStatus_Availability_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kActivationTypeFieldNumber = 2,
    kAvailabilityFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.categories.trafficevents.ECallStatus.ActivationType activation_type = 2;
  void clear_activation_type() ;
  ::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType activation_type() const;
  void set_activation_type(::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType value);

  private:
  ::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType _internal_activation_type() const;
  void _internal_set_activation_type(::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType value);

  public:
  // .sensoris.protobuf.categories.trafficevents.ECallStatus.Availability availability = 3;
  void clear_availability() ;
  ::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability availability() const;
  void set_availability(::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability value);

  private:
  ::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability _internal_availability() const;
  void _internal_set_availability(::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.ECallStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ECallStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    int activation_type_;
    int availability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ECallStatus_class_data_;
// -------------------------------------------------------------------

class RoadWeatherCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition) */ {
 public:
  inline RoadWeatherCondition() : RoadWeatherCondition(nullptr) {}
  ~RoadWeatherCondition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadWeatherCondition* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadWeatherCondition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadWeatherCondition(::google::protobuf::internal::ConstantInitialized);

  inline RoadWeatherCondition(const RoadWeatherCondition& from) : RoadWeatherCondition(nullptr, from) {}
  inline RoadWeatherCondition(RoadWeatherCondition&& from) noexcept
      : RoadWeatherCondition(nullptr, ::std::move(from)) {}
  inline RoadWeatherCondition& operator=(const RoadWeatherCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadWeatherCondition& operator=(RoadWeatherCondition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadWeatherCondition& default_instance() {
    return *reinterpret_cast<const RoadWeatherCondition*>(
        &_RoadWeatherCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(RoadWeatherCondition& a, RoadWeatherCondition& b) { a.Swap(&b); }
  inline void Swap(RoadWeatherCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadWeatherCondition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadWeatherCondition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadWeatherCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadWeatherCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadWeatherCondition& from) { RoadWeatherCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadWeatherCondition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.RoadWeatherCondition"; }

 protected:
  explicit RoadWeatherCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadWeatherCondition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadWeatherCondition& from);
  RoadWeatherCondition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadWeatherCondition&& from) noexcept
      : RoadWeatherCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TypeAndConfidence = RoadWeatherCondition_TypeAndConfidence;

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
    kDepthAndAccuracyFieldNumber = 4,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& type_and_confidence() const;
  [[nodiscard]] ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NULLABLE release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NONNULL mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NULLABLE unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NONNULL _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy depth_and_accuracy = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_depth_and_accuracy() const;
  void clear_depth_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& depth_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_depth_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_depth_and_accuracy();
  void set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_depth_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_depth_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_depth_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadWeatherCondition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE detection_status_;
    ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NULLABLE type_and_confidence_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE depth_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadWeatherCondition_class_data_;
// -------------------------------------------------------------------

class RoadFriction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadFriction) */ {
 public:
  inline RoadFriction() : RoadFriction(nullptr) {}
  ~RoadFriction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoadFriction* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoadFriction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoadFriction(::google::protobuf::internal::ConstantInitialized);

  inline RoadFriction(const RoadFriction& from) : RoadFriction(nullptr, from) {}
  inline RoadFriction(RoadFriction&& from) noexcept
      : RoadFriction(nullptr, ::std::move(from)) {}
  inline RoadFriction& operator=(const RoadFriction& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadFriction& operator=(RoadFriction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadFriction& default_instance() {
    return *reinterpret_cast<const RoadFriction*>(
        &_RoadFriction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(RoadFriction& a, RoadFriction& b) { a.Swap(&b); }
  inline void Swap(RoadFriction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadFriction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadFriction* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoadFriction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadFriction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoadFriction& from) { RoadFriction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoadFriction* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.RoadFriction"; }

 protected:
  explicit RoadFriction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoadFriction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoadFriction& from);
  RoadFriction(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoadFriction&& from) noexcept
      : RoadFriction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kMostProbableFieldNumber = 2,
    kLowerBoundFieldNumber = 3,
    kUpperBoundFieldNumber = 4,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.Int64Value most_probable = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_most_probable() const;
  void clear_most_probable() ;
  const ::sensoris::protobuf::types::base::Int64Value& most_probable() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_most_probable();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_most_probable();
  void set_allocated_most_probable(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_most_probable(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_most_probable();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_most_probable() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_most_probable();

  public:
  // .sensoris.protobuf.types.base.Int64Value lower_bound = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_lower_bound() const;
  void clear_lower_bound() ;
  const ::sensoris::protobuf::types::base::Int64Value& lower_bound() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_lower_bound();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_lower_bound();
  void set_allocated_lower_bound(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lower_bound(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_lower_bound();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_lower_bound() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_lower_bound();

  public:
  // .sensoris.protobuf.types.base.Int64Value upper_bound = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_upper_bound() const;
  void clear_upper_bound() ;
  const ::sensoris::protobuf::types::base::Int64Value& upper_bound() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_upper_bound();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_upper_bound();
  void set_allocated_upper_bound(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_upper_bound(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_upper_bound();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_upper_bound() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_upper_bound();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadFriction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoadFriction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE most_probable_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE lower_bound_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE upper_bound_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoadFriction_class_data_;
// -------------------------------------------------------------------

class DangerousSlowDown final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.DangerousSlowDown) */ {
 public:
  inline DangerousSlowDown() : DangerousSlowDown(nullptr) {}
  ~DangerousSlowDown() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DangerousSlowDown* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DangerousSlowDown));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DangerousSlowDown(::google::protobuf::internal::ConstantInitialized);

  inline DangerousSlowDown(const DangerousSlowDown& from) : DangerousSlowDown(nullptr, from) {}
  inline DangerousSlowDown(DangerousSlowDown&& from) noexcept
      : DangerousSlowDown(nullptr, ::std::move(from)) {}
  inline DangerousSlowDown& operator=(const DangerousSlowDown& from) {
    CopyFrom(from);
    return *this;
  }
  inline DangerousSlowDown& operator=(DangerousSlowDown&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DangerousSlowDown& default_instance() {
    return *reinterpret_cast<const DangerousSlowDown*>(
        &_DangerousSlowDown_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(DangerousSlowDown& a, DangerousSlowDown& b) { a.Swap(&b); }
  inline void Swap(DangerousSlowDown* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DangerousSlowDown* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DangerousSlowDown* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DangerousSlowDown>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DangerousSlowDown& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DangerousSlowDown& from) { DangerousSlowDown::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DangerousSlowDown* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.DangerousSlowDown"; }

 protected:
  explicit DangerousSlowDown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DangerousSlowDown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DangerousSlowDown& from);
  DangerousSlowDown(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DangerousSlowDown&& from) noexcept
      : DangerousSlowDown(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kSpeedReductionAndAccuracyFieldNumber = 2,
    kTimePeriodFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy speed_reduction_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 1];
  bool has_speed_reduction_and_accuracy() const;
  void clear_speed_reduction_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& speed_reduction_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE release_speed_reduction_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL mutable_speed_reduction_and_accuracy();
  void set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_speed_reduction_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_speed_reduction_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL _internal_mutable_speed_reduction_and_accuracy();

  public:
  // .google.protobuf.Int64Value time_period = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_time_period() const;
  void clear_time_period() ;
  const ::google::protobuf::Int64Value& time_period() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_time_period();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_time_period();
  void set_allocated_time_period(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_time_period(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_time_period();

  private:
  const ::google::protobuf::Int64Value& _internal_time_period() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_time_period();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.DangerousSlowDown)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DangerousSlowDown& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE envelope_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE speed_reduction_and_accuracy_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE time_period_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DangerousSlowDown_class_data_;
// -------------------------------------------------------------------

class TrafficEventsCategory final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory) */ {
 public:
  inline TrafficEventsCategory() : TrafficEventsCategory(nullptr) {}
  ~TrafficEventsCategory() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrafficEventsCategory* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrafficEventsCategory));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficEventsCategory(::google::protobuf::internal::ConstantInitialized);

  inline TrafficEventsCategory(const TrafficEventsCategory& from) : TrafficEventsCategory(nullptr, from) {}
  inline TrafficEventsCategory(TrafficEventsCategory&& from) noexcept
      : TrafficEventsCategory(nullptr, ::std::move(from)) {}
  inline TrafficEventsCategory& operator=(const TrafficEventsCategory& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficEventsCategory& operator=(TrafficEventsCategory&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficEventsCategory& default_instance() {
    return *reinterpret_cast<const TrafficEventsCategory*>(
        &_TrafficEventsCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(TrafficEventsCategory& a, TrafficEventsCategory& b) { a.Swap(&b); }
  inline void Swap(TrafficEventsCategory* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficEventsCategory* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficEventsCategory* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrafficEventsCategory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficEventsCategory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrafficEventsCategory& from) { TrafficEventsCategory::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrafficEventsCategory* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.categories.trafficevents.TrafficEventsCategory"; }

 protected:
  explicit TrafficEventsCategory(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TrafficEventsCategory(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TrafficEventsCategory& from);
  TrafficEventsCategory(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TrafficEventsCategory&& from) noexcept
      : TrafficEventsCategory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHazardFieldNumber = 2,
    kDangerousSlowDownFieldNumber = 3,
    kTrafficConditionFieldNumber = 4,
    kRoadworksFieldNumber = 5,
    kRoadWeatherConditionFieldNumber = 6,
    kRoadSurfaceConditionFieldNumber = 7,
    kRoadObstructionConditionFieldNumber = 8,
    kVulnerableRoadUserConditionFieldNumber = 9,
    kECallStatusFieldNumber = 10,
    kRoadFrictionFieldNumber = 11,
    kEnvelopeFieldNumber = 1,
  };
  // repeated .sensoris.protobuf.categories.trafficevents.Hazard hazard = 2;
  int hazard_size() const;
  private:
  int _internal_hazard_size() const;

  public:
  void clear_hazard() ;
  ::sensoris::protobuf::categories::trafficevents::Hazard* PROTOBUF_NONNULL mutable_hazard(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>* PROTOBUF_NONNULL mutable_hazard();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>& _internal_hazard() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>* PROTOBUF_NONNULL _internal_mutable_hazard();
  public:
  const ::sensoris::protobuf::categories::trafficevents::Hazard& hazard(int index) const;
  ::sensoris::protobuf::categories::trafficevents::Hazard* PROTOBUF_NONNULL add_hazard();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>& hazard() const;
  // repeated .sensoris.protobuf.categories.trafficevents.DangerousSlowDown dangerous_slow_down = 3;
  int dangerous_slow_down_size() const;
  private:
  int _internal_dangerous_slow_down_size() const;

  public:
  void clear_dangerous_slow_down() ;
  ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* PROTOBUF_NONNULL mutable_dangerous_slow_down(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>* PROTOBUF_NONNULL mutable_dangerous_slow_down();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>& _internal_dangerous_slow_down() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>* PROTOBUF_NONNULL _internal_mutable_dangerous_slow_down();
  public:
  const ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown& dangerous_slow_down(int index) const;
  ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* PROTOBUF_NONNULL add_dangerous_slow_down();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>& dangerous_slow_down() const;
  // repeated .sensoris.protobuf.categories.trafficevents.TrafficCondition traffic_condition = 4;
  int traffic_condition_size() const;
  private:
  int _internal_traffic_condition_size() const;

  public:
  void clear_traffic_condition() ;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition* PROTOBUF_NONNULL mutable_traffic_condition(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>* PROTOBUF_NONNULL mutable_traffic_condition();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>& _internal_traffic_condition() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>* PROTOBUF_NONNULL _internal_mutable_traffic_condition();
  public:
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition& traffic_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition* PROTOBUF_NONNULL add_traffic_condition();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>& traffic_condition() const;
  // repeated .sensoris.protobuf.categories.trafficevents.RoadWorks roadworks = 5;
  int roadworks_size() const;
  private:
  int _internal_roadworks_size() const;

  public:
  void clear_roadworks() ;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks* PROTOBUF_NONNULL mutable_roadworks(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>* PROTOBUF_NONNULL mutable_roadworks();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>& _internal_roadworks() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>* PROTOBUF_NONNULL _internal_mutable_roadworks();
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks& roadworks(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks* PROTOBUF_NONNULL add_roadworks();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>& roadworks() const;
  // repeated .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition road_weather_condition = 6;
  int road_weather_condition_size() const;
  private:
  int _internal_road_weather_condition_size() const;

  public:
  void clear_road_weather_condition() ;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* PROTOBUF_NONNULL mutable_road_weather_condition(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>* PROTOBUF_NONNULL mutable_road_weather_condition();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>& _internal_road_weather_condition() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>* PROTOBUF_NONNULL _internal_mutable_road_weather_condition();
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition& road_weather_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* PROTOBUF_NONNULL add_road_weather_condition();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>& road_weather_condition() const;
  // repeated .sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition road_surface_condition = 7;
  int road_surface_condition_size() const;
  private:
  int _internal_road_surface_condition_size() const;

  public:
  void clear_road_surface_condition() ;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition* PROTOBUF_NONNULL mutable_road_surface_condition(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>* PROTOBUF_NONNULL mutable_road_surface_condition();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>& _internal_road_surface_condition() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>* PROTOBUF_NONNULL _internal_mutable_road_surface_condition();
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition& road_surface_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition* PROTOBUF_NONNULL add_road_surface_condition();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>& road_surface_condition() const;
  // repeated .sensoris.protobuf.categories.trafficevents.RoadObstructionCondition road_obstruction_condition = 8;
  int road_obstruction_condition_size() const;
  private:
  int _internal_road_obstruction_condition_size() const;

  public:
  void clear_road_obstruction_condition() ;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition* PROTOBUF_NONNULL mutable_road_obstruction_condition(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>* PROTOBUF_NONNULL mutable_road_obstruction_condition();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>& _internal_road_obstruction_condition() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>* PROTOBUF_NONNULL _internal_mutable_road_obstruction_condition();
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition& road_obstruction_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition* PROTOBUF_NONNULL add_road_obstruction_condition();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>& road_obstruction_condition() const;
  // repeated .sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition vulnerable_road_user_condition = 9;
  int vulnerable_road_user_condition_size() const;
  private:
  int _internal_vulnerable_road_user_condition_size() const;

  public:
  void clear_vulnerable_road_user_condition() ;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition* PROTOBUF_NONNULL mutable_vulnerable_road_user_condition(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>* PROTOBUF_NONNULL mutable_vulnerable_road_user_condition();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>& _internal_vulnerable_road_user_condition() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>* PROTOBUF_NONNULL _internal_mutable_vulnerable_road_user_condition();
  public:
  const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition& vulnerable_road_user_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition* PROTOBUF_NONNULL add_vulnerable_road_user_condition();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>& vulnerable_road_user_condition() const;
  // repeated .sensoris.protobuf.categories.trafficevents.ECallStatus e_call_status = 10;
  int e_call_status_size() const;
  private:
  int _internal_e_call_status_size() const;

  public:
  void clear_e_call_status() ;
  ::sensoris::protobuf::categories::trafficevents::ECallStatus* PROTOBUF_NONNULL mutable_e_call_status(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>* PROTOBUF_NONNULL mutable_e_call_status();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>& _internal_e_call_status() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>* PROTOBUF_NONNULL _internal_mutable_e_call_status();
  public:
  const ::sensoris::protobuf::categories::trafficevents::ECallStatus& e_call_status(int index) const;
  ::sensoris::protobuf::categories::trafficevents::ECallStatus* PROTOBUF_NONNULL add_e_call_status();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>& e_call_status() const;
  // repeated .sensoris.protobuf.categories.trafficevents.RoadFriction road_friction = 11;
  int road_friction_size() const;
  private:
  int _internal_road_friction_size() const;

  public:
  void clear_road_friction() ;
  ::sensoris::protobuf::categories::trafficevents::RoadFriction* PROTOBUF_NONNULL mutable_road_friction(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadFriction>* PROTOBUF_NONNULL mutable_road_friction();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadFriction>& _internal_road_friction() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadFriction>* PROTOBUF_NONNULL _internal_mutable_road_friction();
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadFriction& road_friction(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadFriction* PROTOBUF_NONNULL add_road_friction();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadFriction>& road_friction() const;
  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::CategoryEnvelope& envelope() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE release_envelope();
  ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NONNULL mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NONNULL _internal_mutable_envelope();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11,
                                   11, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TrafficEventsCategory& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::Hazard > hazard_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown > dangerous_slow_down_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::TrafficCondition > traffic_condition_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWorks > roadworks_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition > road_weather_condition_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition > road_surface_condition_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition > road_obstruction_condition_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition > vulnerable_road_user_condition_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::ECallStatus > e_call_status_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadFriction > road_friction_;
    ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE envelope_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TrafficEventsCategory_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Hazard_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.Type type = 1;
inline void Hazard_TypeAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.type)
  return _internal_type();
}
inline void Hazard_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type>(_impl_.type_);
}
inline void Hazard_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool Hazard_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& Hazard_TypeAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& Hazard_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void Hazard_TypeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE Hazard_TypeAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE Hazard_TypeAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL Hazard_TypeAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL Hazard_TypeAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
  return _msg;
}
inline void Hazard_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// Hazard

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool Hazard::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Hazard::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Hazard::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
  return _internal_envelope();
}
inline void Hazard::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE Hazard::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE Hazard::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL Hazard::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL Hazard::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
  return _msg;
}
inline void Hazard::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool Hazard::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& Hazard::_internal_detection_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& Hazard::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
  return _internal_detection_status();
}
inline void Hazard::unsafe_arena_set_allocated_detection_status(
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE Hazard::release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE Hazard::unsafe_arena_release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL Hazard::_internal_mutable_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detection_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL Hazard::mutable_detection_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
  return _msg;
}
inline void Hazard::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence type_and_confidence = 3;
inline bool Hazard::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void Hazard::clear_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& Hazard::_internal_type_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_Hazard_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& Hazard::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void Hazard::unsafe_arena_set_allocated_type_and_confidence(
    ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NULLABLE Hazard::release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NULLABLE Hazard::unsafe_arena_release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NONNULL Hazard::_internal_mutable_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NONNULL Hazard::mutable_type_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
  return _msg;
}
inline void Hazard::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
}

// .sensoris.protobuf.categories.trafficevents.Hazard.Direction direction = 4;
inline void Hazard::clear_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_Direction Hazard::direction() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.direction)
  return _internal_direction();
}
inline void Hazard::set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value) {
  _internal_set_direction(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.Hazard.direction)
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_Direction Hazard::_internal_direction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::trafficevents::Hazard_Direction>(_impl_.direction_);
}
inline void Hazard::_internal_set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_ = value;
}

// -------------------------------------------------------------------

// DangerousSlowDown

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool DangerousSlowDown::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& DangerousSlowDown::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& DangerousSlowDown::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
  return _internal_envelope();
}
inline void DangerousSlowDown::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE DangerousSlowDown::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE DangerousSlowDown::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL DangerousSlowDown::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL DangerousSlowDown::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
  return _msg;
}
inline void DangerousSlowDown::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy speed_reduction_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 1];
inline bool DangerousSlowDown::has_speed_reduction_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speed_reduction_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& DangerousSlowDown::_internal_speed_reduction_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.speed_reduction_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& DangerousSlowDown::speed_reduction_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
  return _internal_speed_reduction_and_accuracy();
}
inline void DangerousSlowDown::unsafe_arena_set_allocated_speed_reduction_and_accuracy(
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_reduction_and_accuracy_);
  }
  _impl_.speed_reduction_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE DangerousSlowDown::release_speed_reduction_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.speed_reduction_and_accuracy_;
  _impl_.speed_reduction_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE DangerousSlowDown::unsafe_arena_release_speed_reduction_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.speed_reduction_and_accuracy_;
  _impl_.speed_reduction_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL DangerousSlowDown::_internal_mutable_speed_reduction_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.speed_reduction_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.speed_reduction_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.speed_reduction_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL DangerousSlowDown::mutable_speed_reduction_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_speed_reduction_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
  return _msg;
}
inline void DangerousSlowDown::set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_reduction_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.speed_reduction_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
}

// .google.protobuf.Int64Value time_period = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool DangerousSlowDown::has_time_period() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_period_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& DangerousSlowDown::_internal_time_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.time_period_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& DangerousSlowDown::time_period() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
  return _internal_time_period();
}
inline void DangerousSlowDown::unsafe_arena_set_allocated_time_period(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_period_);
  }
  _impl_.time_period_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE DangerousSlowDown::release_time_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.time_period_;
  _impl_.time_period_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE DangerousSlowDown::unsafe_arena_release_time_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.time_period_;
  _impl_.time_period_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL DangerousSlowDown::_internal_mutable_time_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_period_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.time_period_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.time_period_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL DangerousSlowDown::mutable_time_period()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_time_period();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
  return _msg;
}
inline void DangerousSlowDown::set_allocated_time_period(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_period_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.time_period_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
}

// -------------------------------------------------------------------

// TrafficCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.Type type = 1;
inline void TrafficCondition_TypeAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.type)
  return _internal_type();
}
inline void TrafficCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type>(_impl_.type_);
}
inline void TrafficCondition_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficCondition_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficCondition_TypeAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficCondition_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void TrafficCondition_TypeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE TrafficCondition_TypeAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE TrafficCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL TrafficCondition_TypeAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL TrafficCondition_TypeAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
  return _msg;
}
inline void TrafficCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool TrafficCondition::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TrafficCondition::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TrafficCondition::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
  return _internal_envelope();
}
inline void TrafficCondition::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE TrafficCondition::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE TrafficCondition::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL TrafficCondition::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL TrafficCondition::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
  return _msg;
}
inline void TrafficCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool TrafficCondition::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficCondition::_internal_detection_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficCondition::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
  return _internal_detection_status();
}
inline void TrafficCondition::unsafe_arena_set_allocated_detection_status(
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE TrafficCondition::release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE TrafficCondition::unsafe_arena_release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL TrafficCondition::_internal_mutable_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detection_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL TrafficCondition::mutable_detection_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
  return _msg;
}
inline void TrafficCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence type_and_confidence = 3;
inline bool TrafficCondition::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void TrafficCondition::clear_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& TrafficCondition::_internal_type_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_TrafficCondition_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& TrafficCondition::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void TrafficCondition::unsafe_arena_set_allocated_type_and_confidence(
    ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NULLABLE TrafficCondition::release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NULLABLE TrafficCondition::unsafe_arena_release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NONNULL TrafficCondition::_internal_mutable_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NONNULL TrafficCondition::mutable_type_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
  return _msg;
}
inline void TrafficCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
}

// -------------------------------------------------------------------

// RoadWorks_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.Type type = 1;
inline void RoadWorks_TypeAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.type)
  return _internal_type();
}
inline void RoadWorks_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadWorks_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadWorks_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWorks_TypeAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWorks_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadWorks_TypeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE RoadWorks_TypeAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE RoadWorks_TypeAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL RoadWorks_TypeAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL RoadWorks_TypeAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
  return _msg;
}
inline void RoadWorks_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadWorks

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadWorks::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWorks::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWorks::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
  return _internal_envelope();
}
inline void RoadWorks::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE RoadWorks::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE RoadWorks::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL RoadWorks::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL RoadWorks::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
  return _msg;
}
inline void RoadWorks::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadWorks::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWorks::_internal_detection_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWorks::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
  return _internal_detection_status();
}
inline void RoadWorks::unsafe_arena_set_allocated_detection_status(
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE RoadWorks::release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE RoadWorks::unsafe_arena_release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL RoadWorks::_internal_mutable_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detection_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL RoadWorks::mutable_detection_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
  return _msg;
}
inline void RoadWorks::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence type_and_confidence = 3;
inline bool RoadWorks::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void RoadWorks::clear_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& RoadWorks::_internal_type_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_RoadWorks_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& RoadWorks::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void RoadWorks::unsafe_arena_set_allocated_type_and_confidence(
    ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NULLABLE RoadWorks::release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NULLABLE RoadWorks::unsafe_arena_release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NONNULL RoadWorks::_internal_mutable_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NONNULL RoadWorks::mutable_type_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
  return _msg;
}
inline void RoadWorks::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
}

// .sensoris.protobuf.types.base.CountAndConfidence lanes_closed_and_confidence = 5;
inline bool RoadWorks::has_lanes_closed_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lanes_closed_and_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& RoadWorks::_internal_lanes_closed_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::CountAndConfidence* p = _impl_.lanes_closed_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::CountAndConfidence&>(::sensoris::protobuf::types::base::_CountAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& RoadWorks::lanes_closed_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
  return _internal_lanes_closed_and_confidence();
}
inline void RoadWorks::unsafe_arena_set_allocated_lanes_closed_and_confidence(
    ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lanes_closed_and_confidence_);
  }
  _impl_.lanes_closed_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE RoadWorks::release_lanes_closed_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::CountAndConfidence* released = _impl_.lanes_closed_and_confidence_;
  _impl_.lanes_closed_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE RoadWorks::unsafe_arena_release_lanes_closed_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::CountAndConfidence* temp = _impl_.lanes_closed_and_confidence_;
  _impl_.lanes_closed_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NONNULL RoadWorks::_internal_mutable_lanes_closed_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lanes_closed_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::CountAndConfidence>(GetArena());
    _impl_.lanes_closed_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(p);
  }
  return _impl_.lanes_closed_and_confidence_;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NONNULL RoadWorks::mutable_lanes_closed_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::sensoris::protobuf::types::base::CountAndConfidence* _msg = _internal_mutable_lanes_closed_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
  return _msg;
}
inline void RoadWorks::set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lanes_closed_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.lanes_closed_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
}

// -------------------------------------------------------------------

// RoadWeatherCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.Type type = 1;
inline void RoadWeatherCondition_TypeAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.type)
  return _internal_type();
}
inline void RoadWeatherCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadWeatherCondition_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadWeatherCondition_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWeatherCondition_TypeAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWeatherCondition_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadWeatherCondition_TypeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE RoadWeatherCondition_TypeAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE RoadWeatherCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL RoadWeatherCondition_TypeAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL RoadWeatherCondition_TypeAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
  return _msg;
}
inline void RoadWeatherCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadWeatherCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadWeatherCondition::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWeatherCondition::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWeatherCondition::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
  return _internal_envelope();
}
inline void RoadWeatherCondition::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE RoadWeatherCondition::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE RoadWeatherCondition::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL RoadWeatherCondition::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL RoadWeatherCondition::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
  return _msg;
}
inline void RoadWeatherCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadWeatherCondition::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWeatherCondition::_internal_detection_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWeatherCondition::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
  return _internal_detection_status();
}
inline void RoadWeatherCondition::unsafe_arena_set_allocated_detection_status(
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE RoadWeatherCondition::release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE RoadWeatherCondition::unsafe_arena_release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL RoadWeatherCondition::_internal_mutable_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detection_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL RoadWeatherCondition::mutable_detection_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
  return _msg;
}
inline void RoadWeatherCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence type_and_confidence = 3;
inline bool RoadWeatherCondition::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void RoadWeatherCondition::clear_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& RoadWeatherCondition::_internal_type_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_RoadWeatherCondition_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& RoadWeatherCondition::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void RoadWeatherCondition::unsafe_arena_set_allocated_type_and_confidence(
    ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NULLABLE RoadWeatherCondition::release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NULLABLE RoadWeatherCondition::unsafe_arena_release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NONNULL RoadWeatherCondition::_internal_mutable_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NONNULL RoadWeatherCondition::mutable_type_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
  return _msg;
}
inline void RoadWeatherCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy depth_and_accuracy = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool RoadWeatherCondition::has_depth_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.depth_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& RoadWeatherCondition::_internal_depth_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.depth_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& RoadWeatherCondition::depth_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
  return _internal_depth_and_accuracy();
}
inline void RoadWeatherCondition::unsafe_arena_set_allocated_depth_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.depth_and_accuracy_);
  }
  _impl_.depth_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE RoadWeatherCondition::release_depth_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.depth_and_accuracy_;
  _impl_.depth_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE RoadWeatherCondition::unsafe_arena_release_depth_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.depth_and_accuracy_;
  _impl_.depth_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL RoadWeatherCondition::_internal_mutable_depth_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.depth_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.depth_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.depth_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL RoadWeatherCondition::mutable_depth_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_depth_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
  return _msg;
}
inline void RoadWeatherCondition::set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.depth_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.depth_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
}

// -------------------------------------------------------------------

// RoadSurfaceCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.Type type = 1;
inline void RoadSurfaceCondition_TypeAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type RoadSurfaceCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.type)
  return _internal_type();
}
inline void RoadSurfaceCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type RoadSurfaceCondition_TypeAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadSurfaceCondition_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadSurfaceCondition_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadSurfaceCondition_TypeAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadSurfaceCondition_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadSurfaceCondition_TypeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE RoadSurfaceCondition_TypeAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE RoadSurfaceCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL RoadSurfaceCondition_TypeAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL RoadSurfaceCondition_TypeAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.confidence)
  return _msg;
}
inline void RoadSurfaceCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadSurfaceCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadSurfaceCondition::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadSurfaceCondition::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadSurfaceCondition::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.envelope)
  return _internal_envelope();
}
inline void RoadSurfaceCondition::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE RoadSurfaceCondition::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE RoadSurfaceCondition::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL RoadSurfaceCondition::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL RoadSurfaceCondition::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.envelope)
  return _msg;
}
inline void RoadSurfaceCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadSurfaceCondition::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadSurfaceCondition::_internal_detection_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadSurfaceCondition::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.detection_status)
  return _internal_detection_status();
}
inline void RoadSurfaceCondition::unsafe_arena_set_allocated_detection_status(
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE RoadSurfaceCondition::release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE RoadSurfaceCondition::unsafe_arena_release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL RoadSurfaceCondition::_internal_mutable_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detection_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL RoadSurfaceCondition::mutable_detection_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.detection_status)
  return _msg;
}
inline void RoadSurfaceCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence type_and_confidence = 3;
inline bool RoadSurfaceCondition::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void RoadSurfaceCondition::clear_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence& RoadSurfaceCondition::_internal_type_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_RoadSurfaceCondition_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence& RoadSurfaceCondition::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void RoadSurfaceCondition::unsafe_arena_set_allocated_type_and_confidence(
    ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NULLABLE RoadSurfaceCondition::release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NULLABLE RoadSurfaceCondition::unsafe_arena_release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NONNULL RoadSurfaceCondition::_internal_mutable_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NONNULL RoadSurfaceCondition::mutable_type_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.type_and_confidence)
  return _msg;
}
inline void RoadSurfaceCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.type_and_confidence)
}

// -------------------------------------------------------------------

// RoadObstructionCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.Type type = 1;
inline void RoadObstructionCondition_TypeAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type RoadObstructionCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.type)
  return _internal_type();
}
inline void RoadObstructionCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type RoadObstructionCondition_TypeAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadObstructionCondition_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadObstructionCondition_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadObstructionCondition_TypeAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadObstructionCondition_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadObstructionCondition_TypeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE RoadObstructionCondition_TypeAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE RoadObstructionCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL RoadObstructionCondition_TypeAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL RoadObstructionCondition_TypeAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.confidence)
  return _msg;
}
inline void RoadObstructionCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadObstructionCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadObstructionCondition::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadObstructionCondition::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadObstructionCondition::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.envelope)
  return _internal_envelope();
}
inline void RoadObstructionCondition::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE RoadObstructionCondition::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE RoadObstructionCondition::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL RoadObstructionCondition::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL RoadObstructionCondition::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.envelope)
  return _msg;
}
inline void RoadObstructionCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadObstructionCondition::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadObstructionCondition::_internal_detection_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadObstructionCondition::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.detection_status)
  return _internal_detection_status();
}
inline void RoadObstructionCondition::unsafe_arena_set_allocated_detection_status(
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE RoadObstructionCondition::release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE RoadObstructionCondition::unsafe_arena_release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL RoadObstructionCondition::_internal_mutable_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detection_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL RoadObstructionCondition::mutable_detection_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.detection_status)
  return _msg;
}
inline void RoadObstructionCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence type_and_confidence = 3;
inline bool RoadObstructionCondition::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void RoadObstructionCondition::clear_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence& RoadObstructionCondition::_internal_type_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_RoadObstructionCondition_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence& RoadObstructionCondition::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void RoadObstructionCondition::unsafe_arena_set_allocated_type_and_confidence(
    ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NULLABLE RoadObstructionCondition::release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NULLABLE RoadObstructionCondition::unsafe_arena_release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NONNULL RoadObstructionCondition::_internal_mutable_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NONNULL RoadObstructionCondition::mutable_type_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.type_and_confidence)
  return _msg;
}
inline void RoadObstructionCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.type_and_confidence)
}

// -------------------------------------------------------------------

// VulnerableRoadUserCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.Type type = 1;
inline void VulnerableRoadUserCondition_TypeAndConfidence::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type VulnerableRoadUserCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.type)
  return _internal_type();
}
inline void VulnerableRoadUserCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type VulnerableRoadUserCondition_TypeAndConfidence::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type>(_impl_.type_);
}
inline void VulnerableRoadUserCondition_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool VulnerableRoadUserCondition_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& VulnerableRoadUserCondition_TypeAndConfidence::_internal_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& VulnerableRoadUserCondition_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void VulnerableRoadUserCondition_TypeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE VulnerableRoadUserCondition_TypeAndConfidence::release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE VulnerableRoadUserCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL VulnerableRoadUserCondition_TypeAndConfidence::_internal_mutable_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* PROTOBUF_NONNULL VulnerableRoadUserCondition_TypeAndConfidence::mutable_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.confidence)
  return _msg;
}
inline void VulnerableRoadUserCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// VulnerableRoadUserCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool VulnerableRoadUserCondition::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VulnerableRoadUserCondition::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VulnerableRoadUserCondition::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.envelope)
  return _internal_envelope();
}
inline void VulnerableRoadUserCondition::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE VulnerableRoadUserCondition::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE VulnerableRoadUserCondition::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL VulnerableRoadUserCondition::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL VulnerableRoadUserCondition::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.envelope)
  return _msg;
}
inline void VulnerableRoadUserCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool VulnerableRoadUserCondition::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& VulnerableRoadUserCondition::_internal_detection_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& VulnerableRoadUserCondition::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.detection_status)
  return _internal_detection_status();
}
inline void VulnerableRoadUserCondition::unsafe_arena_set_allocated_detection_status(
    ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE VulnerableRoadUserCondition::release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE VulnerableRoadUserCondition::unsafe_arena_release_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL VulnerableRoadUserCondition::_internal_mutable_detection_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detection_status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NONNULL VulnerableRoadUserCondition::mutable_detection_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.detection_status)
  return _msg;
}
inline void VulnerableRoadUserCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence type_and_confidence = 3;
inline bool VulnerableRoadUserCondition::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void VulnerableRoadUserCondition::clear_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence& VulnerableRoadUserCondition::_internal_type_and_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_VulnerableRoadUserCondition_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence& VulnerableRoadUserCondition::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void VulnerableRoadUserCondition::unsafe_arena_set_allocated_type_and_confidence(
    ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NULLABLE VulnerableRoadUserCondition::release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NULLABLE VulnerableRoadUserCondition::unsafe_arena_release_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NONNULL VulnerableRoadUserCondition::_internal_mutable_type_and_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NONNULL VulnerableRoadUserCondition::mutable_type_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.type_and_confidence)
  return _msg;
}
inline void VulnerableRoadUserCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.type_and_confidence)
}

// -------------------------------------------------------------------

// ECallStatus

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool ECallStatus::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& ECallStatus::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& ECallStatus::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.ECallStatus.envelope)
  return _internal_envelope();
}
inline void ECallStatus::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.ECallStatus.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE ECallStatus::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE ECallStatus::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.ECallStatus.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL ECallStatus::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL ECallStatus::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.ECallStatus.envelope)
  return _msg;
}
inline void ECallStatus::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.ECallStatus.envelope)
}

// .sensoris.protobuf.categories.trafficevents.ECallStatus.ActivationType activation_type = 2;
inline void ECallStatus::clear_activation_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType ECallStatus::activation_type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.ECallStatus.activation_type)
  return _internal_activation_type();
}
inline void ECallStatus::set_activation_type(::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType value) {
  _internal_set_activation_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.ECallStatus.activation_type)
}
inline ::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType ECallStatus::_internal_activation_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType>(_impl_.activation_type_);
}
inline void ECallStatus::_internal_set_activation_type(::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.activation_type_ = value;
}

// .sensoris.protobuf.categories.trafficevents.ECallStatus.Availability availability = 3;
inline void ECallStatus::clear_availability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.availability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability ECallStatus::availability() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.ECallStatus.availability)
  return _internal_availability();
}
inline void ECallStatus::set_availability(::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability value) {
  _internal_set_availability(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.ECallStatus.availability)
}
inline ::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability ECallStatus::_internal_availability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability>(_impl_.availability_);
}
inline void ECallStatus::_internal_set_availability(::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.availability_ = value;
}

// -------------------------------------------------------------------

// RoadFriction

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadFriction::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadFriction::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadFriction::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadFriction.envelope)
  return _internal_envelope();
}
inline void RoadFriction::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadFriction.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE RoadFriction::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE RoadFriction::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadFriction.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL RoadFriction::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NONNULL RoadFriction::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadFriction.envelope)
  return _msg;
}
inline void RoadFriction::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadFriction.envelope)
}

// .sensoris.protobuf.types.base.Int64Value most_probable = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RoadFriction::has_most_probable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.most_probable_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RoadFriction::_internal_most_probable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.most_probable_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RoadFriction::most_probable() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadFriction.most_probable)
  return _internal_most_probable();
}
inline void RoadFriction::unsafe_arena_set_allocated_most_probable(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.most_probable_);
  }
  _impl_.most_probable_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadFriction.most_probable)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RoadFriction::release_most_probable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.most_probable_;
  _impl_.most_probable_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RoadFriction::unsafe_arena_release_most_probable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadFriction.most_probable)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.most_probable_;
  _impl_.most_probable_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RoadFriction::_internal_mutable_most_probable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.most_probable_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.most_probable_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.most_probable_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RoadFriction::mutable_most_probable()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_most_probable();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadFriction.most_probable)
  return _msg;
}
inline void RoadFriction::set_allocated_most_probable(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.most_probable_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.most_probable_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadFriction.most_probable)
}

// .sensoris.protobuf.types.base.Int64Value lower_bound = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RoadFriction::has_lower_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lower_bound_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RoadFriction::_internal_lower_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.lower_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RoadFriction::lower_bound() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadFriction.lower_bound)
  return _internal_lower_bound();
}
inline void RoadFriction::unsafe_arena_set_allocated_lower_bound(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lower_bound_);
  }
  _impl_.lower_bound_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadFriction.lower_bound)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RoadFriction::release_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.lower_bound_;
  _impl_.lower_bound_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RoadFriction::unsafe_arena_release_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadFriction.lower_bound)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.lower_bound_;
  _impl_.lower_bound_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RoadFriction::_internal_mutable_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lower_bound_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.lower_bound_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.lower_bound_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RoadFriction::mutable_lower_bound()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_lower_bound();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadFriction.lower_bound)
  return _msg;
}
inline void RoadFriction::set_allocated_lower_bound(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lower_bound_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.lower_bound_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadFriction.lower_bound)
}

// .sensoris.protobuf.types.base.Int64Value upper_bound = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RoadFriction::has_upper_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.upper_bound_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RoadFriction::_internal_upper_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.upper_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RoadFriction::upper_bound() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadFriction.upper_bound)
  return _internal_upper_bound();
}
inline void RoadFriction::unsafe_arena_set_allocated_upper_bound(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.upper_bound_);
  }
  _impl_.upper_bound_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadFriction.upper_bound)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RoadFriction::release_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.upper_bound_;
  _impl_.upper_bound_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RoadFriction::unsafe_arena_release_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadFriction.upper_bound)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.upper_bound_;
  _impl_.upper_bound_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RoadFriction::_internal_mutable_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.upper_bound_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.upper_bound_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.upper_bound_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RoadFriction::mutable_upper_bound()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_upper_bound();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadFriction.upper_bound)
  return _msg;
}
inline void RoadFriction::set_allocated_upper_bound(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.upper_bound_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.upper_bound_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadFriction.upper_bound)
}

// -------------------------------------------------------------------

// TrafficEventsCategory

// .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
inline bool TrafficEventsCategory::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& TrafficEventsCategory::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::CategoryEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::CategoryEnvelope&>(::sensoris::protobuf::types::base::_CategoryEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& TrafficEventsCategory::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
  return _internal_envelope();
}
inline void TrafficEventsCategory::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE TrafficEventsCategory::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE TrafficEventsCategory::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NONNULL TrafficEventsCategory::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::CategoryEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NONNULL TrafficEventsCategory::mutable_envelope()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
  return _msg;
}
inline void TrafficEventsCategory::set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
}

// repeated .sensoris.protobuf.categories.trafficevents.Hazard hazard = 2;
inline int TrafficEventsCategory::_internal_hazard_size() const {
  return _internal_hazard().size();
}
inline int TrafficEventsCategory::hazard_size() const {
  return _internal_hazard_size();
}
inline void TrafficEventsCategory::clear_hazard() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hazard_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard* PROTOBUF_NONNULL TrafficEventsCategory::mutable_hazard(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return _internal_mutable_hazard()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>* PROTOBUF_NONNULL TrafficEventsCategory::mutable_hazard()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hazard();
}
inline const ::sensoris::protobuf::categories::trafficevents::Hazard& TrafficEventsCategory::hazard(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return _internal_hazard().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard* PROTOBUF_NONNULL TrafficEventsCategory::add_hazard()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::trafficevents::Hazard* _add = _internal_mutable_hazard()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>& TrafficEventsCategory::hazard() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return _internal_hazard();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>&
TrafficEventsCategory::_internal_hazard() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hazard_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>* PROTOBUF_NONNULL
TrafficEventsCategory::_internal_mutable_hazard() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hazard_;
}

// repeated .sensoris.protobuf.categories.trafficevents.DangerousSlowDown dangerous_slow_down = 3;
inline int TrafficEventsCategory::_internal_dangerous_slow_down_size() const {
  return _internal_dangerous_slow_down().size();
}
inline int TrafficEventsCategory::dangerous_slow_down_size() const {
  return _internal_dangerous_slow_down_size();
}
inline void TrafficEventsCategory::clear_dangerous_slow_down() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dangerous_slow_down_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* PROTOBUF_NONNULL TrafficEventsCategory::mutable_dangerous_slow_down(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return _internal_mutable_dangerous_slow_down()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>* PROTOBUF_NONNULL TrafficEventsCategory::mutable_dangerous_slow_down()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dangerous_slow_down();
}
inline const ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown& TrafficEventsCategory::dangerous_slow_down(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return _internal_dangerous_slow_down().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* PROTOBUF_NONNULL TrafficEventsCategory::add_dangerous_slow_down()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* _add = _internal_mutable_dangerous_slow_down()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>& TrafficEventsCategory::dangerous_slow_down() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return _internal_dangerous_slow_down();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>&
TrafficEventsCategory::_internal_dangerous_slow_down() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dangerous_slow_down_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>* PROTOBUF_NONNULL
TrafficEventsCategory::_internal_mutable_dangerous_slow_down() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dangerous_slow_down_;
}

// repeated .sensoris.protobuf.categories.trafficevents.TrafficCondition traffic_condition = 4;
inline int TrafficEventsCategory::_internal_traffic_condition_size() const {
  return _internal_traffic_condition().size();
}
inline int TrafficEventsCategory::traffic_condition_size() const {
  return _internal_traffic_condition_size();
}
inline void TrafficEventsCategory::clear_traffic_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.traffic_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition* PROTOBUF_NONNULL TrafficEventsCategory::mutable_traffic_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return _internal_mutable_traffic_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>* PROTOBUF_NONNULL TrafficEventsCategory::mutable_traffic_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_traffic_condition();
}
inline const ::sensoris::protobuf::categories::trafficevents::TrafficCondition& TrafficEventsCategory::traffic_condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return _internal_traffic_condition().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition* PROTOBUF_NONNULL TrafficEventsCategory::add_traffic_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition* _add = _internal_mutable_traffic_condition()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>& TrafficEventsCategory::traffic_condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return _internal_traffic_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>&
TrafficEventsCategory::_internal_traffic_condition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.traffic_condition_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>* PROTOBUF_NONNULL
TrafficEventsCategory::_internal_mutable_traffic_condition() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.traffic_condition_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadWorks roadworks = 5;
inline int TrafficEventsCategory::_internal_roadworks_size() const {
  return _internal_roadworks().size();
}
inline int TrafficEventsCategory::roadworks_size() const {
  return _internal_roadworks_size();
}
inline void TrafficEventsCategory::clear_roadworks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.roadworks_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks* PROTOBUF_NONNULL TrafficEventsCategory::mutable_roadworks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return _internal_mutable_roadworks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>* PROTOBUF_NONNULL TrafficEventsCategory::mutable_roadworks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_roadworks();
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWorks& TrafficEventsCategory::roadworks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return _internal_roadworks().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks* PROTOBUF_NONNULL TrafficEventsCategory::add_roadworks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::trafficevents::RoadWorks* _add = _internal_mutable_roadworks()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>& TrafficEventsCategory::roadworks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return _internal_roadworks();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>&
TrafficEventsCategory::_internal_roadworks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.roadworks_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>* PROTOBUF_NONNULL
TrafficEventsCategory::_internal_mutable_roadworks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.roadworks_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition road_weather_condition = 6;
inline int TrafficEventsCategory::_internal_road_weather_condition_size() const {
  return _internal_road_weather_condition().size();
}
inline int TrafficEventsCategory::road_weather_condition_size() const {
  return _internal_road_weather_condition_size();
}
inline void TrafficEventsCategory::clear_road_weather_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.road_weather_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* PROTOBUF_NONNULL TrafficEventsCategory::mutable_road_weather_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return _internal_mutable_road_weather_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>* PROTOBUF_NONNULL TrafficEventsCategory::mutable_road_weather_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_road_weather_condition();
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition& TrafficEventsCategory::road_weather_condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return _internal_road_weather_condition().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* PROTOBUF_NONNULL TrafficEventsCategory::add_road_weather_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* _add = _internal_mutable_road_weather_condition()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>& TrafficEventsCategory::road_weather_condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return _internal_road_weather_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>&
TrafficEventsCategory::_internal_road_weather_condition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.road_weather_condition_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>* PROTOBUF_NONNULL
TrafficEventsCategory::_internal_mutable_road_weather_condition() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.road_weather_condition_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition road_surface_condition = 7;
inline int TrafficEventsCategory::_internal_road_surface_condition_size() const {
  return _internal_road_surface_condition().size();
}
inline int TrafficEventsCategory::road_surface_condition_size() const {
  return _internal_road_surface_condition_size();
}
inline void TrafficEventsCategory::clear_road_surface_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.road_surface_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition* PROTOBUF_NONNULL TrafficEventsCategory::mutable_road_surface_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_surface_condition)
  return _internal_mutable_road_surface_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>* PROTOBUF_NONNULL TrafficEventsCategory::mutable_road_surface_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_surface_condition)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_road_surface_condition();
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition& TrafficEventsCategory::road_surface_condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_surface_condition)
  return _internal_road_surface_condition().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition* PROTOBUF_NONNULL TrafficEventsCategory::add_road_surface_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition* _add = _internal_mutable_road_surface_condition()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_surface_condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>& TrafficEventsCategory::road_surface_condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_surface_condition)
  return _internal_road_surface_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>&
TrafficEventsCategory::_internal_road_surface_condition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.road_surface_condition_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>* PROTOBUF_NONNULL
TrafficEventsCategory::_internal_mutable_road_surface_condition() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.road_surface_condition_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadObstructionCondition road_obstruction_condition = 8;
inline int TrafficEventsCategory::_internal_road_obstruction_condition_size() const {
  return _internal_road_obstruction_condition().size();
}
inline int TrafficEventsCategory::road_obstruction_condition_size() const {
  return _internal_road_obstruction_condition_size();
}
inline void TrafficEventsCategory::clear_road_obstruction_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.road_obstruction_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition* PROTOBUF_NONNULL TrafficEventsCategory::mutable_road_obstruction_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_obstruction_condition)
  return _internal_mutable_road_obstruction_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>* PROTOBUF_NONNULL TrafficEventsCategory::mutable_road_obstruction_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_obstruction_condition)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_road_obstruction_condition();
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition& TrafficEventsCategory::road_obstruction_condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_obstruction_condition)
  return _internal_road_obstruction_condition().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition* PROTOBUF_NONNULL TrafficEventsCategory::add_road_obstruction_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition* _add = _internal_mutable_road_obstruction_condition()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_obstruction_condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>& TrafficEventsCategory::road_obstruction_condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_obstruction_condition)
  return _internal_road_obstruction_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>&
TrafficEventsCategory::_internal_road_obstruction_condition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.road_obstruction_condition_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>* PROTOBUF_NONNULL
TrafficEventsCategory::_internal_mutable_road_obstruction_condition() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.road_obstruction_condition_;
}

// repeated .sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition vulnerable_road_user_condition = 9;
inline int TrafficEventsCategory::_internal_vulnerable_road_user_condition_size() const {
  return _internal_vulnerable_road_user_condition().size();
}
inline int TrafficEventsCategory::vulnerable_road_user_condition_size() const {
  return _internal_vulnerable_road_user_condition_size();
}
inline void TrafficEventsCategory::clear_vulnerable_road_user_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vulnerable_road_user_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition* PROTOBUF_NONNULL TrafficEventsCategory::mutable_vulnerable_road_user_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.vulnerable_road_user_condition)
  return _internal_mutable_vulnerable_road_user_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>* PROTOBUF_NONNULL TrafficEventsCategory::mutable_vulnerable_road_user_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.vulnerable_road_user_condition)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vulnerable_road_user_condition();
}
inline const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition& TrafficEventsCategory::vulnerable_road_user_condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.vulnerable_road_user_condition)
  return _internal_vulnerable_road_user_condition().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition* PROTOBUF_NONNULL TrafficEventsCategory::add_vulnerable_road_user_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition* _add = _internal_mutable_vulnerable_road_user_condition()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.vulnerable_road_user_condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>& TrafficEventsCategory::vulnerable_road_user_condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.vulnerable_road_user_condition)
  return _internal_vulnerable_road_user_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>&
TrafficEventsCategory::_internal_vulnerable_road_user_condition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vulnerable_road_user_condition_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>* PROTOBUF_NONNULL
TrafficEventsCategory::_internal_mutable_vulnerable_road_user_condition() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vulnerable_road_user_condition_;
}

// repeated .sensoris.protobuf.categories.trafficevents.ECallStatus e_call_status = 10;
inline int TrafficEventsCategory::_internal_e_call_status_size() const {
  return _internal_e_call_status().size();
}
inline int TrafficEventsCategory::e_call_status_size() const {
  return _internal_e_call_status_size();
}
inline void TrafficEventsCategory::clear_e_call_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.e_call_status_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::ECallStatus* PROTOBUF_NONNULL TrafficEventsCategory::mutable_e_call_status(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.e_call_status)
  return _internal_mutable_e_call_status()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>* PROTOBUF_NONNULL TrafficEventsCategory::mutable_e_call_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.e_call_status)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_e_call_status();
}
inline const ::sensoris::protobuf::categories::trafficevents::ECallStatus& TrafficEventsCategory::e_call_status(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.e_call_status)
  return _internal_e_call_status().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::ECallStatus* PROTOBUF_NONNULL TrafficEventsCategory::add_e_call_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::trafficevents::ECallStatus* _add = _internal_mutable_e_call_status()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.e_call_status)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>& TrafficEventsCategory::e_call_status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.e_call_status)
  return _internal_e_call_status();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>&
TrafficEventsCategory::_internal_e_call_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.e_call_status_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>* PROTOBUF_NONNULL
TrafficEventsCategory::_internal_mutable_e_call_status() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.e_call_status_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadFriction road_friction = 11;
inline int TrafficEventsCategory::_internal_road_friction_size() const {
  return _internal_road_friction().size();
}
inline int TrafficEventsCategory::road_friction_size() const {
  return _internal_road_friction_size();
}
inline void TrafficEventsCategory::clear_road_friction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.road_friction_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadFriction* PROTOBUF_NONNULL TrafficEventsCategory::mutable_road_friction(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_friction)
  return _internal_mutable_road_friction()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadFriction>* PROTOBUF_NONNULL TrafficEventsCategory::mutable_road_friction()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_friction)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_road_friction();
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadFriction& TrafficEventsCategory::road_friction(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_friction)
  return _internal_road_friction().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadFriction* PROTOBUF_NONNULL TrafficEventsCategory::add_road_friction()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::categories::trafficevents::RoadFriction* _add = _internal_mutable_road_friction()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_friction)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadFriction>& TrafficEventsCategory::road_friction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_friction)
  return _internal_road_friction();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadFriction>&
TrafficEventsCategory::_internal_road_friction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.road_friction_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadFriction>* PROTOBUF_NONNULL
TrafficEventsCategory::_internal_mutable_road_friction() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.road_friction_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace trafficevents
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::Hazard_Direction> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::Hazard_Direction>() {
  return ::sensoris::protobuf::categories::trafficevents::Hazard_Direction_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType>() {
  return ::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability>() {
  return ::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto_2epb_2eh
