// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: sensoris/protobuf/types/spatial.proto
// Protobuf C++ Version: 6.31.1

#ifndef sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_2epb_2eh
#define sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/wrappers.pb.h"
#include "sensoris/protobuf/types/base.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
}  // extern "C"
namespace sensoris {
namespace protobuf {
namespace types {
namespace spatial {
class CircleAndAccuracy;
struct CircleAndAccuracyDefaultTypeInternal;
extern CircleAndAccuracyDefaultTypeInternal _CircleAndAccuracy_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CircleAndAccuracy_class_data_;
class DirectedPolylineCorridor;
struct DirectedPolylineCorridorDefaultTypeInternal;
extern DirectedPolylineCorridorDefaultTypeInternal _DirectedPolylineCorridor_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DirectedPolylineCorridor_class_data_;
class MapLocationReference;
struct MapLocationReferenceDefaultTypeInternal;
extern MapLocationReferenceDefaultTypeInternal _MapLocationReference_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MapLocationReference_class_data_;
class MapLocationReference_TileIdLinkIdOffset;
struct MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal;
extern MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal _MapLocationReference_TileIdLinkIdOffset_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MapLocationReference_TileIdLinkIdOffset_class_data_;
class MapLocationReference_TileIdObjectId;
struct MapLocationReference_TileIdObjectIdDefaultTypeInternal;
extern MapLocationReference_TileIdObjectIdDefaultTypeInternal _MapLocationReference_TileIdObjectId_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MapLocationReference_TileIdObjectId_class_data_;
class PolygonAndAccuracy;
struct PolygonAndAccuracyDefaultTypeInternal;
extern PolygonAndAccuracyDefaultTypeInternal _PolygonAndAccuracy_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PolygonAndAccuracy_class_data_;
class PolylineAndAccuracy;
struct PolylineAndAccuracyDefaultTypeInternal;
extern PolylineAndAccuracyDefaultTypeInternal _PolylineAndAccuracy_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PolylineAndAccuracy_class_data_;
class PolylineCorridorAndAccuracy;
struct PolylineCorridorAndAccuracyDefaultTypeInternal;
extern PolylineCorridorAndAccuracyDefaultTypeInternal _PolylineCorridorAndAccuracy_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PolylineCorridorAndAccuracy_class_data_;
class PositionAndAccuracy;
struct PositionAndAccuracyDefaultTypeInternal;
extern PositionAndAccuracyDefaultTypeInternal _PositionAndAccuracy_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_class_data_;
class PositionAndAccuracy_Geographic;
struct PositionAndAccuracy_GeographicDefaultTypeInternal;
extern PositionAndAccuracy_GeographicDefaultTypeInternal _PositionAndAccuracy_Geographic_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_Geographic_class_data_;
class PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev;
struct PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal;
extern PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal _PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_class_data_;
class PositionAndAccuracy_HorizontalVerticalStdDev;
struct PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal;
extern PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal _PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_HorizontalVerticalStdDev_class_data_;
class PositionAndAccuracy_Metric;
struct PositionAndAccuracy_MetricDefaultTypeInternal;
extern PositionAndAccuracy_MetricDefaultTypeInternal _PositionAndAccuracy_Metric_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_Metric_class_data_;
class RectangleAndAccuracy;
struct RectangleAndAccuracyDefaultTypeInternal;
extern RectangleAndAccuracyDefaultTypeInternal _RectangleAndAccuracy_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RectangleAndAccuracy_class_data_;
class RectangularBoxAndAccuracy;
struct RectangularBoxAndAccuracyDefaultTypeInternal;
extern RectangularBoxAndAccuracyDefaultTypeInternal _RectangularBoxAndAccuracy_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RectangularBoxAndAccuracy_class_data_;
class RectangularBoxAndAccuracy_CenterOrientationSize;
struct RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal;
extern RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal _RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RectangularBoxAndAccuracy_CenterOrientationSize_class_data_;
class RectangularBoxAndAccuracy_CornerVectors;
struct RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal;
extern RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal _RectangularBoxAndAccuracy_CornerVectors_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RectangularBoxAndAccuracy_CornerVectors_class_data_;
class RotationAndAccuracy;
struct RotationAndAccuracyDefaultTypeInternal;
extern RotationAndAccuracyDefaultTypeInternal _RotationAndAccuracy_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RotationAndAccuracy_class_data_;
class RotationAndAccuracy_Euler;
struct RotationAndAccuracy_EulerDefaultTypeInternal;
extern RotationAndAccuracy_EulerDefaultTypeInternal _RotationAndAccuracy_Euler_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RotationAndAccuracy_Euler_class_data_;
class RotationAndAccuracy_Quaternion;
struct RotationAndAccuracy_QuaternionDefaultTypeInternal;
extern RotationAndAccuracy_QuaternionDefaultTypeInternal _RotationAndAccuracy_Quaternion_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RotationAndAccuracy_Quaternion_class_data_;
class RotationAndAccuracy_StdDev;
struct RotationAndAccuracy_StdDevDefaultTypeInternal;
extern RotationAndAccuracy_StdDevDefaultTypeInternal _RotationAndAccuracy_StdDev_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RotationAndAccuracy_StdDev_class_data_;
class RotationRateAndAccuracy;
struct RotationRateAndAccuracyDefaultTypeInternal;
extern RotationRateAndAccuracyDefaultTypeInternal _RotationRateAndAccuracy_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RotationRateAndAccuracy_class_data_;
class RotationRateAndAccuracy_StdDev;
struct RotationRateAndAccuracy_StdDevDefaultTypeInternal;
extern RotationRateAndAccuracy_StdDevDefaultTypeInternal _RotationRateAndAccuracy_StdDev_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RotationRateAndAccuracy_StdDev_class_data_;
class XyzVectorAndAccuracy;
struct XyzVectorAndAccuracyDefaultTypeInternal;
extern XyzVectorAndAccuracyDefaultTypeInternal _XyzVectorAndAccuracy_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull XyzVectorAndAccuracy_class_data_;
class XyzVectorAndAccuracy_Metric;
struct XyzVectorAndAccuracy_MetricDefaultTypeInternal;
extern XyzVectorAndAccuracy_MetricDefaultTypeInternal _XyzVectorAndAccuracy_Metric_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull XyzVectorAndAccuracy_Metric_class_data_;
class XyzVectorAndAccuracy_StdDev;
struct XyzVectorAndAccuracy_StdDevDefaultTypeInternal;
extern XyzVectorAndAccuracy_StdDevDefaultTypeInternal _XyzVectorAndAccuracy_StdDev_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull XyzVectorAndAccuracy_StdDev_class_data_;
}  // namespace spatial
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace sensoris {
namespace protobuf {
namespace types {
namespace spatial {

// ===================================================================


// -------------------------------------------------------------------

class XyzVectorAndAccuracy_StdDev final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev) */ {
 public:
  inline XyzVectorAndAccuracy_StdDev() : XyzVectorAndAccuracy_StdDev(nullptr) {}
  ~XyzVectorAndAccuracy_StdDev() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(XyzVectorAndAccuracy_StdDev* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(XyzVectorAndAccuracy_StdDev));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR XyzVectorAndAccuracy_StdDev(::google::protobuf::internal::ConstantInitialized);

  inline XyzVectorAndAccuracy_StdDev(const XyzVectorAndAccuracy_StdDev& from) : XyzVectorAndAccuracy_StdDev(nullptr, from) {}
  inline XyzVectorAndAccuracy_StdDev(XyzVectorAndAccuracy_StdDev&& from) noexcept
      : XyzVectorAndAccuracy_StdDev(nullptr, ::std::move(from)) {}
  inline XyzVectorAndAccuracy_StdDev& operator=(const XyzVectorAndAccuracy_StdDev& from) {
    CopyFrom(from);
    return *this;
  }
  inline XyzVectorAndAccuracy_StdDev& operator=(XyzVectorAndAccuracy_StdDev&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XyzVectorAndAccuracy_StdDev& default_instance() {
    return *reinterpret_cast<const XyzVectorAndAccuracy_StdDev*>(
        &_XyzVectorAndAccuracy_StdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(XyzVectorAndAccuracy_StdDev& a, XyzVectorAndAccuracy_StdDev& b) { a.Swap(&b); }
  inline void Swap(XyzVectorAndAccuracy_StdDev* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XyzVectorAndAccuracy_StdDev* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XyzVectorAndAccuracy_StdDev* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<XyzVectorAndAccuracy_StdDev>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XyzVectorAndAccuracy_StdDev& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const XyzVectorAndAccuracy_StdDev& from) { XyzVectorAndAccuracy_StdDev::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(XyzVectorAndAccuracy_StdDev* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev"; }

 protected:
  explicit XyzVectorAndAccuracy_StdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  XyzVectorAndAccuracy_StdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const XyzVectorAndAccuracy_StdDev& from);
  XyzVectorAndAccuracy_StdDev(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, XyzVectorAndAccuracy_StdDev&& from) noexcept
      : XyzVectorAndAccuracy_StdDev(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .google.protobuf.Int64Value x = 1;
  bool has_x() const;
  void clear_x() ;
  const ::google::protobuf::Int64Value& x() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_x();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_x();
  void set_allocated_x(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_x(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_x();

  private:
  const ::google::protobuf::Int64Value& _internal_x() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_x();

  public:
  // .google.protobuf.Int64Value y = 2;
  bool has_y() const;
  void clear_y() ;
  const ::google::protobuf::Int64Value& y() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_y();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_y();
  void set_allocated_y(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_y(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_y();

  private:
  const ::google::protobuf::Int64Value& _internal_y() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_y();

  public:
  // .google.protobuf.Int64Value z = 3;
  bool has_z() const;
  void clear_z() ;
  const ::google::protobuf::Int64Value& z() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_z();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_z();
  void set_allocated_z(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_z(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_z();

  private:
  const ::google::protobuf::Int64Value& _internal_z() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_z();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const XyzVectorAndAccuracy_StdDev& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE x_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE y_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull XyzVectorAndAccuracy_StdDev_class_data_;
// -------------------------------------------------------------------

class RotationRateAndAccuracy_StdDev final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev) */ {
 public:
  inline RotationRateAndAccuracy_StdDev() : RotationRateAndAccuracy_StdDev(nullptr) {}
  ~RotationRateAndAccuracy_StdDev() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RotationRateAndAccuracy_StdDev* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RotationRateAndAccuracy_StdDev));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RotationRateAndAccuracy_StdDev(::google::protobuf::internal::ConstantInitialized);

  inline RotationRateAndAccuracy_StdDev(const RotationRateAndAccuracy_StdDev& from) : RotationRateAndAccuracy_StdDev(nullptr, from) {}
  inline RotationRateAndAccuracy_StdDev(RotationRateAndAccuracy_StdDev&& from) noexcept
      : RotationRateAndAccuracy_StdDev(nullptr, ::std::move(from)) {}
  inline RotationRateAndAccuracy_StdDev& operator=(const RotationRateAndAccuracy_StdDev& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationRateAndAccuracy_StdDev& operator=(RotationRateAndAccuracy_StdDev&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationRateAndAccuracy_StdDev& default_instance() {
    return *reinterpret_cast<const RotationRateAndAccuracy_StdDev*>(
        &_RotationRateAndAccuracy_StdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(RotationRateAndAccuracy_StdDev& a, RotationRateAndAccuracy_StdDev& b) { a.Swap(&b); }
  inline void Swap(RotationRateAndAccuracy_StdDev* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationRateAndAccuracy_StdDev* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationRateAndAccuracy_StdDev* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RotationRateAndAccuracy_StdDev>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RotationRateAndAccuracy_StdDev& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RotationRateAndAccuracy_StdDev& from) { RotationRateAndAccuracy_StdDev::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RotationRateAndAccuracy_StdDev* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev"; }

 protected:
  explicit RotationRateAndAccuracy_StdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RotationRateAndAccuracy_StdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RotationRateAndAccuracy_StdDev& from);
  RotationRateAndAccuracy_StdDev(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RotationRateAndAccuracy_StdDev&& from) noexcept
      : RotationRateAndAccuracy_StdDev(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kYawFieldNumber = 1,
    kPitchFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_yaw() const;
  void clear_yaw() ;
  const ::google::protobuf::Int64Value& yaw() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_yaw();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_yaw();
  void set_allocated_yaw(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_yaw(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_yaw();

  private:
  const ::google::protobuf::Int64Value& _internal_yaw() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_yaw();

  public:
  // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pitch() const;
  void clear_pitch() ;
  const ::google::protobuf::Int64Value& pitch() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_pitch();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_pitch();
  void set_allocated_pitch(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pitch(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_pitch();

  private:
  const ::google::protobuf::Int64Value& _internal_pitch() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_pitch();

  public:
  // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_roll() const;
  void clear_roll() ;
  const ::google::protobuf::Int64Value& roll() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_roll();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_roll();
  void set_allocated_roll(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_roll(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_roll();

  private:
  const ::google::protobuf::Int64Value& _internal_roll() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_roll();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RotationRateAndAccuracy_StdDev& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE yaw_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE pitch_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE roll_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RotationRateAndAccuracy_StdDev_class_data_;
// -------------------------------------------------------------------

class RotationAndAccuracy_StdDev final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev) */ {
 public:
  inline RotationAndAccuracy_StdDev() : RotationAndAccuracy_StdDev(nullptr) {}
  ~RotationAndAccuracy_StdDev() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RotationAndAccuracy_StdDev* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RotationAndAccuracy_StdDev));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RotationAndAccuracy_StdDev(::google::protobuf::internal::ConstantInitialized);

  inline RotationAndAccuracy_StdDev(const RotationAndAccuracy_StdDev& from) : RotationAndAccuracy_StdDev(nullptr, from) {}
  inline RotationAndAccuracy_StdDev(RotationAndAccuracy_StdDev&& from) noexcept
      : RotationAndAccuracy_StdDev(nullptr, ::std::move(from)) {}
  inline RotationAndAccuracy_StdDev& operator=(const RotationAndAccuracy_StdDev& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationAndAccuracy_StdDev& operator=(RotationAndAccuracy_StdDev&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationAndAccuracy_StdDev& default_instance() {
    return *reinterpret_cast<const RotationAndAccuracy_StdDev*>(
        &_RotationAndAccuracy_StdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(RotationAndAccuracy_StdDev& a, RotationAndAccuracy_StdDev& b) { a.Swap(&b); }
  inline void Swap(RotationAndAccuracy_StdDev* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationAndAccuracy_StdDev* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationAndAccuracy_StdDev* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RotationAndAccuracy_StdDev>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RotationAndAccuracy_StdDev& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RotationAndAccuracy_StdDev& from) { RotationAndAccuracy_StdDev::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RotationAndAccuracy_StdDev* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev"; }

 protected:
  explicit RotationAndAccuracy_StdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RotationAndAccuracy_StdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RotationAndAccuracy_StdDev& from);
  RotationAndAccuracy_StdDev(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RotationAndAccuracy_StdDev&& from) noexcept
      : RotationAndAccuracy_StdDev(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kYawFieldNumber = 1,
    kPitchFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_yaw() const;
  void clear_yaw() ;
  const ::google::protobuf::Int64Value& yaw() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_yaw();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_yaw();
  void set_allocated_yaw(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_yaw(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_yaw();

  private:
  const ::google::protobuf::Int64Value& _internal_yaw() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_yaw();

  public:
  // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pitch() const;
  void clear_pitch() ;
  const ::google::protobuf::Int64Value& pitch() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_pitch();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_pitch();
  void set_allocated_pitch(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pitch(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_pitch();

  private:
  const ::google::protobuf::Int64Value& _internal_pitch() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_pitch();

  public:
  // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_roll() const;
  void clear_roll() ;
  const ::google::protobuf::Int64Value& roll() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_roll();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_roll();
  void set_allocated_roll(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_roll(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_roll();

  private:
  const ::google::protobuf::Int64Value& _internal_roll() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_roll();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RotationAndAccuracy_StdDev& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE yaw_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE pitch_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE roll_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RotationAndAccuracy_StdDev_class_data_;
// -------------------------------------------------------------------

class PositionAndAccuracy_HorizontalVerticalStdDev final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev) */ {
 public:
  inline PositionAndAccuracy_HorizontalVerticalStdDev() : PositionAndAccuracy_HorizontalVerticalStdDev(nullptr) {}
  ~PositionAndAccuracy_HorizontalVerticalStdDev() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PositionAndAccuracy_HorizontalVerticalStdDev));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PositionAndAccuracy_HorizontalVerticalStdDev(::google::protobuf::internal::ConstantInitialized);

  inline PositionAndAccuracy_HorizontalVerticalStdDev(const PositionAndAccuracy_HorizontalVerticalStdDev& from) : PositionAndAccuracy_HorizontalVerticalStdDev(nullptr, from) {}
  inline PositionAndAccuracy_HorizontalVerticalStdDev(PositionAndAccuracy_HorizontalVerticalStdDev&& from) noexcept
      : PositionAndAccuracy_HorizontalVerticalStdDev(nullptr, ::std::move(from)) {}
  inline PositionAndAccuracy_HorizontalVerticalStdDev& operator=(const PositionAndAccuracy_HorizontalVerticalStdDev& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionAndAccuracy_HorizontalVerticalStdDev& operator=(PositionAndAccuracy_HorizontalVerticalStdDev&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionAndAccuracy_HorizontalVerticalStdDev& default_instance() {
    return *reinterpret_cast<const PositionAndAccuracy_HorizontalVerticalStdDev*>(
        &_PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(PositionAndAccuracy_HorizontalVerticalStdDev& a, PositionAndAccuracy_HorizontalVerticalStdDev& b) { a.Swap(&b); }
  inline void Swap(PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PositionAndAccuracy_HorizontalVerticalStdDev>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionAndAccuracy_HorizontalVerticalStdDev& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PositionAndAccuracy_HorizontalVerticalStdDev& from) { PositionAndAccuracy_HorizontalVerticalStdDev::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev"; }

 protected:
  explicit PositionAndAccuracy_HorizontalVerticalStdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PositionAndAccuracy_HorizontalVerticalStdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PositionAndAccuracy_HorizontalVerticalStdDev& from);
  PositionAndAccuracy_HorizontalVerticalStdDev(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PositionAndAccuracy_HorizontalVerticalStdDev&& from) noexcept
      : PositionAndAccuracy_HorizontalVerticalStdDev(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHorizontalFieldNumber = 1,
    kVerticalFieldNumber = 2,
  };
  // .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_horizontal() const;
  void clear_horizontal() ;
  const ::google::protobuf::Int64Value& horizontal() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_horizontal();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_horizontal();
  void set_allocated_horizontal(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_horizontal(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_horizontal();

  private:
  const ::google::protobuf::Int64Value& _internal_horizontal() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_horizontal();

  public:
  // .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_vertical() const;
  void clear_vertical() ;
  const ::google::protobuf::Int64Value& vertical() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_vertical();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_vertical();
  void set_allocated_vertical(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vertical(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_vertical();

  private:
  const ::google::protobuf::Int64Value& _internal_vertical() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_vertical();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PositionAndAccuracy_HorizontalVerticalStdDev& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE horizontal_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE vertical_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_HorizontalVerticalStdDev_class_data_;
// -------------------------------------------------------------------

class PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev) */ {
 public:
  inline PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev() : PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(nullptr) {}
  ~PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(::google::protobuf::internal::ConstantInitialized);

  inline PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from) : PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(nullptr, from) {}
  inline PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&& from) noexcept
      : PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(nullptr, ::std::move(from)) {}
  inline PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& operator=(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& operator=(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& default_instance() {
    return *reinterpret_cast<const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev*>(
        &_PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& a, PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& b) { a.Swap(&b); }
  inline void Swap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from) { PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev"; }

 protected:
  explicit PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from);
  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&& from) noexcept
      : PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHorizontalEllipseMajorFieldNumber = 1,
    kHorizontalEllipseMinorFieldNumber = 2,
    kHorizontalEllipseMajorHeadingFieldNumber = 3,
    kVerticalFieldNumber = 4,
  };
  // .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_horizontal_ellipse_major() const;
  void clear_horizontal_ellipse_major() ;
  const ::google::protobuf::Int64Value& horizontal_ellipse_major() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_horizontal_ellipse_major();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_horizontal_ellipse_major();
  void set_allocated_horizontal_ellipse_major(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_horizontal_ellipse_major(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_horizontal_ellipse_major();

  private:
  const ::google::protobuf::Int64Value& _internal_horizontal_ellipse_major() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_horizontal_ellipse_major();

  public:
  // .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_horizontal_ellipse_minor() const;
  void clear_horizontal_ellipse_minor() ;
  const ::google::protobuf::Int64Value& horizontal_ellipse_minor() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_horizontal_ellipse_minor();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_horizontal_ellipse_minor();
  void set_allocated_horizontal_ellipse_minor(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_horizontal_ellipse_minor(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_horizontal_ellipse_minor();

  private:
  const ::google::protobuf::Int64Value& _internal_horizontal_ellipse_minor() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_horizontal_ellipse_minor();

  public:
  // .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_horizontal_ellipse_major_heading() const;
  void clear_horizontal_ellipse_major_heading() ;
  const ::google::protobuf::Int64Value& horizontal_ellipse_major_heading() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_horizontal_ellipse_major_heading();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_horizontal_ellipse_major_heading();
  void set_allocated_horizontal_ellipse_major_heading(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_horizontal_ellipse_major_heading(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_horizontal_ellipse_major_heading();

  private:
  const ::google::protobuf::Int64Value& _internal_horizontal_ellipse_major_heading() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_horizontal_ellipse_major_heading();

  public:
  // .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_vertical() const;
  void clear_vertical() ;
  const ::google::protobuf::Int64Value& vertical() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_vertical();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_vertical();
  void set_allocated_vertical(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vertical(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_vertical();

  private:
  const ::google::protobuf::Int64Value& _internal_vertical() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_vertical();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE horizontal_ellipse_major_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE horizontal_ellipse_minor_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE horizontal_ellipse_major_heading_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE vertical_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_class_data_;
// -------------------------------------------------------------------

class MapLocationReference_TileIdObjectId final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId) */ {
 public:
  inline MapLocationReference_TileIdObjectId() : MapLocationReference_TileIdObjectId(nullptr) {}
  ~MapLocationReference_TileIdObjectId() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MapLocationReference_TileIdObjectId* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MapLocationReference_TileIdObjectId));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MapLocationReference_TileIdObjectId(::google::protobuf::internal::ConstantInitialized);

  inline MapLocationReference_TileIdObjectId(const MapLocationReference_TileIdObjectId& from) : MapLocationReference_TileIdObjectId(nullptr, from) {}
  inline MapLocationReference_TileIdObjectId(MapLocationReference_TileIdObjectId&& from) noexcept
      : MapLocationReference_TileIdObjectId(nullptr, ::std::move(from)) {}
  inline MapLocationReference_TileIdObjectId& operator=(const MapLocationReference_TileIdObjectId& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapLocationReference_TileIdObjectId& operator=(MapLocationReference_TileIdObjectId&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapLocationReference_TileIdObjectId& default_instance() {
    return *reinterpret_cast<const MapLocationReference_TileIdObjectId*>(
        &_MapLocationReference_TileIdObjectId_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(MapLocationReference_TileIdObjectId& a, MapLocationReference_TileIdObjectId& b) { a.Swap(&b); }
  inline void Swap(MapLocationReference_TileIdObjectId* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapLocationReference_TileIdObjectId* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapLocationReference_TileIdObjectId* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MapLocationReference_TileIdObjectId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MapLocationReference_TileIdObjectId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MapLocationReference_TileIdObjectId& from) { MapLocationReference_TileIdObjectId::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MapLocationReference_TileIdObjectId* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId"; }

 protected:
  explicit MapLocationReference_TileIdObjectId(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MapLocationReference_TileIdObjectId(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MapLocationReference_TileIdObjectId& from);
  MapLocationReference_TileIdObjectId(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MapLocationReference_TileIdObjectId&& from) noexcept
      : MapLocationReference_TileIdObjectId(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kTileIdFieldNumber = 1,
    kObjectIdFieldNumber = 2,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .google.protobuf.Int64Value tile_id = 1;
  bool has_tile_id() const;
  void clear_tile_id() ;
  const ::google::protobuf::Int64Value& tile_id() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_tile_id();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_tile_id();
  void set_allocated_tile_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tile_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_tile_id();

  private:
  const ::google::protobuf::Int64Value& _internal_tile_id() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_tile_id();

  public:
  // .google.protobuf.Int64Value object_id = 2;
  bool has_object_id() const;
  void clear_object_id() ;
  const ::google::protobuf::Int64Value& object_id() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_object_id();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_object_id();
  void set_allocated_object_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_object_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_object_id();

  private:
  const ::google::protobuf::Int64Value& _internal_object_id() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_object_id();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MapLocationReference_TileIdObjectId& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE tile_id_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE object_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MapLocationReference_TileIdObjectId_class_data_;
// -------------------------------------------------------------------

class MapLocationReference_TileIdLinkIdOffset final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset) */ {
 public:
  inline MapLocationReference_TileIdLinkIdOffset() : MapLocationReference_TileIdLinkIdOffset(nullptr) {}
  ~MapLocationReference_TileIdLinkIdOffset() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MapLocationReference_TileIdLinkIdOffset));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MapLocationReference_TileIdLinkIdOffset(::google::protobuf::internal::ConstantInitialized);

  inline MapLocationReference_TileIdLinkIdOffset(const MapLocationReference_TileIdLinkIdOffset& from) : MapLocationReference_TileIdLinkIdOffset(nullptr, from) {}
  inline MapLocationReference_TileIdLinkIdOffset(MapLocationReference_TileIdLinkIdOffset&& from) noexcept
      : MapLocationReference_TileIdLinkIdOffset(nullptr, ::std::move(from)) {}
  inline MapLocationReference_TileIdLinkIdOffset& operator=(const MapLocationReference_TileIdLinkIdOffset& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapLocationReference_TileIdLinkIdOffset& operator=(MapLocationReference_TileIdLinkIdOffset&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapLocationReference_TileIdLinkIdOffset& default_instance() {
    return *reinterpret_cast<const MapLocationReference_TileIdLinkIdOffset*>(
        &_MapLocationReference_TileIdLinkIdOffset_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(MapLocationReference_TileIdLinkIdOffset& a, MapLocationReference_TileIdLinkIdOffset& b) { a.Swap(&b); }
  inline void Swap(MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MapLocationReference_TileIdLinkIdOffset>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MapLocationReference_TileIdLinkIdOffset& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MapLocationReference_TileIdLinkIdOffset& from) { MapLocationReference_TileIdLinkIdOffset::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset"; }

 protected:
  explicit MapLocationReference_TileIdLinkIdOffset(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MapLocationReference_TileIdLinkIdOffset(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MapLocationReference_TileIdLinkIdOffset& from);
  MapLocationReference_TileIdLinkIdOffset(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MapLocationReference_TileIdLinkIdOffset&& from) noexcept
      : MapLocationReference_TileIdLinkIdOffset(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kTileIdFieldNumber = 1,
    kLinkIdFieldNumber = 2,
    kOffsetFieldNumber = 3,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .google.protobuf.Int64Value tile_id = 1;
  bool has_tile_id() const;
  void clear_tile_id() ;
  const ::google::protobuf::Int64Value& tile_id() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_tile_id();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_tile_id();
  void set_allocated_tile_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tile_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_tile_id();

  private:
  const ::google::protobuf::Int64Value& _internal_tile_id() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_tile_id();

  public:
  // .google.protobuf.Int64Value link_id = 2;
  bool has_link_id() const;
  void clear_link_id() ;
  const ::google::protobuf::Int64Value& link_id() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_link_id();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_link_id();
  void set_allocated_link_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_link_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_link_id();

  private:
  const ::google::protobuf::Int64Value& _internal_link_id() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_link_id();

  public:
  // .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_offset() const;
  void clear_offset() ;
  const ::google::protobuf::Int64Value& offset() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_offset();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_offset();
  void set_allocated_offset(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_offset(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_offset();

  private:
  const ::google::protobuf::Int64Value& _internal_offset() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_offset();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MapLocationReference_TileIdLinkIdOffset& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE tile_id_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE link_id_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MapLocationReference_TileIdLinkIdOffset_class_data_;
// -------------------------------------------------------------------

class XyzVectorAndAccuracy_Metric final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric) */ {
 public:
  inline XyzVectorAndAccuracy_Metric() : XyzVectorAndAccuracy_Metric(nullptr) {}
  ~XyzVectorAndAccuracy_Metric() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(XyzVectorAndAccuracy_Metric));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR XyzVectorAndAccuracy_Metric(::google::protobuf::internal::ConstantInitialized);

  inline XyzVectorAndAccuracy_Metric(const XyzVectorAndAccuracy_Metric& from) : XyzVectorAndAccuracy_Metric(nullptr, from) {}
  inline XyzVectorAndAccuracy_Metric(XyzVectorAndAccuracy_Metric&& from) noexcept
      : XyzVectorAndAccuracy_Metric(nullptr, ::std::move(from)) {}
  inline XyzVectorAndAccuracy_Metric& operator=(const XyzVectorAndAccuracy_Metric& from) {
    CopyFrom(from);
    return *this;
  }
  inline XyzVectorAndAccuracy_Metric& operator=(XyzVectorAndAccuracy_Metric&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XyzVectorAndAccuracy_Metric& default_instance() {
    return *reinterpret_cast<const XyzVectorAndAccuracy_Metric*>(
        &_XyzVectorAndAccuracy_Metric_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(XyzVectorAndAccuracy_Metric& a, XyzVectorAndAccuracy_Metric& b) { a.Swap(&b); }
  inline void Swap(XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<XyzVectorAndAccuracy_Metric>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XyzVectorAndAccuracy_Metric& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const XyzVectorAndAccuracy_Metric& from) { XyzVectorAndAccuracy_Metric::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric"; }

 protected:
  explicit XyzVectorAndAccuracy_Metric(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  XyzVectorAndAccuracy_Metric(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const XyzVectorAndAccuracy_Metric& from);
  XyzVectorAndAccuracy_Metric(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, XyzVectorAndAccuracy_Metric&& from) noexcept
      : XyzVectorAndAccuracy_Metric(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.Int64Value x = 1;
  bool has_x() const;
  void clear_x() ;
  const ::sensoris::protobuf::types::base::Int64Value& x() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_x();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_x();
  void set_allocated_x(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_x(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_x();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_x() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_x();

  public:
  // .sensoris.protobuf.types.base.Int64Value y = 2;
  bool has_y() const;
  void clear_y() ;
  const ::sensoris::protobuf::types::base::Int64Value& y() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_y();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_y();
  void set_allocated_y(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_y(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_y();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_y() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_y();

  public:
  // .sensoris.protobuf.types.base.Int64Value z = 3;
  bool has_z() const;
  void clear_z() ;
  const ::sensoris::protobuf::types::base::Int64Value& z() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_z();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_z();
  void set_allocated_z(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_z(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_z();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_z() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_z();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const XyzVectorAndAccuracy_Metric& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE x_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE y_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull XyzVectorAndAccuracy_Metric_class_data_;
// -------------------------------------------------------------------

class RotationRateAndAccuracy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationRateAndAccuracy) */ {
 public:
  inline RotationRateAndAccuracy() : RotationRateAndAccuracy(nullptr) {}
  ~RotationRateAndAccuracy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RotationRateAndAccuracy* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RotationRateAndAccuracy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RotationRateAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline RotationRateAndAccuracy(const RotationRateAndAccuracy& from) : RotationRateAndAccuracy(nullptr, from) {}
  inline RotationRateAndAccuracy(RotationRateAndAccuracy&& from) noexcept
      : RotationRateAndAccuracy(nullptr, ::std::move(from)) {}
  inline RotationRateAndAccuracy& operator=(const RotationRateAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationRateAndAccuracy& operator=(RotationRateAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationRateAndAccuracy& default_instance() {
    return *reinterpret_cast<const RotationRateAndAccuracy*>(
        &_RotationRateAndAccuracy_default_instance_);
  }
  enum AccuracyCase {
    kCombinedStdDev = 4,
    kStdDev = 5,
    kCovariance = 6,
    ACCURACY_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(RotationRateAndAccuracy& a, RotationRateAndAccuracy& b) { a.Swap(&b); }
  inline void Swap(RotationRateAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationRateAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationRateAndAccuracy* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RotationRateAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RotationRateAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RotationRateAndAccuracy& from) { RotationRateAndAccuracy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RotationRateAndAccuracy* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.RotationRateAndAccuracy"; }

 protected:
  explicit RotationRateAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RotationRateAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RotationRateAndAccuracy& from);
  RotationRateAndAccuracy(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RotationRateAndAccuracy&& from) noexcept
      : RotationRateAndAccuracy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using StdDev = RotationRateAndAccuracy_StdDev;

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kYawFieldNumber = 1,
    kPitchFieldNumber = 2,
    kRollFieldNumber = 3,
    kCombinedStdDevFieldNumber = 4,
    kStdDevFieldNumber = 5,
    kCovarianceFieldNumber = 6,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_yaw() const;
  void clear_yaw() ;
  const ::sensoris::protobuf::types::base::Int64Value& yaw() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_yaw();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_yaw();
  void set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_yaw();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_yaw() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_yaw();

  public:
  // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pitch() const;
  void clear_pitch() ;
  const ::sensoris::protobuf::types::base::Int64Value& pitch() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_pitch();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_pitch();
  void set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_pitch();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_pitch() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_pitch();

  public:
  // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_roll() const;
  void clear_roll() ;
  const ::sensoris::protobuf::types::base::Int64Value& roll() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_roll();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_roll();
  void set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_roll();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_roll() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_roll();

  public:
  // .google.protobuf.Int64Value combined_std_dev = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_combined_std_dev() const;
  private:
  bool _internal_has_combined_std_dev() const;

  public:
  void clear_combined_std_dev() ;
  const ::google::protobuf::Int64Value& combined_std_dev() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_combined_std_dev();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_combined_std_dev();
  void set_allocated_combined_std_dev(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_combined_std_dev();

  private:
  const ::google::protobuf::Int64Value& _internal_combined_std_dev() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_combined_std_dev();

  public:
  // .sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev std_dev = 5;
  bool has_std_dev() const;
  private:
  bool _internal_has_std_dev() const;

  public:
  void clear_std_dev() ;
  const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& std_dev() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* PROTOBUF_NULLABLE release_std_dev();
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* PROTOBUF_NONNULL mutable_std_dev();
  void set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* PROTOBUF_NULLABLE unsafe_arena_release_std_dev();

  private:
  const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& _internal_std_dev() const;
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* PROTOBUF_NONNULL _internal_mutable_std_dev();

  public:
  // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_covariance() const;
  private:
  bool _internal_has_covariance() const;

  public:
  void clear_covariance() ;
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE release_covariance();
  ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL mutable_covariance();
  void set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE unsafe_arena_release_covariance();

  private:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& _internal_covariance() const;
  ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL _internal_mutable_covariance();

  public:
  void clear_accuracy();
  AccuracyCase accuracy_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
 private:
  class _Internal;
  void set_has_combined_std_dev();
  void set_has_std_dev();
  void set_has_covariance();
  inline bool has_accuracy() const;
  inline void clear_has_accuracy();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   7, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RotationRateAndAccuracy& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE yaw_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE pitch_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE roll_;
    union AccuracyUnion {
      constexpr AccuracyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE combined_std_dev_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE std_dev_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE covariance_;
    } accuracy_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RotationRateAndAccuracy_class_data_;
// -------------------------------------------------------------------

class RotationAndAccuracy_Quaternion final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion) */ {
 public:
  inline RotationAndAccuracy_Quaternion() : RotationAndAccuracy_Quaternion(nullptr) {}
  ~RotationAndAccuracy_Quaternion() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RotationAndAccuracy_Quaternion));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RotationAndAccuracy_Quaternion(::google::protobuf::internal::ConstantInitialized);

  inline RotationAndAccuracy_Quaternion(const RotationAndAccuracy_Quaternion& from) : RotationAndAccuracy_Quaternion(nullptr, from) {}
  inline RotationAndAccuracy_Quaternion(RotationAndAccuracy_Quaternion&& from) noexcept
      : RotationAndAccuracy_Quaternion(nullptr, ::std::move(from)) {}
  inline RotationAndAccuracy_Quaternion& operator=(const RotationAndAccuracy_Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationAndAccuracy_Quaternion& operator=(RotationAndAccuracy_Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationAndAccuracy_Quaternion& default_instance() {
    return *reinterpret_cast<const RotationAndAccuracy_Quaternion*>(
        &_RotationAndAccuracy_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(RotationAndAccuracy_Quaternion& a, RotationAndAccuracy_Quaternion& b) { a.Swap(&b); }
  inline void Swap(RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RotationAndAccuracy_Quaternion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RotationAndAccuracy_Quaternion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RotationAndAccuracy_Quaternion& from) { RotationAndAccuracy_Quaternion::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion"; }

 protected:
  explicit RotationAndAccuracy_Quaternion(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RotationAndAccuracy_Quaternion(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RotationAndAccuracy_Quaternion& from);
  RotationAndAccuracy_Quaternion(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RotationAndAccuracy_Quaternion&& from) noexcept
      : RotationAndAccuracy_Quaternion(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_x() const;
  void clear_x() ;
  const ::sensoris::protobuf::types::base::Int64Value& x() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_x();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_x();
  void set_allocated_x(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_x(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_x();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_x() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_x();

  public:
  // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_y() const;
  void clear_y() ;
  const ::sensoris::protobuf::types::base::Int64Value& y() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_y();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_y();
  void set_allocated_y(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_y(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_y();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_y() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_y();

  public:
  // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_z() const;
  void clear_z() ;
  const ::sensoris::protobuf::types::base::Int64Value& z() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_z();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_z();
  void set_allocated_z(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_z(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_z();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_z() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_z();

  public:
  // .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_w() const;
  void clear_w() ;
  const ::sensoris::protobuf::types::base::Int64Value& w() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_w();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_w();
  void set_allocated_w(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_w(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_w();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_w() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_w();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RotationAndAccuracy_Quaternion& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE x_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE y_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE z_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE w_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RotationAndAccuracy_Quaternion_class_data_;
// -------------------------------------------------------------------

class RotationAndAccuracy_Euler final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler) */ {
 public:
  inline RotationAndAccuracy_Euler() : RotationAndAccuracy_Euler(nullptr) {}
  ~RotationAndAccuracy_Euler() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RotationAndAccuracy_Euler* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RotationAndAccuracy_Euler));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RotationAndAccuracy_Euler(::google::protobuf::internal::ConstantInitialized);

  inline RotationAndAccuracy_Euler(const RotationAndAccuracy_Euler& from) : RotationAndAccuracy_Euler(nullptr, from) {}
  inline RotationAndAccuracy_Euler(RotationAndAccuracy_Euler&& from) noexcept
      : RotationAndAccuracy_Euler(nullptr, ::std::move(from)) {}
  inline RotationAndAccuracy_Euler& operator=(const RotationAndAccuracy_Euler& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationAndAccuracy_Euler& operator=(RotationAndAccuracy_Euler&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationAndAccuracy_Euler& default_instance() {
    return *reinterpret_cast<const RotationAndAccuracy_Euler*>(
        &_RotationAndAccuracy_Euler_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(RotationAndAccuracy_Euler& a, RotationAndAccuracy_Euler& b) { a.Swap(&b); }
  inline void Swap(RotationAndAccuracy_Euler* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationAndAccuracy_Euler* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationAndAccuracy_Euler* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RotationAndAccuracy_Euler>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RotationAndAccuracy_Euler& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RotationAndAccuracy_Euler& from) { RotationAndAccuracy_Euler::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RotationAndAccuracy_Euler* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler"; }

 protected:
  explicit RotationAndAccuracy_Euler(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RotationAndAccuracy_Euler(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RotationAndAccuracy_Euler& from);
  RotationAndAccuracy_Euler(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RotationAndAccuracy_Euler&& from) noexcept
      : RotationAndAccuracy_Euler(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kYawFieldNumber = 1,
    kPitchFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_yaw() const;
  void clear_yaw() ;
  const ::sensoris::protobuf::types::base::Int64Value& yaw() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_yaw();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_yaw();
  void set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_yaw();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_yaw() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_yaw();

  public:
  // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pitch() const;
  void clear_pitch() ;
  const ::sensoris::protobuf::types::base::Int64Value& pitch() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_pitch();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_pitch();
  void set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_pitch();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_pitch() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_pitch();

  public:
  // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_roll() const;
  void clear_roll() ;
  const ::sensoris::protobuf::types::base::Int64Value& roll() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_roll();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_roll();
  void set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_roll();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_roll() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_roll();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RotationAndAccuracy_Euler& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE yaw_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE pitch_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE roll_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RotationAndAccuracy_Euler_class_data_;
// -------------------------------------------------------------------

class PositionAndAccuracy_Metric final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric) */ {
 public:
  inline PositionAndAccuracy_Metric() : PositionAndAccuracy_Metric(nullptr) {}
  ~PositionAndAccuracy_Metric() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PositionAndAccuracy_Metric* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PositionAndAccuracy_Metric));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PositionAndAccuracy_Metric(::google::protobuf::internal::ConstantInitialized);

  inline PositionAndAccuracy_Metric(const PositionAndAccuracy_Metric& from) : PositionAndAccuracy_Metric(nullptr, from) {}
  inline PositionAndAccuracy_Metric(PositionAndAccuracy_Metric&& from) noexcept
      : PositionAndAccuracy_Metric(nullptr, ::std::move(from)) {}
  inline PositionAndAccuracy_Metric& operator=(const PositionAndAccuracy_Metric& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionAndAccuracy_Metric& operator=(PositionAndAccuracy_Metric&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionAndAccuracy_Metric& default_instance() {
    return *reinterpret_cast<const PositionAndAccuracy_Metric*>(
        &_PositionAndAccuracy_Metric_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(PositionAndAccuracy_Metric& a, PositionAndAccuracy_Metric& b) { a.Swap(&b); }
  inline void Swap(PositionAndAccuracy_Metric* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionAndAccuracy_Metric* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionAndAccuracy_Metric* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PositionAndAccuracy_Metric>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionAndAccuracy_Metric& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PositionAndAccuracy_Metric& from) { PositionAndAccuracy_Metric::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PositionAndAccuracy_Metric* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric"; }

 protected:
  explicit PositionAndAccuracy_Metric(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PositionAndAccuracy_Metric(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PositionAndAccuracy_Metric& from);
  PositionAndAccuracy_Metric(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PositionAndAccuracy_Metric&& from) noexcept
      : PositionAndAccuracy_Metric(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_x() const;
  void clear_x() ;
  const ::sensoris::protobuf::types::base::Int64Value& x() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_x();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_x();
  void set_allocated_x(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_x(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_x();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_x() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_x();

  public:
  // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_y() const;
  void clear_y() ;
  const ::sensoris::protobuf::types::base::Int64Value& y() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_y();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_y();
  void set_allocated_y(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_y(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_y();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_y() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_y();

  public:
  // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_z() const;
  void clear_z() ;
  const ::sensoris::protobuf::types::base::Int64Value& z() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_z();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_z();
  void set_allocated_z(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_z(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_z();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_z() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_z();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PositionAndAccuracy_Metric& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE x_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE y_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_Metric_class_data_;
// -------------------------------------------------------------------

class PositionAndAccuracy_Geographic final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic) */ {
 public:
  inline PositionAndAccuracy_Geographic() : PositionAndAccuracy_Geographic(nullptr) {}
  ~PositionAndAccuracy_Geographic() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PositionAndAccuracy_Geographic* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PositionAndAccuracy_Geographic));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PositionAndAccuracy_Geographic(::google::protobuf::internal::ConstantInitialized);

  inline PositionAndAccuracy_Geographic(const PositionAndAccuracy_Geographic& from) : PositionAndAccuracy_Geographic(nullptr, from) {}
  inline PositionAndAccuracy_Geographic(PositionAndAccuracy_Geographic&& from) noexcept
      : PositionAndAccuracy_Geographic(nullptr, ::std::move(from)) {}
  inline PositionAndAccuracy_Geographic& operator=(const PositionAndAccuracy_Geographic& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionAndAccuracy_Geographic& operator=(PositionAndAccuracy_Geographic&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionAndAccuracy_Geographic& default_instance() {
    return *reinterpret_cast<const PositionAndAccuracy_Geographic*>(
        &_PositionAndAccuracy_Geographic_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(PositionAndAccuracy_Geographic& a, PositionAndAccuracy_Geographic& b) { a.Swap(&b); }
  inline void Swap(PositionAndAccuracy_Geographic* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionAndAccuracy_Geographic* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionAndAccuracy_Geographic* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PositionAndAccuracy_Geographic>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionAndAccuracy_Geographic& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PositionAndAccuracy_Geographic& from) { PositionAndAccuracy_Geographic::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PositionAndAccuracy_Geographic* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic"; }

 protected:
  explicit PositionAndAccuracy_Geographic(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PositionAndAccuracy_Geographic(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PositionAndAccuracy_Geographic& from);
  PositionAndAccuracy_Geographic(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PositionAndAccuracy_Geographic&& from) noexcept
      : PositionAndAccuracy_Geographic(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
    kAltitudeFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
  bool has_longitude() const;
  void clear_longitude() ;
  const ::sensoris::protobuf::types::base::Int64Value& longitude() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_longitude();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_longitude();
  void set_allocated_longitude(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_longitude(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_longitude();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_longitude() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_longitude();

  public:
  // .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
  bool has_latitude() const;
  void clear_latitude() ;
  const ::sensoris::protobuf::types::base::Int64Value& latitude() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_latitude();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_latitude();
  void set_allocated_latitude(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_latitude(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_latitude();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_latitude() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_latitude();

  public:
  // .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_altitude() const;
  void clear_altitude() ;
  const ::sensoris::protobuf::types::base::Int64Value& altitude() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE release_altitude();
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL mutable_altitude();
  void set_allocated_altitude(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_altitude(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_altitude();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_altitude() const;
  ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL _internal_mutable_altitude();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PositionAndAccuracy_Geographic& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE longitude_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE latitude_;
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE altitude_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_Geographic_class_data_;
// -------------------------------------------------------------------

class XyzVectorAndAccuracy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy) */ {
 public:
  inline XyzVectorAndAccuracy() : XyzVectorAndAccuracy(nullptr) {}
  ~XyzVectorAndAccuracy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(XyzVectorAndAccuracy* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(XyzVectorAndAccuracy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR XyzVectorAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline XyzVectorAndAccuracy(const XyzVectorAndAccuracy& from) : XyzVectorAndAccuracy(nullptr, from) {}
  inline XyzVectorAndAccuracy(XyzVectorAndAccuracy&& from) noexcept
      : XyzVectorAndAccuracy(nullptr, ::std::move(from)) {}
  inline XyzVectorAndAccuracy& operator=(const XyzVectorAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline XyzVectorAndAccuracy& operator=(XyzVectorAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XyzVectorAndAccuracy& default_instance() {
    return *reinterpret_cast<const XyzVectorAndAccuracy*>(
        &_XyzVectorAndAccuracy_default_instance_);
  }
  enum GeometryCase {
    kMetricVehicle = 1,
    kMetricEventGroup = 2,
    kMetricOrigin = 3,
    GEOMETRY_NOT_SET = 0,
  };
  enum AccuracyCase {
    kCombinedStdDev = 4,
    kStdDev = 5,
    kCovariance = 6,
    ACCURACY_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(XyzVectorAndAccuracy& a, XyzVectorAndAccuracy& b) { a.Swap(&b); }
  inline void Swap(XyzVectorAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XyzVectorAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XyzVectorAndAccuracy* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<XyzVectorAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XyzVectorAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const XyzVectorAndAccuracy& from) { XyzVectorAndAccuracy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(XyzVectorAndAccuracy* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.XyzVectorAndAccuracy"; }

 protected:
  explicit XyzVectorAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  XyzVectorAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const XyzVectorAndAccuracy& from);
  XyzVectorAndAccuracy(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, XyzVectorAndAccuracy&& from) noexcept
      : XyzVectorAndAccuracy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using StdDev = XyzVectorAndAccuracy_StdDev;
  using Metric = XyzVectorAndAccuracy_Metric;

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kMetricVehicleFieldNumber = 1,
    kMetricEventGroupFieldNumber = 2,
    kMetricOriginFieldNumber = 3,
    kCombinedStdDevFieldNumber = 4,
    kStdDevFieldNumber = 5,
    kCovarianceFieldNumber = 6,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_vehicle = 1;
  bool has_metric_vehicle() const;
  private:
  bool _internal_has_metric_vehicle() const;

  public:
  void clear_metric_vehicle() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& metric_vehicle() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE release_metric_vehicle();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL mutable_metric_vehicle();
  void set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE unsafe_arena_release_metric_vehicle();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& _internal_metric_vehicle() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL _internal_mutable_metric_vehicle();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_event_group = 2;
  bool has_metric_event_group() const;
  private:
  bool _internal_has_metric_event_group() const;

  public:
  void clear_metric_event_group() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& metric_event_group() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE release_metric_event_group();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL mutable_metric_event_group();
  void set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE unsafe_arena_release_metric_event_group();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& _internal_metric_event_group() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL _internal_mutable_metric_event_group();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_origin = 3;
  bool has_metric_origin() const;
  private:
  bool _internal_has_metric_origin() const;

  public:
  void clear_metric_origin() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& metric_origin() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE release_metric_origin();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL mutable_metric_origin();
  void set_allocated_metric_origin(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_metric_origin(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE unsafe_arena_release_metric_origin();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& _internal_metric_origin() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL _internal_mutable_metric_origin();

  public:
  // .google.protobuf.Int64Value combined_std_dev = 4;
  bool has_combined_std_dev() const;
  private:
  bool _internal_has_combined_std_dev() const;

  public:
  void clear_combined_std_dev() ;
  const ::google::protobuf::Int64Value& combined_std_dev() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_combined_std_dev();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_combined_std_dev();
  void set_allocated_combined_std_dev(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_combined_std_dev();

  private:
  const ::google::protobuf::Int64Value& _internal_combined_std_dev() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_combined_std_dev();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev std_dev = 5;
  bool has_std_dev() const;
  private:
  bool _internal_has_std_dev() const;

  public:
  void clear_std_dev() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& std_dev() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* PROTOBUF_NULLABLE release_std_dev();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* PROTOBUF_NONNULL mutable_std_dev();
  void set_allocated_std_dev(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* PROTOBUF_NULLABLE unsafe_arena_release_std_dev();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& _internal_std_dev() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* PROTOBUF_NONNULL _internal_mutable_std_dev();

  public:
  // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6;
  bool has_covariance() const;
  private:
  bool _internal_has_covariance() const;

  public:
  void clear_covariance() ;
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE release_covariance();
  ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL mutable_covariance();
  void set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE unsafe_arena_release_covariance();

  private:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& _internal_covariance() const;
  ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL _internal_mutable_covariance();

  public:
  void clear_geometry();
  GeometryCase geometry_case() const;
  void clear_accuracy();
  AccuracyCase accuracy_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
 private:
  class _Internal;
  void set_has_metric_vehicle();
  void set_has_metric_event_group();
  void set_has_metric_origin();
  void set_has_combined_std_dev();
  void set_has_std_dev();
  void set_has_covariance();
  inline bool has_geometry() const;
  inline void clear_has_geometry();
  inline bool has_accuracy() const;
  inline void clear_has_accuracy();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 7,
                                   7, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const XyzVectorAndAccuracy& from_msg);
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    union GeometryUnion {
      constexpr GeometryUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE metric_vehicle_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE metric_event_group_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE metric_origin_;
    } geometry_;
    union AccuracyUnion {
      constexpr AccuracyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE combined_std_dev_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE std_dev_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE covariance_;
    } accuracy_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull XyzVectorAndAccuracy_class_data_;
// -------------------------------------------------------------------

class RotationAndAccuracy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationAndAccuracy) */ {
 public:
  inline RotationAndAccuracy() : RotationAndAccuracy(nullptr) {}
  ~RotationAndAccuracy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RotationAndAccuracy* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RotationAndAccuracy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RotationAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline RotationAndAccuracy(const RotationAndAccuracy& from) : RotationAndAccuracy(nullptr, from) {}
  inline RotationAndAccuracy(RotationAndAccuracy&& from) noexcept
      : RotationAndAccuracy(nullptr, ::std::move(from)) {}
  inline RotationAndAccuracy& operator=(const RotationAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationAndAccuracy& operator=(RotationAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationAndAccuracy& default_instance() {
    return *reinterpret_cast<const RotationAndAccuracy*>(
        &_RotationAndAccuracy_default_instance_);
  }
  enum EulerQuaternionCase {
    kEulerVehicle = 1,
    kEulerEventGroup = 2,
    kQuaternionVehicle = 3,
    kQuaternionEventGroup = 4,
    EULER_QUATERNION_NOT_SET = 0,
  };
  enum AccuracyCase {
    kCombinedStdDev = 5,
    kStdDev = 6,
    kCovariance = 7,
    ACCURACY_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(RotationAndAccuracy& a, RotationAndAccuracy& b) { a.Swap(&b); }
  inline void Swap(RotationAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationAndAccuracy* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RotationAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RotationAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RotationAndAccuracy& from) { RotationAndAccuracy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RotationAndAccuracy* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.RotationAndAccuracy"; }

 protected:
  explicit RotationAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RotationAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RotationAndAccuracy& from);
  RotationAndAccuracy(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RotationAndAccuracy&& from) noexcept
      : RotationAndAccuracy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Euler = RotationAndAccuracy_Euler;
  using Quaternion = RotationAndAccuracy_Quaternion;
  using StdDev = RotationAndAccuracy_StdDev;

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kEulerVehicleFieldNumber = 1,
    kEulerEventGroupFieldNumber = 2,
    kQuaternionVehicleFieldNumber = 3,
    kQuaternionEventGroupFieldNumber = 4,
    kCombinedStdDevFieldNumber = 5,
    kStdDevFieldNumber = 6,
    kCovarianceFieldNumber = 7,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_vehicle = 1;
  bool has_euler_vehicle() const;
  private:
  bool _internal_has_euler_vehicle() const;

  public:
  void clear_euler_vehicle() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& euler_vehicle() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE release_euler_vehicle();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NONNULL mutable_euler_vehicle();
  void set_allocated_euler_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_euler_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE unsafe_arena_release_euler_vehicle();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& _internal_euler_vehicle() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NONNULL _internal_mutable_euler_vehicle();

  public:
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_event_group = 2;
  bool has_euler_event_group() const;
  private:
  bool _internal_has_euler_event_group() const;

  public:
  void clear_euler_event_group() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& euler_event_group() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE release_euler_event_group();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NONNULL mutable_euler_event_group();
  void set_allocated_euler_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_euler_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE unsafe_arena_release_euler_event_group();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& _internal_euler_event_group() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NONNULL _internal_mutable_euler_event_group();

  public:
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_vehicle = 3;
  bool has_quaternion_vehicle() const;
  private:
  bool _internal_has_quaternion_vehicle() const;

  public:
  void clear_quaternion_vehicle() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& quaternion_vehicle() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE release_quaternion_vehicle();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL mutable_quaternion_vehicle();
  void set_allocated_quaternion_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_quaternion_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE unsafe_arena_release_quaternion_vehicle();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& _internal_quaternion_vehicle() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL _internal_mutable_quaternion_vehicle();

  public:
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_event_group = 4;
  bool has_quaternion_event_group() const;
  private:
  bool _internal_has_quaternion_event_group() const;

  public:
  void clear_quaternion_event_group() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& quaternion_event_group() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE release_quaternion_event_group();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL mutable_quaternion_event_group();
  void set_allocated_quaternion_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_quaternion_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE unsafe_arena_release_quaternion_event_group();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& _internal_quaternion_event_group() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL _internal_mutable_quaternion_event_group();

  public:
  // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_combined_std_dev() const;
  private:
  bool _internal_has_combined_std_dev() const;

  public:
  void clear_combined_std_dev() ;
  const ::google::protobuf::Int64Value& combined_std_dev() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_combined_std_dev();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_combined_std_dev();
  void set_allocated_combined_std_dev(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_combined_std_dev();

  private:
  const ::google::protobuf::Int64Value& _internal_combined_std_dev() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_combined_std_dev();

  public:
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev std_dev = 6;
  bool has_std_dev() const;
  private:
  bool _internal_has_std_dev() const;

  public:
  void clear_std_dev() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& std_dev() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* PROTOBUF_NULLABLE release_std_dev();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* PROTOBUF_NONNULL mutable_std_dev();
  void set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* PROTOBUF_NULLABLE unsafe_arena_release_std_dev();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& _internal_std_dev() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* PROTOBUF_NONNULL _internal_mutable_std_dev();

  public:
  // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 7 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_covariance() const;
  private:
  bool _internal_has_covariance() const;

  public:
  void clear_covariance() ;
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE release_covariance();
  ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL mutable_covariance();
  void set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE unsafe_arena_release_covariance();

  private:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& _internal_covariance() const;
  ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL _internal_mutable_covariance();

  public:
  void clear_euler_quaternion();
  EulerQuaternionCase euler_quaternion_case() const;
  void clear_accuracy();
  AccuracyCase accuracy_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationAndAccuracy)
 private:
  class _Internal;
  void set_has_euler_vehicle();
  void set_has_euler_event_group();
  void set_has_quaternion_vehicle();
  void set_has_quaternion_event_group();
  void set_has_combined_std_dev();
  void set_has_std_dev();
  void set_has_covariance();
  inline bool has_euler_quaternion() const;
  inline void clear_has_euler_quaternion();
  inline bool has_accuracy() const;
  inline void clear_has_accuracy();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 8,
                                   8, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RotationAndAccuracy& from_msg);
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    union EulerQuaternionUnion {
      constexpr EulerQuaternionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE euler_vehicle_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE euler_event_group_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE quaternion_vehicle_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE quaternion_event_group_;
    } euler_quaternion_;
    union AccuracyUnion {
      constexpr AccuracyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE combined_std_dev_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE std_dev_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE covariance_;
    } accuracy_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RotationAndAccuracy_class_data_;
// -------------------------------------------------------------------

class PositionAndAccuracy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy) */ {
 public:
  inline PositionAndAccuracy() : PositionAndAccuracy(nullptr) {}
  ~PositionAndAccuracy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PositionAndAccuracy* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PositionAndAccuracy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PositionAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline PositionAndAccuracy(const PositionAndAccuracy& from) : PositionAndAccuracy(nullptr, from) {}
  inline PositionAndAccuracy(PositionAndAccuracy&& from) noexcept
      : PositionAndAccuracy(nullptr, ::std::move(from)) {}
  inline PositionAndAccuracy& operator=(const PositionAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionAndAccuracy& operator=(PositionAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionAndAccuracy& default_instance() {
    return *reinterpret_cast<const PositionAndAccuracy*>(
        &_PositionAndAccuracy_default_instance_);
  }
  enum GeographicMetricCase {
    kGeographicWgs84 = 1,
    kMetricVehicle = 2,
    kMetricEventGroup = 3,
    kMetricEcef = 4,
    GEOGRAPHIC_METRIC_NOT_SET = 0,
  };
  enum AccuracyCase {
    kCombinedStdDev = 5,
    kStdDev = 6,
    kHorizontalConfidenceEllipseVerticalStdDev = 7,
    kCovariance = 8,
    ACCURACY_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(PositionAndAccuracy& a, PositionAndAccuracy& b) { a.Swap(&b); }
  inline void Swap(PositionAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionAndAccuracy* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PositionAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PositionAndAccuracy& from) { PositionAndAccuracy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PositionAndAccuracy* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.PositionAndAccuracy"; }

 protected:
  explicit PositionAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PositionAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PositionAndAccuracy& from);
  PositionAndAccuracy(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PositionAndAccuracy&& from) noexcept
      : PositionAndAccuracy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Geographic = PositionAndAccuracy_Geographic;
  using Metric = PositionAndAccuracy_Metric;
  using HorizontalVerticalStdDev = PositionAndAccuracy_HorizontalVerticalStdDev;
  using HorizontalConfidenceEllipseVerticalStdDev = PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev;

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kGeographicWgs84FieldNumber = 1,
    kMetricVehicleFieldNumber = 2,
    kMetricEventGroupFieldNumber = 3,
    kMetricEcefFieldNumber = 4,
    kCombinedStdDevFieldNumber = 5,
    kStdDevFieldNumber = 6,
    kHorizontalConfidenceEllipseVerticalStdDevFieldNumber = 7,
    kCovarianceFieldNumber = 8,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic geographic_wgs84 = 1;
  bool has_geographic_wgs84() const;
  private:
  bool _internal_has_geographic_wgs84() const;

  public:
  void clear_geographic_wgs84() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& geographic_wgs84() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PROTOBUF_NULLABLE release_geographic_wgs84();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PROTOBUF_NONNULL mutable_geographic_wgs84();
  void set_allocated_geographic_wgs84(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_geographic_wgs84(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PROTOBUF_NULLABLE unsafe_arena_release_geographic_wgs84();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& _internal_geographic_wgs84() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PROTOBUF_NONNULL _internal_mutable_geographic_wgs84();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_vehicle = 2;
  bool has_metric_vehicle() const;
  private:
  bool _internal_has_metric_vehicle() const;

  public:
  void clear_metric_vehicle() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& metric_vehicle() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE release_metric_vehicle();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NONNULL mutable_metric_vehicle();
  void set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE unsafe_arena_release_metric_vehicle();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& _internal_metric_vehicle() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NONNULL _internal_mutable_metric_vehicle();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_event_group = 3;
  bool has_metric_event_group() const;
  private:
  bool _internal_has_metric_event_group() const;

  public:
  void clear_metric_event_group() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& metric_event_group() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE release_metric_event_group();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NONNULL mutable_metric_event_group();
  void set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE unsafe_arena_release_metric_event_group();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& _internal_metric_event_group() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NONNULL _internal_mutable_metric_event_group();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_ecef = 4;
  bool has_metric_ecef() const;
  private:
  bool _internal_has_metric_ecef() const;

  public:
  void clear_metric_ecef() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& metric_ecef() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE release_metric_ecef();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NONNULL mutable_metric_ecef();
  void set_allocated_metric_ecef(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_metric_ecef(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE unsafe_arena_release_metric_ecef();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& _internal_metric_ecef() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NONNULL _internal_mutable_metric_ecef();

  public:
  // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_combined_std_dev() const;
  private:
  bool _internal_has_combined_std_dev() const;

  public:
  void clear_combined_std_dev() ;
  const ::google::protobuf::Int64Value& combined_std_dev() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_combined_std_dev();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_combined_std_dev();
  void set_allocated_combined_std_dev(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_combined_std_dev();

  private:
  const ::google::protobuf::Int64Value& _internal_combined_std_dev() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_combined_std_dev();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev std_dev = 6;
  bool has_std_dev() const;
  private:
  bool _internal_has_std_dev() const;

  public:
  void clear_std_dev() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& std_dev() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NULLABLE release_std_dev();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NONNULL mutable_std_dev();
  void set_allocated_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NULLABLE unsafe_arena_release_std_dev();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& _internal_std_dev() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NONNULL _internal_mutable_std_dev();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev horizontal_confidence_ellipse_vertical_std_dev = 7;
  bool has_horizontal_confidence_ellipse_vertical_std_dev() const;
  private:
  bool _internal_has_horizontal_confidence_ellipse_vertical_std_dev() const;

  public:
  void clear_horizontal_confidence_ellipse_vertical_std_dev() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& horizontal_confidence_ellipse_vertical_std_dev() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NULLABLE release_horizontal_confidence_ellipse_vertical_std_dev();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NONNULL mutable_horizontal_confidence_ellipse_vertical_std_dev();
  void set_allocated_horizontal_confidence_ellipse_vertical_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_horizontal_confidence_ellipse_vertical_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NULLABLE unsafe_arena_release_horizontal_confidence_ellipse_vertical_std_dev();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& _internal_horizontal_confidence_ellipse_vertical_std_dev() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NONNULL _internal_mutable_horizontal_confidence_ellipse_vertical_std_dev();

  public:
  // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 8 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_covariance() const;
  private:
  bool _internal_has_covariance() const;

  public:
  void clear_covariance() ;
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE release_covariance();
  ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL mutable_covariance();
  void set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE unsafe_arena_release_covariance();

  private:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& _internal_covariance() const;
  ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL _internal_mutable_covariance();

  public:
  void clear_geographic_metric();
  GeographicMetricCase geographic_metric_case() const;
  void clear_accuracy();
  AccuracyCase accuracy_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy)
 private:
  class _Internal;
  void set_has_geographic_wgs84();
  void set_has_metric_vehicle();
  void set_has_metric_event_group();
  void set_has_metric_ecef();
  void set_has_combined_std_dev();
  void set_has_std_dev();
  void set_has_horizontal_confidence_ellipse_vertical_std_dev();
  void set_has_covariance();
  inline bool has_geographic_metric() const;
  inline void clear_has_geographic_metric();
  inline bool has_accuracy() const;
  inline void clear_has_accuracy();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 9,
                                   9, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PositionAndAccuracy& from_msg);
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    union GeographicMetricUnion {
      constexpr GeographicMetricUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE geographic_wgs84_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE metric_vehicle_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE metric_event_group_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE metric_ecef_;
    } geographic_metric_;
    union AccuracyUnion {
      constexpr AccuracyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE combined_std_dev_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE std_dev_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE horizontal_confidence_ellipse_vertical_std_dev_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE covariance_;
    } accuracy_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PositionAndAccuracy_class_data_;
// -------------------------------------------------------------------

class RectangularBoxAndAccuracy_CornerVectors final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors) */ {
 public:
  inline RectangularBoxAndAccuracy_CornerVectors() : RectangularBoxAndAccuracy_CornerVectors(nullptr) {}
  ~RectangularBoxAndAccuracy_CornerVectors() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RectangularBoxAndAccuracy_CornerVectors));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy_CornerVectors(::google::protobuf::internal::ConstantInitialized);

  inline RectangularBoxAndAccuracy_CornerVectors(const RectangularBoxAndAccuracy_CornerVectors& from) : RectangularBoxAndAccuracy_CornerVectors(nullptr, from) {}
  inline RectangularBoxAndAccuracy_CornerVectors(RectangularBoxAndAccuracy_CornerVectors&& from) noexcept
      : RectangularBoxAndAccuracy_CornerVectors(nullptr, ::std::move(from)) {}
  inline RectangularBoxAndAccuracy_CornerVectors& operator=(const RectangularBoxAndAccuracy_CornerVectors& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectangularBoxAndAccuracy_CornerVectors& operator=(RectangularBoxAndAccuracy_CornerVectors&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RectangularBoxAndAccuracy_CornerVectors& default_instance() {
    return *reinterpret_cast<const RectangularBoxAndAccuracy_CornerVectors*>(
        &_RectangularBoxAndAccuracy_CornerVectors_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(RectangularBoxAndAccuracy_CornerVectors& a, RectangularBoxAndAccuracy_CornerVectors& b) { a.Swap(&b); }
  inline void Swap(RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RectangularBoxAndAccuracy_CornerVectors>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RectangularBoxAndAccuracy_CornerVectors& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RectangularBoxAndAccuracy_CornerVectors& from) { RectangularBoxAndAccuracy_CornerVectors::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors"; }

 protected:
  explicit RectangularBoxAndAccuracy_CornerVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RectangularBoxAndAccuracy_CornerVectors(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RectangularBoxAndAccuracy_CornerVectors& from);
  RectangularBoxAndAccuracy_CornerVectors(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RectangularBoxAndAccuracy_CornerVectors&& from) noexcept
      : RectangularBoxAndAccuracy_CornerVectors(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFirstAndAccuracyFieldNumber = 1,
    kSecondAndAccuracyFieldNumber = 2,
    kThirdAndAccuracyFieldNumber = 3,
  };
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_first_and_accuracy() const;
  void clear_first_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& first_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE release_first_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL mutable_first_and_accuracy();
  void set_allocated_first_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_first_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_first_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_first_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL _internal_mutable_first_and_accuracy();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_second_and_accuracy() const;
  void clear_second_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& second_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE release_second_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL mutable_second_and_accuracy();
  void set_allocated_second_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_second_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_second_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_second_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL _internal_mutable_second_and_accuracy();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_third_and_accuracy() const;
  void clear_third_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& third_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE release_third_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL mutable_third_and_accuracy();
  void set_allocated_third_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_third_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_third_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_third_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL _internal_mutable_third_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RectangularBoxAndAccuracy_CornerVectors& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE first_and_accuracy_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE second_and_accuracy_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE third_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RectangularBoxAndAccuracy_CornerVectors_class_data_;
// -------------------------------------------------------------------

class RectangularBoxAndAccuracy_CenterOrientationSize final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize) */ {
 public:
  inline RectangularBoxAndAccuracy_CenterOrientationSize() : RectangularBoxAndAccuracy_CenterOrientationSize(nullptr) {}
  ~RectangularBoxAndAccuracy_CenterOrientationSize() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RectangularBoxAndAccuracy_CenterOrientationSize));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy_CenterOrientationSize(::google::protobuf::internal::ConstantInitialized);

  inline RectangularBoxAndAccuracy_CenterOrientationSize(const RectangularBoxAndAccuracy_CenterOrientationSize& from) : RectangularBoxAndAccuracy_CenterOrientationSize(nullptr, from) {}
  inline RectangularBoxAndAccuracy_CenterOrientationSize(RectangularBoxAndAccuracy_CenterOrientationSize&& from) noexcept
      : RectangularBoxAndAccuracy_CenterOrientationSize(nullptr, ::std::move(from)) {}
  inline RectangularBoxAndAccuracy_CenterOrientationSize& operator=(const RectangularBoxAndAccuracy_CenterOrientationSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectangularBoxAndAccuracy_CenterOrientationSize& operator=(RectangularBoxAndAccuracy_CenterOrientationSize&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RectangularBoxAndAccuracy_CenterOrientationSize& default_instance() {
    return *reinterpret_cast<const RectangularBoxAndAccuracy_CenterOrientationSize*>(
        &_RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(RectangularBoxAndAccuracy_CenterOrientationSize& a, RectangularBoxAndAccuracy_CenterOrientationSize& b) { a.Swap(&b); }
  inline void Swap(RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RectangularBoxAndAccuracy_CenterOrientationSize>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RectangularBoxAndAccuracy_CenterOrientationSize& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RectangularBoxAndAccuracy_CenterOrientationSize& from) { RectangularBoxAndAccuracy_CenterOrientationSize::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize"; }

 protected:
  explicit RectangularBoxAndAccuracy_CenterOrientationSize(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RectangularBoxAndAccuracy_CenterOrientationSize(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RectangularBoxAndAccuracy_CenterOrientationSize& from);
  RectangularBoxAndAccuracy_CenterOrientationSize(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RectangularBoxAndAccuracy_CenterOrientationSize&& from) noexcept
      : RectangularBoxAndAccuracy_CenterOrientationSize(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCenterPositionAndAccuracyFieldNumber = 1,
    kOrientationAndAccuracyFieldNumber = 2,
    kSizeAndAccuracyFieldNumber = 3,
  };
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
  bool has_center_position_and_accuracy() const;
  void clear_center_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& center_position_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE release_center_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL mutable_center_position_and_accuracy();
  void set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_center_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_center_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL _internal_mutable_center_position_and_accuracy();

  public:
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
  bool has_orientation_and_accuracy() const;
  void clear_orientation_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& orientation_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE release_orientation_and_accuracy();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NONNULL mutable_orientation_and_accuracy();
  void set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_orientation_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& _internal_orientation_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NONNULL _internal_mutable_orientation_and_accuracy();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_size_and_accuracy() const;
  void clear_size_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& size_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE release_size_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL mutable_size_and_accuracy();
  void set_allocated_size_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_size_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_size_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_size_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL _internal_mutable_size_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RectangularBoxAndAccuracy_CenterOrientationSize& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE center_position_and_accuracy_;
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE orientation_and_accuracy_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE size_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RectangularBoxAndAccuracy_CenterOrientationSize_class_data_;
// -------------------------------------------------------------------

class RectangleAndAccuracy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RectangleAndAccuracy) */ {
 public:
  inline RectangleAndAccuracy() : RectangleAndAccuracy(nullptr) {}
  ~RectangleAndAccuracy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RectangleAndAccuracy* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RectangleAndAccuracy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RectangleAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline RectangleAndAccuracy(const RectangleAndAccuracy& from) : RectangleAndAccuracy(nullptr, from) {}
  inline RectangleAndAccuracy(RectangleAndAccuracy&& from) noexcept
      : RectangleAndAccuracy(nullptr, ::std::move(from)) {}
  inline RectangleAndAccuracy& operator=(const RectangleAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectangleAndAccuracy& operator=(RectangleAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RectangleAndAccuracy& default_instance() {
    return *reinterpret_cast<const RectangleAndAccuracy*>(
        &_RectangleAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(RectangleAndAccuracy& a, RectangleAndAccuracy& b) { a.Swap(&b); }
  inline void Swap(RectangleAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectangleAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RectangleAndAccuracy* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RectangleAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RectangleAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RectangleAndAccuracy& from) { RectangleAndAccuracy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RectangleAndAccuracy* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.RectangleAndAccuracy"; }

 protected:
  explicit RectangleAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RectangleAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RectangleAndAccuracy& from);
  RectangleAndAccuracy(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RectangleAndAccuracy&& from) noexcept
      : RectangleAndAccuracy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kMinimumPositionAndAccuracyFieldNumber = 1,
    kMaximumPositionAndAccuracyFieldNumber = 2,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy minimum_position_and_accuracy = 1;
  bool has_minimum_position_and_accuracy() const;
  void clear_minimum_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& minimum_position_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE release_minimum_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL mutable_minimum_position_and_accuracy();
  void set_allocated_minimum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_minimum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_minimum_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_minimum_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL _internal_mutable_minimum_position_and_accuracy();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy maximum_position_and_accuracy = 2;
  bool has_maximum_position_and_accuracy() const;
  void clear_maximum_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& maximum_position_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE release_maximum_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL mutable_maximum_position_and_accuracy();
  void set_allocated_maximum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_maximum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_maximum_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_maximum_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL _internal_mutable_maximum_position_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RectangleAndAccuracy& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE minimum_position_and_accuracy_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE maximum_position_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RectangleAndAccuracy_class_data_;
// -------------------------------------------------------------------

class PolylineAndAccuracy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PolylineAndAccuracy) */ {
 public:
  inline PolylineAndAccuracy() : PolylineAndAccuracy(nullptr) {}
  ~PolylineAndAccuracy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PolylineAndAccuracy* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PolylineAndAccuracy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PolylineAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline PolylineAndAccuracy(const PolylineAndAccuracy& from) : PolylineAndAccuracy(nullptr, from) {}
  inline PolylineAndAccuracy(PolylineAndAccuracy&& from) noexcept
      : PolylineAndAccuracy(nullptr, ::std::move(from)) {}
  inline PolylineAndAccuracy& operator=(const PolylineAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolylineAndAccuracy& operator=(PolylineAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolylineAndAccuracy& default_instance() {
    return *reinterpret_cast<const PolylineAndAccuracy*>(
        &_PolylineAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(PolylineAndAccuracy& a, PolylineAndAccuracy& b) { a.Swap(&b); }
  inline void Swap(PolylineAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolylineAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolylineAndAccuracy* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PolylineAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PolylineAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PolylineAndAccuracy& from) { PolylineAndAccuracy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PolylineAndAccuracy* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.PolylineAndAccuracy"; }

 protected:
  explicit PolylineAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PolylineAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PolylineAndAccuracy& from);
  PolylineAndAccuracy(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PolylineAndAccuracy&& from) noexcept
      : PolylineAndAccuracy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionAndAccuracyFieldNumber = 1,
    kExtensionFieldNumber = 15,
  };
  // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  int position_and_accuracy_size() const;
  private:
  int _internal_position_and_accuracy_size() const;

  public:
  void clear_position_and_accuracy() ;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL mutable_position_and_accuracy(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>* PROTOBUF_NONNULL mutable_position_and_accuracy();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>& _internal_position_and_accuracy() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>* PROTOBUF_NONNULL _internal_mutable_position_and_accuracy();
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy(int index) const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL add_position_and_accuracy();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>& position_and_accuracy() const;
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PolylineAndAccuracy& from_msg);
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy > position_and_accuracy_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PolylineAndAccuracy_class_data_;
// -------------------------------------------------------------------

class PolygonAndAccuracy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PolygonAndAccuracy) */ {
 public:
  inline PolygonAndAccuracy() : PolygonAndAccuracy(nullptr) {}
  ~PolygonAndAccuracy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PolygonAndAccuracy* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PolygonAndAccuracy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PolygonAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline PolygonAndAccuracy(const PolygonAndAccuracy& from) : PolygonAndAccuracy(nullptr, from) {}
  inline PolygonAndAccuracy(PolygonAndAccuracy&& from) noexcept
      : PolygonAndAccuracy(nullptr, ::std::move(from)) {}
  inline PolygonAndAccuracy& operator=(const PolygonAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolygonAndAccuracy& operator=(PolygonAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolygonAndAccuracy& default_instance() {
    return *reinterpret_cast<const PolygonAndAccuracy*>(
        &_PolygonAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(PolygonAndAccuracy& a, PolygonAndAccuracy& b) { a.Swap(&b); }
  inline void Swap(PolygonAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolygonAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolygonAndAccuracy* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PolygonAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PolygonAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PolygonAndAccuracy& from) { PolygonAndAccuracy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PolygonAndAccuracy* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.PolygonAndAccuracy"; }

 protected:
  explicit PolygonAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PolygonAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PolygonAndAccuracy& from);
  PolygonAndAccuracy(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PolygonAndAccuracy&& from) noexcept
      : PolygonAndAccuracy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionAndAccuracyFieldNumber = 1,
    kExtensionFieldNumber = 15,
  };
  // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  int position_and_accuracy_size() const;
  private:
  int _internal_position_and_accuracy_size() const;

  public:
  void clear_position_and_accuracy() ;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL mutable_position_and_accuracy(int index);
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>* PROTOBUF_NONNULL mutable_position_and_accuracy();

  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>& _internal_position_and_accuracy() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>* PROTOBUF_NONNULL _internal_mutable_position_and_accuracy();
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy(int index) const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL add_position_and_accuracy();
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>& position_and_accuracy() const;
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PolygonAndAccuracy& from_msg);
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy > position_and_accuracy_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PolygonAndAccuracy_class_data_;
// -------------------------------------------------------------------

class MapLocationReference final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.MapLocationReference) */ {
 public:
  inline MapLocationReference() : MapLocationReference(nullptr) {}
  ~MapLocationReference() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MapLocationReference* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MapLocationReference));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MapLocationReference(::google::protobuf::internal::ConstantInitialized);

  inline MapLocationReference(const MapLocationReference& from) : MapLocationReference(nullptr, from) {}
  inline MapLocationReference(MapLocationReference&& from) noexcept
      : MapLocationReference(nullptr, ::std::move(from)) {}
  inline MapLocationReference& operator=(const MapLocationReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapLocationReference& operator=(MapLocationReference&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapLocationReference& default_instance() {
    return *reinterpret_cast<const MapLocationReference*>(
        &_MapLocationReference_default_instance_);
  }
  enum MapBasedReferenceCase {
    kTileLinkOffsetReference = 3,
    kMapObjectId = 4,
    MAP_BASED_REFERENCE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(MapLocationReference& a, MapLocationReference& b) { a.Swap(&b); }
  inline void Swap(MapLocationReference* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapLocationReference* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapLocationReference* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MapLocationReference>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MapLocationReference& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MapLocationReference& from) { MapLocationReference::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MapLocationReference* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.MapLocationReference"; }

 protected:
  explicit MapLocationReference(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MapLocationReference(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MapLocationReference& from);
  MapLocationReference(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MapLocationReference&& from) noexcept
      : MapLocationReference(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TileIdLinkIdOffset = MapLocationReference_TileIdLinkIdOffset;
  using TileIdObjectId = MapLocationReference_TileIdObjectId;

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kPositionAndAccuracyFieldNumber = 1,
    kZLevelFieldNumber = 2,
    kTileLinkOffsetReferenceFieldNumber = 3,
    kMapObjectIdFieldNumber = 4,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL _internal_mutable_position_and_accuracy();

  public:
  // .google.protobuf.Int64Value z_level = 2;
  bool has_z_level() const;
  void clear_z_level() ;
  const ::google::protobuf::Int64Value& z_level() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_z_level();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_z_level();
  void set_allocated_z_level(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_z_level(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_z_level();

  private:
  const ::google::protobuf::Int64Value& _internal_z_level() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_z_level();

  public:
  // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset tile_link_offset_reference = 3;
  bool has_tile_link_offset_reference() const;
  private:
  bool _internal_has_tile_link_offset_reference() const;

  public:
  void clear_tile_link_offset_reference() ;
  const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& tile_link_offset_reference() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NULLABLE release_tile_link_offset_reference();
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NONNULL mutable_tile_link_offset_reference();
  void set_allocated_tile_link_offset_reference(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tile_link_offset_reference(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NULLABLE unsafe_arena_release_tile_link_offset_reference();

  private:
  const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& _internal_tile_link_offset_reference() const;
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NONNULL _internal_mutable_tile_link_offset_reference();

  public:
  // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId map_object_id = 4;
  bool has_map_object_id() const;
  private:
  bool _internal_has_map_object_id() const;

  public:
  void clear_map_object_id() ;
  const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& map_object_id() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NULLABLE release_map_object_id();
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NONNULL mutable_map_object_id();
  void set_allocated_map_object_id(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_map_object_id(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NULLABLE unsafe_arena_release_map_object_id();

  private:
  const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& _internal_map_object_id() const;
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NONNULL _internal_mutable_map_object_id();

  public:
  void clear_map_based_reference();
  MapBasedReferenceCase map_based_reference_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.MapLocationReference)
 private:
  class _Internal;
  void set_has_tile_link_offset_reference();
  void set_has_map_object_id();
  inline bool has_map_based_reference() const;
  inline void clear_has_map_based_reference();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 5,
                                   5, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MapLocationReference& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE position_and_accuracy_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE z_level_;
    union MapBasedReferenceUnion {
      constexpr MapBasedReferenceUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NULLABLE tile_link_offset_reference_;
      ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NULLABLE map_object_id_;
    } map_based_reference_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MapLocationReference_class_data_;
// -------------------------------------------------------------------

class CircleAndAccuracy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.CircleAndAccuracy) */ {
 public:
  inline CircleAndAccuracy() : CircleAndAccuracy(nullptr) {}
  ~CircleAndAccuracy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CircleAndAccuracy* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CircleAndAccuracy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CircleAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline CircleAndAccuracy(const CircleAndAccuracy& from) : CircleAndAccuracy(nullptr, from) {}
  inline CircleAndAccuracy(CircleAndAccuracy&& from) noexcept
      : CircleAndAccuracy(nullptr, ::std::move(from)) {}
  inline CircleAndAccuracy& operator=(const CircleAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircleAndAccuracy& operator=(CircleAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircleAndAccuracy& default_instance() {
    return *reinterpret_cast<const CircleAndAccuracy*>(
        &_CircleAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(CircleAndAccuracy& a, CircleAndAccuracy& b) { a.Swap(&b); }
  inline void Swap(CircleAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircleAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircleAndAccuracy* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CircleAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CircleAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CircleAndAccuracy& from) { CircleAndAccuracy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CircleAndAccuracy* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.CircleAndAccuracy"; }

 protected:
  explicit CircleAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CircleAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CircleAndAccuracy& from);
  CircleAndAccuracy(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CircleAndAccuracy&& from) noexcept
      : CircleAndAccuracy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kCenterPositionAndAccuracyFieldNumber = 1,
    kRadiusAndAccuracyFieldNumber = 2,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
  bool has_center_position_and_accuracy() const;
  void clear_center_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& center_position_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE release_center_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL mutable_center_position_and_accuracy();
  void set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_center_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_center_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL _internal_mutable_center_position_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy radius_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_radius_and_accuracy() const;
  void clear_radius_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& radius_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_radius_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_radius_and_accuracy();
  void set_allocated_radius_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_radius_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_radius_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_radius_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_radius_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.CircleAndAccuracy)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CircleAndAccuracy& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE center_position_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE radius_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CircleAndAccuracy_class_data_;
// -------------------------------------------------------------------

class RectangularBoxAndAccuracy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy) */ {
 public:
  inline RectangularBoxAndAccuracy() : RectangularBoxAndAccuracy(nullptr) {}
  ~RectangularBoxAndAccuracy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RectangularBoxAndAccuracy* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RectangularBoxAndAccuracy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline RectangularBoxAndAccuracy(const RectangularBoxAndAccuracy& from) : RectangularBoxAndAccuracy(nullptr, from) {}
  inline RectangularBoxAndAccuracy(RectangularBoxAndAccuracy&& from) noexcept
      : RectangularBoxAndAccuracy(nullptr, ::std::move(from)) {}
  inline RectangularBoxAndAccuracy& operator=(const RectangularBoxAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectangularBoxAndAccuracy& operator=(RectangularBoxAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RectangularBoxAndAccuracy& default_instance() {
    return *reinterpret_cast<const RectangularBoxAndAccuracy*>(
        &_RectangularBoxAndAccuracy_default_instance_);
  }
  enum GeometryCase {
    kCornerVectors = 1,
    kCenterOrientationSize = 2,
    GEOMETRY_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(RectangularBoxAndAccuracy& a, RectangularBoxAndAccuracy& b) { a.Swap(&b); }
  inline void Swap(RectangularBoxAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectangularBoxAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RectangularBoxAndAccuracy* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RectangularBoxAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RectangularBoxAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RectangularBoxAndAccuracy& from) { RectangularBoxAndAccuracy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RectangularBoxAndAccuracy* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy"; }

 protected:
  explicit RectangularBoxAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RectangularBoxAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RectangularBoxAndAccuracy& from);
  RectangularBoxAndAccuracy(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RectangularBoxAndAccuracy&& from) noexcept
      : RectangularBoxAndAccuracy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using CornerVectors = RectangularBoxAndAccuracy_CornerVectors;
  using CenterOrientationSize = RectangularBoxAndAccuracy_CenterOrientationSize;

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kCornerVectorsFieldNumber = 1,
    kCenterOrientationSizeFieldNumber = 2,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors corner_vectors = 1;
  bool has_corner_vectors() const;
  private:
  bool _internal_has_corner_vectors() const;

  public:
  void clear_corner_vectors() ;
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& corner_vectors() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NULLABLE release_corner_vectors();
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NONNULL mutable_corner_vectors();
  void set_allocated_corner_vectors(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_corner_vectors(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NULLABLE unsafe_arena_release_corner_vectors();

  private:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& _internal_corner_vectors() const;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NONNULL _internal_mutable_corner_vectors();

  public:
  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize center_orientation_size = 2;
  bool has_center_orientation_size() const;
  private:
  bool _internal_has_center_orientation_size() const;

  public:
  void clear_center_orientation_size() ;
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& center_orientation_size() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NULLABLE release_center_orientation_size();
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NONNULL mutable_center_orientation_size();
  void set_allocated_center_orientation_size(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_center_orientation_size(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NULLABLE unsafe_arena_release_center_orientation_size();

  private:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& _internal_center_orientation_size() const;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NONNULL _internal_mutable_center_orientation_size();

  public:
  void clear_geometry();
  GeometryCase geometry_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
 private:
  class _Internal;
  void set_has_corner_vectors();
  void set_has_center_orientation_size();
  inline bool has_geometry() const;
  inline void clear_has_geometry();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RectangularBoxAndAccuracy& from_msg);
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    union GeometryUnion {
      constexpr GeometryUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NULLABLE corner_vectors_;
      ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NULLABLE center_orientation_size_;
    } geometry_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RectangularBoxAndAccuracy_class_data_;
// -------------------------------------------------------------------

class PolylineCorridorAndAccuracy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy) */ {
 public:
  inline PolylineCorridorAndAccuracy() : PolylineCorridorAndAccuracy(nullptr) {}
  ~PolylineCorridorAndAccuracy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PolylineCorridorAndAccuracy* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PolylineCorridorAndAccuracy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PolylineCorridorAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline PolylineCorridorAndAccuracy(const PolylineCorridorAndAccuracy& from) : PolylineCorridorAndAccuracy(nullptr, from) {}
  inline PolylineCorridorAndAccuracy(PolylineCorridorAndAccuracy&& from) noexcept
      : PolylineCorridorAndAccuracy(nullptr, ::std::move(from)) {}
  inline PolylineCorridorAndAccuracy& operator=(const PolylineCorridorAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolylineCorridorAndAccuracy& operator=(PolylineCorridorAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolylineCorridorAndAccuracy& default_instance() {
    return *reinterpret_cast<const PolylineCorridorAndAccuracy*>(
        &_PolylineCorridorAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PolylineCorridorAndAccuracy& a, PolylineCorridorAndAccuracy& b) { a.Swap(&b); }
  inline void Swap(PolylineCorridorAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolylineCorridorAndAccuracy* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolylineCorridorAndAccuracy* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PolylineCorridorAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PolylineCorridorAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PolylineCorridorAndAccuracy& from) { PolylineCorridorAndAccuracy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PolylineCorridorAndAccuracy* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy"; }

 protected:
  explicit PolylineCorridorAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PolylineCorridorAndAccuracy(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PolylineCorridorAndAccuracy& from);
  PolylineCorridorAndAccuracy(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PolylineCorridorAndAccuracy&& from) noexcept
      : PolylineCorridorAndAccuracy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kCenterPolylineAndAccuracyFieldNumber = 1,
    kTotalWidthAndAccuracyFieldNumber = 2,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .sensoris.protobuf.types.spatial.PolylineAndAccuracy center_polyline_and_accuracy = 1;
  bool has_center_polyline_and_accuracy() const;
  void clear_center_polyline_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& center_polyline_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE release_center_polyline_and_accuracy();
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NONNULL mutable_center_polyline_and_accuracy();
  void set_allocated_center_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_center_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_center_polyline_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& _internal_center_polyline_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NONNULL _internal_mutable_center_polyline_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy total_width_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_total_width_and_accuracy() const;
  void clear_total_width_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& total_width_and_accuracy() const;
  [[nodiscard]] ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE release_total_width_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL mutable_total_width_and_accuracy();
  void set_allocated_total_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_total_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_total_width_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_total_width_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL _internal_mutable_total_width_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PolylineCorridorAndAccuracy& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE center_polyline_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE total_width_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PolylineCorridorAndAccuracy_class_data_;
// -------------------------------------------------------------------

class DirectedPolylineCorridor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.DirectedPolylineCorridor) */ {
 public:
  inline DirectedPolylineCorridor() : DirectedPolylineCorridor(nullptr) {}
  ~DirectedPolylineCorridor() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DirectedPolylineCorridor* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DirectedPolylineCorridor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DirectedPolylineCorridor(::google::protobuf::internal::ConstantInitialized);

  inline DirectedPolylineCorridor(const DirectedPolylineCorridor& from) : DirectedPolylineCorridor(nullptr, from) {}
  inline DirectedPolylineCorridor(DirectedPolylineCorridor&& from) noexcept
      : DirectedPolylineCorridor(nullptr, ::std::move(from)) {}
  inline DirectedPolylineCorridor& operator=(const DirectedPolylineCorridor& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectedPolylineCorridor& operator=(DirectedPolylineCorridor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectedPolylineCorridor& default_instance() {
    return *reinterpret_cast<const DirectedPolylineCorridor*>(
        &_DirectedPolylineCorridor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(DirectedPolylineCorridor& a, DirectedPolylineCorridor& b) { a.Swap(&b); }
  inline void Swap(DirectedPolylineCorridor* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectedPolylineCorridor* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectedPolylineCorridor* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DirectedPolylineCorridor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DirectedPolylineCorridor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DirectedPolylineCorridor& from) { DirectedPolylineCorridor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DirectedPolylineCorridor* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sensoris.protobuf.types.spatial.DirectedPolylineCorridor"; }

 protected:
  explicit DirectedPolylineCorridor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DirectedPolylineCorridor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DirectedPolylineCorridor& from);
  DirectedPolylineCorridor(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DirectedPolylineCorridor&& from) noexcept
      : DirectedPolylineCorridor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExtensionFieldNumber = 15,
    kPolylineCorridorFieldNumber = 1,
    kIsBidirectionalFieldNumber = 2,
    kHeadingDeviationFromCenterLineFieldNumber = 3,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* PROTOBUF_NONNULL mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL mutable_extension();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* PROTOBUF_NONNULL add_extension();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& extension() const;
  // .sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy polyline_corridor = 1;
  bool has_polyline_corridor() const;
  void clear_polyline_corridor() ;
  const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy& polyline_corridor() const;
  [[nodiscard]] ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NULLABLE release_polyline_corridor();
  ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NONNULL mutable_polyline_corridor();
  void set_allocated_polyline_corridor(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_polyline_corridor(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NULLABLE value);
  ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NULLABLE unsafe_arena_release_polyline_corridor();

  private:
  const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy& _internal_polyline_corridor() const;
  ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NONNULL _internal_mutable_polyline_corridor();

  public:
  // .google.protobuf.BoolValue is_bidirectional = 2;
  bool has_is_bidirectional() const;
  void clear_is_bidirectional() ;
  const ::google::protobuf::BoolValue& is_bidirectional() const;
  [[nodiscard]] ::google::protobuf::BoolValue* PROTOBUF_NULLABLE release_is_bidirectional();
  ::google::protobuf::BoolValue* PROTOBUF_NONNULL mutable_is_bidirectional();
  void set_allocated_is_bidirectional(::google::protobuf::BoolValue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_is_bidirectional(::google::protobuf::BoolValue* PROTOBUF_NULLABLE value);
  ::google::protobuf::BoolValue* PROTOBUF_NULLABLE unsafe_arena_release_is_bidirectional();

  private:
  const ::google::protobuf::BoolValue& _internal_is_bidirectional() const;
  ::google::protobuf::BoolValue* PROTOBUF_NONNULL _internal_mutable_is_bidirectional();

  public:
  // .google.protobuf.Int64Value heading_deviation_from_center_line = 3;
  bool has_heading_deviation_from_center_line() const;
  void clear_heading_deviation_from_center_line() ;
  const ::google::protobuf::Int64Value& heading_deviation_from_center_line() const;
  [[nodiscard]] ::google::protobuf::Int64Value* PROTOBUF_NULLABLE release_heading_deviation_from_center_line();
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL mutable_heading_deviation_from_center_line();
  void set_allocated_heading_deviation_from_center_line(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_heading_deviation_from_center_line(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value);
  ::google::protobuf::Int64Value* PROTOBUF_NULLABLE unsafe_arena_release_heading_deviation_from_center_line();

  private:
  const ::google::protobuf::Int64Value& _internal_heading_deviation_from_center_line() const;
  ::google::protobuf::Int64Value* PROTOBUF_NONNULL _internal_mutable_heading_deviation_from_center_line();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DirectedPolylineCorridor& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NULLABLE polyline_corridor_;
    ::google::protobuf::BoolValue* PROTOBUF_NULLABLE is_bidirectional_;
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE heading_deviation_from_center_line_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DirectedPolylineCorridor_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PositionAndAccuracy_Geographic

// .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
inline bool PositionAndAccuracy_Geographic::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.longitude_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::_internal_longitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.longitude_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::longitude() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
  return _internal_longitude();
}
inline void PositionAndAccuracy_Geographic::unsafe_arena_set_allocated_longitude(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.longitude_);
  }
  _impl_.longitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_Geographic::release_longitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.longitude_;
  _impl_.longitude_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_Geographic::unsafe_arena_release_longitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.longitude_;
  _impl_.longitude_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_Geographic::_internal_mutable_longitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.longitude_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.longitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.longitude_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_Geographic::mutable_longitude()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_longitude();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
  return _msg;
}
inline void PositionAndAccuracy_Geographic::set_allocated_longitude(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.longitude_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.longitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
}

// .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
inline bool PositionAndAccuracy_Geographic::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.latitude_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::_internal_latitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.latitude_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::latitude() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
  return _internal_latitude();
}
inline void PositionAndAccuracy_Geographic::unsafe_arena_set_allocated_latitude(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latitude_);
  }
  _impl_.latitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_Geographic::release_latitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.latitude_;
  _impl_.latitude_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_Geographic::unsafe_arena_release_latitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.latitude_;
  _impl_.latitude_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_Geographic::_internal_mutable_latitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.latitude_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.latitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.latitude_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_Geographic::mutable_latitude()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_latitude();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
  return _msg;
}
inline void PositionAndAccuracy_Geographic::set_allocated_latitude(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latitude_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.latitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
}

// .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool PositionAndAccuracy_Geographic::has_altitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.altitude_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::_internal_altitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.altitude_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::altitude() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
  return _internal_altitude();
}
inline void PositionAndAccuracy_Geographic::unsafe_arena_set_allocated_altitude(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.altitude_);
  }
  _impl_.altitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_Geographic::release_altitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.altitude_;
  _impl_.altitude_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_Geographic::unsafe_arena_release_altitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.altitude_;
  _impl_.altitude_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_Geographic::_internal_mutable_altitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.altitude_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.altitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.altitude_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_Geographic::mutable_altitude()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_altitude();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
  return _msg;
}
inline void PositionAndAccuracy_Geographic::set_allocated_altitude(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.altitude_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.altitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
}

// -------------------------------------------------------------------

// PositionAndAccuracy_Metric

// .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_Metric::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::x() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
  return _internal_x();
}
inline void PositionAndAccuracy_Metric::unsafe_arena_set_allocated_x(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_Metric::release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.x_;
  _impl_.x_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_Metric::unsafe_arena_release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_Metric::_internal_mutable_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.x_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_Metric::mutable_x()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
  return _msg;
}
inline void PositionAndAccuracy_Metric::set_allocated_x(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
}

// .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_Metric::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.y_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::y() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
  return _internal_y();
}
inline void PositionAndAccuracy_Metric::unsafe_arena_set_allocated_y(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_Metric::release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.y_;
  _impl_.y_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_Metric::unsafe_arena_release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_Metric::_internal_mutable_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.y_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_Metric::mutable_y()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
  return _msg;
}
inline void PositionAndAccuracy_Metric::set_allocated_y(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
}

// .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_Metric::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.z_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.z_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::z() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
  return _internal_z();
}
inline void PositionAndAccuracy_Metric::unsafe_arena_set_allocated_z(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }
  _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_Metric::release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.z_;
  _impl_.z_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_Metric::unsafe_arena_release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.z_;
  _impl_.z_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_Metric::_internal_mutable_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.z_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_Metric::mutable_z()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
  return _msg;
}
inline void PositionAndAccuracy_Metric::set_allocated_z(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
}

// -------------------------------------------------------------------

// PositionAndAccuracy_HorizontalVerticalStdDev

// .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalVerticalStdDev::has_horizontal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.horizontal_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::_internal_horizontal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.horizontal_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::horizontal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
  return _internal_horizontal();
}
inline void PositionAndAccuracy_HorizontalVerticalStdDev::unsafe_arena_set_allocated_horizontal(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_);
  }
  _impl_.horizontal_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_HorizontalVerticalStdDev::release_horizontal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.horizontal_;
  _impl_.horizontal_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_HorizontalVerticalStdDev::unsafe_arena_release_horizontal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.horizontal_;
  _impl_.horizontal_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalVerticalStdDev::_internal_mutable_horizontal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.horizontal_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.horizontal_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.horizontal_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalVerticalStdDev::mutable_horizontal()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_horizontal();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
  return _msg;
}
inline void PositionAndAccuracy_HorizontalVerticalStdDev::set_allocated_horizontal(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.horizontal_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
}

// .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalVerticalStdDev::has_vertical() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vertical_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::_internal_vertical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.vertical_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::vertical() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
  return _internal_vertical();
}
inline void PositionAndAccuracy_HorizontalVerticalStdDev::unsafe_arena_set_allocated_vertical(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vertical_);
  }
  _impl_.vertical_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_HorizontalVerticalStdDev::release_vertical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.vertical_;
  _impl_.vertical_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_HorizontalVerticalStdDev::unsafe_arena_release_vertical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.vertical_;
  _impl_.vertical_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalVerticalStdDev::_internal_mutable_vertical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vertical_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.vertical_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.vertical_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalVerticalStdDev::mutable_vertical()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_vertical();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
  return _msg;
}
inline void PositionAndAccuracy_HorizontalVerticalStdDev::set_allocated_vertical(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vertical_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.vertical_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
}

// -------------------------------------------------------------------

// PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev

// .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::has_horizontal_ellipse_major() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.horizontal_ellipse_major_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_horizontal_ellipse_major() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.horizontal_ellipse_major_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::horizontal_ellipse_major() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
  return _internal_horizontal_ellipse_major();
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_set_allocated_horizontal_ellipse_major(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_ellipse_major_);
  }
  _impl_.horizontal_ellipse_major_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::release_horizontal_ellipse_major() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.horizontal_ellipse_major_;
  _impl_.horizontal_ellipse_major_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_release_horizontal_ellipse_major() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.horizontal_ellipse_major_;
  _impl_.horizontal_ellipse_major_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_mutable_horizontal_ellipse_major() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.horizontal_ellipse_major_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.horizontal_ellipse_major_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.horizontal_ellipse_major_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::mutable_horizontal_ellipse_major()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_horizontal_ellipse_major();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
  return _msg;
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::set_allocated_horizontal_ellipse_major(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_ellipse_major_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.horizontal_ellipse_major_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
}

// .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::has_horizontal_ellipse_minor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.horizontal_ellipse_minor_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_horizontal_ellipse_minor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.horizontal_ellipse_minor_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::horizontal_ellipse_minor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
  return _internal_horizontal_ellipse_minor();
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_set_allocated_horizontal_ellipse_minor(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_ellipse_minor_);
  }
  _impl_.horizontal_ellipse_minor_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::release_horizontal_ellipse_minor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.horizontal_ellipse_minor_;
  _impl_.horizontal_ellipse_minor_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_release_horizontal_ellipse_minor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.horizontal_ellipse_minor_;
  _impl_.horizontal_ellipse_minor_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_mutable_horizontal_ellipse_minor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.horizontal_ellipse_minor_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.horizontal_ellipse_minor_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.horizontal_ellipse_minor_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::mutable_horizontal_ellipse_minor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_horizontal_ellipse_minor();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
  return _msg;
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::set_allocated_horizontal_ellipse_minor(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_ellipse_minor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.horizontal_ellipse_minor_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
}

// .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::has_horizontal_ellipse_major_heading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.horizontal_ellipse_major_heading_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_horizontal_ellipse_major_heading() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.horizontal_ellipse_major_heading_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::horizontal_ellipse_major_heading() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
  return _internal_horizontal_ellipse_major_heading();
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_set_allocated_horizontal_ellipse_major_heading(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_ellipse_major_heading_);
  }
  _impl_.horizontal_ellipse_major_heading_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::release_horizontal_ellipse_major_heading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.horizontal_ellipse_major_heading_;
  _impl_.horizontal_ellipse_major_heading_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_release_horizontal_ellipse_major_heading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.horizontal_ellipse_major_heading_;
  _impl_.horizontal_ellipse_major_heading_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_mutable_horizontal_ellipse_major_heading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.horizontal_ellipse_major_heading_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.horizontal_ellipse_major_heading_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.horizontal_ellipse_major_heading_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::mutable_horizontal_ellipse_major_heading()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_horizontal_ellipse_major_heading();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
  return _msg;
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::set_allocated_horizontal_ellipse_major_heading(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_ellipse_major_heading_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.horizontal_ellipse_major_heading_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
}

// .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::has_vertical() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vertical_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_vertical() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.vertical_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::vertical() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
  return _internal_vertical();
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_set_allocated_vertical(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vertical_);
  }
  _impl_.vertical_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::release_vertical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Int64Value* released = _impl_.vertical_;
  _impl_.vertical_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_release_vertical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Int64Value* temp = _impl_.vertical_;
  _impl_.vertical_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_mutable_vertical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vertical_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.vertical_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.vertical_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::mutable_vertical()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_vertical();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
  return _msg;
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::set_allocated_vertical(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vertical_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.vertical_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
}

// -------------------------------------------------------------------

// PositionAndAccuracy

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic geographic_wgs84 = 1;
inline bool PositionAndAccuracy::has_geographic_wgs84() const {
  return geographic_metric_case() == kGeographicWgs84;
}
inline bool PositionAndAccuracy::_internal_has_geographic_wgs84() const {
  return geographic_metric_case() == kGeographicWgs84;
}
inline void PositionAndAccuracy::set_has_geographic_wgs84() {
  _impl_._oneof_case_[0] = kGeographicWgs84;
}
inline void PositionAndAccuracy::clear_geographic_wgs84() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (geographic_metric_case() == kGeographicWgs84) {
    if (GetArena() == nullptr) {
      delete _impl_.geographic_metric_.geographic_wgs84_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geographic_metric_.geographic_wgs84_);
    }
    clear_has_geographic_metric();
  }
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PROTOBUF_NULLABLE PositionAndAccuracy::release_geographic_wgs84() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
  if (geographic_metric_case() == kGeographicWgs84) {
    clear_has_geographic_metric();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic*>(_impl_.geographic_metric_.geographic_wgs84_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geographic_metric_.geographic_wgs84_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& PositionAndAccuracy::_internal_geographic_wgs84() const {
  return geographic_metric_case() == kGeographicWgs84 ? *reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic*>(_impl_.geographic_metric_.geographic_wgs84_) : reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Geographic_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& PositionAndAccuracy::geographic_wgs84() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
  return _internal_geographic_wgs84();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PROTOBUF_NULLABLE PositionAndAccuracy::unsafe_arena_release_geographic_wgs84() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
  if (geographic_metric_case() == kGeographicWgs84) {
    clear_has_geographic_metric();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic*>(_impl_.geographic_metric_.geographic_wgs84_);
    _impl_.geographic_metric_.geographic_wgs84_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_geographic_wgs84(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geographic_metric();
  if (value) {
    set_has_geographic_wgs84();
    _impl_.geographic_metric_.geographic_wgs84_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PROTOBUF_NONNULL PositionAndAccuracy::_internal_mutable_geographic_wgs84() {
  if (geographic_metric_case() != kGeographicWgs84) {
    clear_geographic_metric();
    set_has_geographic_wgs84();
    _impl_.geographic_metric_.geographic_wgs84_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic*>(_impl_.geographic_metric_.geographic_wgs84_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PROTOBUF_NONNULL PositionAndAccuracy::mutable_geographic_wgs84()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* _msg = _internal_mutable_geographic_wgs84();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
  return _msg;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_vehicle = 2;
inline bool PositionAndAccuracy::has_metric_vehicle() const {
  return geographic_metric_case() == kMetricVehicle;
}
inline bool PositionAndAccuracy::_internal_has_metric_vehicle() const {
  return geographic_metric_case() == kMetricVehicle;
}
inline void PositionAndAccuracy::set_has_metric_vehicle() {
  _impl_._oneof_case_[0] = kMetricVehicle;
}
inline void PositionAndAccuracy::clear_metric_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (geographic_metric_case() == kMetricVehicle) {
    if (GetArena() == nullptr) {
      delete _impl_.geographic_metric_.metric_vehicle_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geographic_metric_.metric_vehicle_);
    }
    clear_has_geographic_metric();
  }
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE PositionAndAccuracy::release_metric_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
  if (geographic_metric_case() == kMetricVehicle) {
    clear_has_geographic_metric();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(_impl_.geographic_metric_.metric_vehicle_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geographic_metric_.metric_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::_internal_metric_vehicle() const {
  return geographic_metric_case() == kMetricVehicle ? *reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(_impl_.geographic_metric_.metric_vehicle_) : reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Metric_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::metric_vehicle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
  return _internal_metric_vehicle();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE PositionAndAccuracy::unsafe_arena_release_metric_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
  if (geographic_metric_case() == kMetricVehicle) {
    clear_has_geographic_metric();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(_impl_.geographic_metric_.metric_vehicle_);
    _impl_.geographic_metric_.metric_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_metric_vehicle(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geographic_metric();
  if (value) {
    set_has_metric_vehicle();
    _impl_.geographic_metric_.metric_vehicle_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NONNULL PositionAndAccuracy::_internal_mutable_metric_vehicle() {
  if (geographic_metric_case() != kMetricVehicle) {
    clear_geographic_metric();
    set_has_metric_vehicle();
    _impl_.geographic_metric_.metric_vehicle_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(_impl_.geographic_metric_.metric_vehicle_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NONNULL PositionAndAccuracy::mutable_metric_vehicle()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* _msg = _internal_mutable_metric_vehicle();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
  return _msg;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_event_group = 3;
inline bool PositionAndAccuracy::has_metric_event_group() const {
  return geographic_metric_case() == kMetricEventGroup;
}
inline bool PositionAndAccuracy::_internal_has_metric_event_group() const {
  return geographic_metric_case() == kMetricEventGroup;
}
inline void PositionAndAccuracy::set_has_metric_event_group() {
  _impl_._oneof_case_[0] = kMetricEventGroup;
}
inline void PositionAndAccuracy::clear_metric_event_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (geographic_metric_case() == kMetricEventGroup) {
    if (GetArena() == nullptr) {
      delete _impl_.geographic_metric_.metric_event_group_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geographic_metric_.metric_event_group_);
    }
    clear_has_geographic_metric();
  }
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE PositionAndAccuracy::release_metric_event_group() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
  if (geographic_metric_case() == kMetricEventGroup) {
    clear_has_geographic_metric();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(_impl_.geographic_metric_.metric_event_group_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geographic_metric_.metric_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::_internal_metric_event_group() const {
  return geographic_metric_case() == kMetricEventGroup ? *reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(_impl_.geographic_metric_.metric_event_group_) : reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Metric_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::metric_event_group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
  return _internal_metric_event_group();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE PositionAndAccuracy::unsafe_arena_release_metric_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
  if (geographic_metric_case() == kMetricEventGroup) {
    clear_has_geographic_metric();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(_impl_.geographic_metric_.metric_event_group_);
    _impl_.geographic_metric_.metric_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_metric_event_group(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geographic_metric();
  if (value) {
    set_has_metric_event_group();
    _impl_.geographic_metric_.metric_event_group_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NONNULL PositionAndAccuracy::_internal_mutable_metric_event_group() {
  if (geographic_metric_case() != kMetricEventGroup) {
    clear_geographic_metric();
    set_has_metric_event_group();
    _impl_.geographic_metric_.metric_event_group_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(_impl_.geographic_metric_.metric_event_group_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NONNULL PositionAndAccuracy::mutable_metric_event_group()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* _msg = _internal_mutable_metric_event_group();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
  return _msg;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_ecef = 4;
inline bool PositionAndAccuracy::has_metric_ecef() const {
  return geographic_metric_case() == kMetricEcef;
}
inline bool PositionAndAccuracy::_internal_has_metric_ecef() const {
  return geographic_metric_case() == kMetricEcef;
}
inline void PositionAndAccuracy::set_has_metric_ecef() {
  _impl_._oneof_case_[0] = kMetricEcef;
}
inline void PositionAndAccuracy::clear_metric_ecef() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (geographic_metric_case() == kMetricEcef) {
    if (GetArena() == nullptr) {
      delete _impl_.geographic_metric_.metric_ecef_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geographic_metric_.metric_ecef_);
    }
    clear_has_geographic_metric();
  }
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE PositionAndAccuracy::release_metric_ecef() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
  if (geographic_metric_case() == kMetricEcef) {
    clear_has_geographic_metric();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(_impl_.geographic_metric_.metric_ecef_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geographic_metric_.metric_ecef_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::_internal_metric_ecef() const {
  return geographic_metric_case() == kMetricEcef ? *reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(_impl_.geographic_metric_.metric_ecef_) : reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Metric_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::metric_ecef() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
  return _internal_metric_ecef();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE PositionAndAccuracy::unsafe_arena_release_metric_ecef() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
  if (geographic_metric_case() == kMetricEcef) {
    clear_has_geographic_metric();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(_impl_.geographic_metric_.metric_ecef_);
    _impl_.geographic_metric_.metric_ecef_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_metric_ecef(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geographic_metric();
  if (value) {
    set_has_metric_ecef();
    _impl_.geographic_metric_.metric_ecef_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NONNULL PositionAndAccuracy::_internal_mutable_metric_ecef() {
  if (geographic_metric_case() != kMetricEcef) {
    clear_geographic_metric();
    set_has_metric_ecef();
    _impl_.geographic_metric_.metric_ecef_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(_impl_.geographic_metric_.metric_ecef_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PROTOBUF_NONNULL PositionAndAccuracy::mutable_metric_ecef()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* _msg = _internal_mutable_metric_ecef();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
  return _msg;
}

// .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy::has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline bool PositionAndAccuracy::_internal_has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline void PositionAndAccuracy::set_has_combined_std_dev() {
  _impl_._oneof_case_[1] = kCombinedStdDev;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy::release_combined_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy::_internal_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev ? *reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_) : reinterpret_cast<::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy::combined_std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
  return _internal_combined_std_dev();
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE PositionAndAccuracy::unsafe_arena_release_combined_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_);
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_combined_std_dev(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy::_internal_mutable_combined_std_dev() {
  if (accuracy_case() != kCombinedStdDev) {
    clear_accuracy();
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena()));
  }
  return reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_);
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL PositionAndAccuracy::mutable_combined_std_dev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_combined_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
  return _msg;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev std_dev = 6;
inline bool PositionAndAccuracy::has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline bool PositionAndAccuracy::_internal_has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline void PositionAndAccuracy::set_has_std_dev() {
  _impl_._oneof_case_[1] = kStdDev;
}
inline void PositionAndAccuracy::clear_std_dev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.std_dev_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.std_dev_);
    }
    clear_has_accuracy();
  }
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NULLABLE PositionAndAccuracy::release_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev*>(_impl_.accuracy_.std_dev_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& PositionAndAccuracy::_internal_std_dev() const {
  return accuracy_case() == kStdDev ? *reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev*>(_impl_.accuracy_.std_dev_) : reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& PositionAndAccuracy::std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
  return _internal_std_dev();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NULLABLE PositionAndAccuracy::unsafe_arena_release_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev*>(_impl_.accuracy_.std_dev_);
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_std_dev(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NONNULL PositionAndAccuracy::_internal_mutable_std_dev() {
  if (accuracy_case() != kStdDev) {
    clear_accuracy();
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev*>(_impl_.accuracy_.std_dev_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_NONNULL PositionAndAccuracy::mutable_std_dev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* _msg = _internal_mutable_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
  return _msg;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev horizontal_confidence_ellipse_vertical_std_dev = 7;
inline bool PositionAndAccuracy::has_horizontal_confidence_ellipse_vertical_std_dev() const {
  return accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev;
}
inline bool PositionAndAccuracy::_internal_has_horizontal_confidence_ellipse_vertical_std_dev() const {
  return accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev;
}
inline void PositionAndAccuracy::set_has_horizontal_confidence_ellipse_vertical_std_dev() {
  _impl_._oneof_case_[1] = kHorizontalConfidenceEllipseVerticalStdDev;
}
inline void PositionAndAccuracy::clear_horizontal_confidence_ellipse_vertical_std_dev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_);
    }
    clear_has_accuracy();
  }
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NULLABLE PositionAndAccuracy::release_horizontal_confidence_ellipse_vertical_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
  if (accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev*>(_impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& PositionAndAccuracy::_internal_horizontal_confidence_ellipse_vertical_std_dev() const {
  return accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev ? *reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev*>(_impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_) : reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& PositionAndAccuracy::horizontal_confidence_ellipse_vertical_std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
  return _internal_horizontal_confidence_ellipse_vertical_std_dev();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NULLABLE PositionAndAccuracy::unsafe_arena_release_horizontal_confidence_ellipse_vertical_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
  if (accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev*>(_impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_);
    _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_horizontal_confidence_ellipse_vertical_std_dev(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_horizontal_confidence_ellipse_vertical_std_dev();
    _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NONNULL PositionAndAccuracy::_internal_mutable_horizontal_confidence_ellipse_vertical_std_dev() {
  if (accuracy_case() != kHorizontalConfidenceEllipseVerticalStdDev) {
    clear_accuracy();
    set_has_horizontal_confidence_ellipse_vertical_std_dev();
    _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev*>(_impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_NONNULL PositionAndAccuracy::mutable_horizontal_confidence_ellipse_vertical_std_dev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* _msg = _internal_mutable_horizontal_confidence_ellipse_vertical_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
  return _msg;
}

// .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 8 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy::has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline bool PositionAndAccuracy::_internal_has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline void PositionAndAccuracy::set_has_covariance() {
  _impl_._oneof_case_[1] = kCovariance;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE PositionAndAccuracy::release_covariance() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& PositionAndAccuracy::_internal_covariance() const {
  return accuracy_case() == kCovariance ? *reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_) : reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3&>(::sensoris::protobuf::types::base::_Int64Matrix3x3_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& PositionAndAccuracy::covariance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
  return _internal_covariance();
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE PositionAndAccuracy::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_);
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_covariance(
    ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_covariance();
    _impl_.accuracy_.covariance_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL PositionAndAccuracy::_internal_mutable_covariance() {
  if (accuracy_case() != kCovariance) {
    clear_accuracy();
    set_has_covariance();
    _impl_.accuracy_.covariance_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Matrix3x3>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_);
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL PositionAndAccuracy::mutable_covariance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Matrix3x3* _msg = _internal_mutable_covariance();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int PositionAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int PositionAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL PositionAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL PositionAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& PositionAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL PositionAndAccuracy::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& PositionAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
PositionAndAccuracy::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
PositionAndAccuracy::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

inline bool PositionAndAccuracy::has_geographic_metric() const {
  return geographic_metric_case() != GEOGRAPHIC_METRIC_NOT_SET;
}
inline void PositionAndAccuracy::clear_has_geographic_metric() {
  _impl_._oneof_case_[0] = GEOGRAPHIC_METRIC_NOT_SET;
}
inline bool PositionAndAccuracy::has_accuracy() const {
  return accuracy_case() != ACCURACY_NOT_SET;
}
inline void PositionAndAccuracy::clear_has_accuracy() {
  _impl_._oneof_case_[1] = ACCURACY_NOT_SET;
}
inline PositionAndAccuracy::GeographicMetricCase PositionAndAccuracy::geographic_metric_case() const {
  return PositionAndAccuracy::GeographicMetricCase(_impl_._oneof_case_[0]);
}
inline PositionAndAccuracy::AccuracyCase PositionAndAccuracy::accuracy_case() const {
  return PositionAndAccuracy::AccuracyCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// PolylineAndAccuracy

// repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
inline int PolylineAndAccuracy::_internal_position_and_accuracy_size() const {
  return _internal_position_and_accuracy().size();
}
inline int PolylineAndAccuracy::position_and_accuracy_size() const {
  return _internal_position_and_accuracy_size();
}
inline void PolylineAndAccuracy::clear_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_and_accuracy_.Clear();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL PolylineAndAccuracy::mutable_position_and_accuracy(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return _internal_mutable_position_and_accuracy()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>* PROTOBUF_NONNULL PolylineAndAccuracy::mutable_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_position_and_accuracy();
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& PolylineAndAccuracy::position_and_accuracy(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return _internal_position_and_accuracy().Get(index);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL PolylineAndAccuracy::add_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _add = _internal_mutable_position_and_accuracy()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>& PolylineAndAccuracy::position_and_accuracy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>&
PolylineAndAccuracy::_internal_position_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.position_and_accuracy_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>* PROTOBUF_NONNULL
PolylineAndAccuracy::_internal_mutable_position_and_accuracy() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.position_and_accuracy_;
}

// repeated .google.protobuf.Any extension = 15;
inline int PolylineAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int PolylineAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL PolylineAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL PolylineAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& PolylineAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL PolylineAndAccuracy::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& PolylineAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
PolylineAndAccuracy::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
PolylineAndAccuracy::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// PolylineCorridorAndAccuracy

// .sensoris.protobuf.types.spatial.PolylineAndAccuracy center_polyline_and_accuracy = 1;
inline bool PolylineCorridorAndAccuracy::has_center_polyline_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_polyline_and_accuracy_ != nullptr);
  return value;
}
inline void PolylineCorridorAndAccuracy::clear_center_polyline_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.center_polyline_and_accuracy_ != nullptr) _impl_.center_polyline_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& PolylineCorridorAndAccuracy::_internal_center_polyline_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* p = _impl_.center_polyline_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy&>(::sensoris::protobuf::types::spatial::_PolylineAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& PolylineCorridorAndAccuracy::center_polyline_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.center_polyline_and_accuracy)
  return _internal_center_polyline_and_accuracy();
}
inline void PolylineCorridorAndAccuracy::unsafe_arena_set_allocated_center_polyline_and_accuracy(
    ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_polyline_and_accuracy_);
  }
  _impl_.center_polyline_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.center_polyline_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE PolylineCorridorAndAccuracy::release_center_polyline_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* released = _impl_.center_polyline_and_accuracy_;
  _impl_.center_polyline_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE PolylineCorridorAndAccuracy::unsafe_arena_release_center_polyline_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.center_polyline_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* temp = _impl_.center_polyline_and_accuracy_;
  _impl_.center_polyline_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NONNULL PolylineCorridorAndAccuracy::_internal_mutable_center_polyline_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.center_polyline_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PolylineAndAccuracy>(GetArena());
    _impl_.center_polyline_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineAndAccuracy*>(p);
  }
  return _impl_.center_polyline_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NONNULL PolylineCorridorAndAccuracy::mutable_center_polyline_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* _msg = _internal_mutable_center_polyline_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.center_polyline_and_accuracy)
  return _msg;
}
inline void PolylineCorridorAndAccuracy::set_allocated_center_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_polyline_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_polyline_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.center_polyline_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy total_width_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PolylineCorridorAndAccuracy::has_total_width_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.total_width_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& PolylineCorridorAndAccuracy::_internal_total_width_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.total_width_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& PolylineCorridorAndAccuracy::total_width_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.total_width_and_accuracy)
  return _internal_total_width_and_accuracy();
}
inline void PolylineCorridorAndAccuracy::unsafe_arena_set_allocated_total_width_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.total_width_and_accuracy_);
  }
  _impl_.total_width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.total_width_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE PolylineCorridorAndAccuracy::release_total_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.total_width_and_accuracy_;
  _impl_.total_width_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE PolylineCorridorAndAccuracy::unsafe_arena_release_total_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.total_width_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.total_width_and_accuracy_;
  _impl_.total_width_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL PolylineCorridorAndAccuracy::_internal_mutable_total_width_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.total_width_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.total_width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.total_width_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL PolylineCorridorAndAccuracy::mutable_total_width_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_total_width_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.total_width_and_accuracy)
  return _msg;
}
inline void PolylineCorridorAndAccuracy::set_allocated_total_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.total_width_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.total_width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.total_width_and_accuracy)
}

// repeated .google.protobuf.Any extension = 15;
inline int PolylineCorridorAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int PolylineCorridorAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL PolylineCorridorAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL PolylineCorridorAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& PolylineCorridorAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL PolylineCorridorAndAccuracy::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& PolylineCorridorAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
PolylineCorridorAndAccuracy::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
PolylineCorridorAndAccuracy::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// DirectedPolylineCorridor

// .sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy polyline_corridor = 1;
inline bool DirectedPolylineCorridor::has_polyline_corridor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.polyline_corridor_ != nullptr);
  return value;
}
inline void DirectedPolylineCorridor::clear_polyline_corridor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.polyline_corridor_ != nullptr) _impl_.polyline_corridor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy& DirectedPolylineCorridor::_internal_polyline_corridor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* p = _impl_.polyline_corridor_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy&>(::sensoris::protobuf::types::spatial::_PolylineCorridorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy& DirectedPolylineCorridor::polyline_corridor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.polyline_corridor)
  return _internal_polyline_corridor();
}
inline void DirectedPolylineCorridor::unsafe_arena_set_allocated_polyline_corridor(
    ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.polyline_corridor_);
  }
  _impl_.polyline_corridor_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.polyline_corridor)
}
inline ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NULLABLE DirectedPolylineCorridor::release_polyline_corridor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* released = _impl_.polyline_corridor_;
  _impl_.polyline_corridor_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NULLABLE DirectedPolylineCorridor::unsafe_arena_release_polyline_corridor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.polyline_corridor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* temp = _impl_.polyline_corridor_;
  _impl_.polyline_corridor_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NONNULL DirectedPolylineCorridor::_internal_mutable_polyline_corridor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.polyline_corridor_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy>(GetArena());
    _impl_.polyline_corridor_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy*>(p);
  }
  return _impl_.polyline_corridor_;
}
inline ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NONNULL DirectedPolylineCorridor::mutable_polyline_corridor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* _msg = _internal_mutable_polyline_corridor();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.polyline_corridor)
  return _msg;
}
inline void DirectedPolylineCorridor::set_allocated_polyline_corridor(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.polyline_corridor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.polyline_corridor_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.polyline_corridor)
}

// .google.protobuf.BoolValue is_bidirectional = 2;
inline bool DirectedPolylineCorridor::has_is_bidirectional() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.is_bidirectional_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& DirectedPolylineCorridor::_internal_is_bidirectional() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::BoolValue* p = _impl_.is_bidirectional_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& DirectedPolylineCorridor::is_bidirectional() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.is_bidirectional)
  return _internal_is_bidirectional();
}
inline void DirectedPolylineCorridor::unsafe_arena_set_allocated_is_bidirectional(
    ::google::protobuf::BoolValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.is_bidirectional_);
  }
  _impl_.is_bidirectional_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.is_bidirectional)
}
inline ::google::protobuf::BoolValue* PROTOBUF_NULLABLE DirectedPolylineCorridor::release_is_bidirectional() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::BoolValue* released = _impl_.is_bidirectional_;
  _impl_.is_bidirectional_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::BoolValue* PROTOBUF_NULLABLE DirectedPolylineCorridor::unsafe_arena_release_is_bidirectional() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.is_bidirectional)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::BoolValue* temp = _impl_.is_bidirectional_;
  _impl_.is_bidirectional_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* PROTOBUF_NONNULL DirectedPolylineCorridor::_internal_mutable_is_bidirectional() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.is_bidirectional_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::BoolValue>(GetArena());
    _impl_.is_bidirectional_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.is_bidirectional_;
}
inline ::google::protobuf::BoolValue* PROTOBUF_NONNULL DirectedPolylineCorridor::mutable_is_bidirectional()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::BoolValue* _msg = _internal_mutable_is_bidirectional();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.is_bidirectional)
  return _msg;
}
inline void DirectedPolylineCorridor::set_allocated_is_bidirectional(::google::protobuf::BoolValue* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.is_bidirectional_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.is_bidirectional_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.is_bidirectional)
}

// .google.protobuf.Int64Value heading_deviation_from_center_line = 3;
inline bool DirectedPolylineCorridor::has_heading_deviation_from_center_line() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heading_deviation_from_center_line_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& DirectedPolylineCorridor::_internal_heading_deviation_from_center_line() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.heading_deviation_from_center_line_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& DirectedPolylineCorridor::heading_deviation_from_center_line() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.heading_deviation_from_center_line)
  return _internal_heading_deviation_from_center_line();
}
inline void DirectedPolylineCorridor::unsafe_arena_set_allocated_heading_deviation_from_center_line(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.heading_deviation_from_center_line_);
  }
  _impl_.heading_deviation_from_center_line_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.heading_deviation_from_center_line)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE DirectedPolylineCorridor::release_heading_deviation_from_center_line() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.heading_deviation_from_center_line_;
  _impl_.heading_deviation_from_center_line_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE DirectedPolylineCorridor::unsafe_arena_release_heading_deviation_from_center_line() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.heading_deviation_from_center_line)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.heading_deviation_from_center_line_;
  _impl_.heading_deviation_from_center_line_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL DirectedPolylineCorridor::_internal_mutable_heading_deviation_from_center_line() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.heading_deviation_from_center_line_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.heading_deviation_from_center_line_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.heading_deviation_from_center_line_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL DirectedPolylineCorridor::mutable_heading_deviation_from_center_line()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_heading_deviation_from_center_line();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.heading_deviation_from_center_line)
  return _msg;
}
inline void DirectedPolylineCorridor::set_allocated_heading_deviation_from_center_line(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.heading_deviation_from_center_line_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.heading_deviation_from_center_line_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.heading_deviation_from_center_line)
}

// repeated .google.protobuf.Any extension = 15;
inline int DirectedPolylineCorridor::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int DirectedPolylineCorridor::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL DirectedPolylineCorridor::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL DirectedPolylineCorridor::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& DirectedPolylineCorridor::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL DirectedPolylineCorridor::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& DirectedPolylineCorridor::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
DirectedPolylineCorridor::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
DirectedPolylineCorridor::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// CircleAndAccuracy

// .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
inline bool CircleAndAccuracy::has_center_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_position_and_accuracy_ != nullptr);
  return value;
}
inline void CircleAndAccuracy::clear_center_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.center_position_and_accuracy_ != nullptr) _impl_.center_position_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& CircleAndAccuracy::_internal_center_position_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.center_position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& CircleAndAccuracy::center_position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.CircleAndAccuracy.center_position_and_accuracy)
  return _internal_center_position_and_accuracy();
}
inline void CircleAndAccuracy::unsafe_arena_set_allocated_center_position_and_accuracy(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_position_and_accuracy_);
  }
  _impl_.center_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.CircleAndAccuracy.center_position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE CircleAndAccuracy::release_center_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.center_position_and_accuracy_;
  _impl_.center_position_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE CircleAndAccuracy::unsafe_arena_release_center_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.CircleAndAccuracy.center_position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.center_position_and_accuracy_;
  _impl_.center_position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL CircleAndAccuracy::_internal_mutable_center_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.center_position_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.center_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.center_position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL CircleAndAccuracy::mutable_center_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_center_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.CircleAndAccuracy.center_position_and_accuracy)
  return _msg;
}
inline void CircleAndAccuracy::set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.CircleAndAccuracy.center_position_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy radius_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool CircleAndAccuracy::has_radius_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.radius_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& CircleAndAccuracy::_internal_radius_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.radius_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& CircleAndAccuracy::radius_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.CircleAndAccuracy.radius_and_accuracy)
  return _internal_radius_and_accuracy();
}
inline void CircleAndAccuracy::unsafe_arena_set_allocated_radius_and_accuracy(
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.radius_and_accuracy_);
  }
  _impl_.radius_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.CircleAndAccuracy.radius_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE CircleAndAccuracy::release_radius_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.radius_and_accuracy_;
  _impl_.radius_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE CircleAndAccuracy::unsafe_arena_release_radius_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.CircleAndAccuracy.radius_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.radius_and_accuracy_;
  _impl_.radius_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL CircleAndAccuracy::_internal_mutable_radius_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.radius_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.radius_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.radius_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NONNULL CircleAndAccuracy::mutable_radius_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_radius_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.CircleAndAccuracy.radius_and_accuracy)
  return _msg;
}
inline void CircleAndAccuracy::set_allocated_radius_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.radius_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.radius_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.CircleAndAccuracy.radius_and_accuracy)
}

// repeated .google.protobuf.Any extension = 15;
inline int CircleAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int CircleAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL CircleAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.CircleAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL CircleAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.CircleAndAccuracy.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& CircleAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.CircleAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL CircleAndAccuracy::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.CircleAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& CircleAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.CircleAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
CircleAndAccuracy::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
CircleAndAccuracy::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// RectangleAndAccuracy

// .sensoris.protobuf.types.spatial.PositionAndAccuracy minimum_position_and_accuracy = 1;
inline bool RectangleAndAccuracy::has_minimum_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.minimum_position_and_accuracy_ != nullptr);
  return value;
}
inline void RectangleAndAccuracy::clear_minimum_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.minimum_position_and_accuracy_ != nullptr) _impl_.minimum_position_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangleAndAccuracy::_internal_minimum_position_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.minimum_position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangleAndAccuracy::minimum_position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangleAndAccuracy.minimum_position_and_accuracy)
  return _internal_minimum_position_and_accuracy();
}
inline void RectangleAndAccuracy::unsafe_arena_set_allocated_minimum_position_and_accuracy(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.minimum_position_and_accuracy_);
  }
  _impl_.minimum_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangleAndAccuracy.minimum_position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE RectangleAndAccuracy::release_minimum_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.minimum_position_and_accuracy_;
  _impl_.minimum_position_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE RectangleAndAccuracy::unsafe_arena_release_minimum_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangleAndAccuracy.minimum_position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.minimum_position_and_accuracy_;
  _impl_.minimum_position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL RectangleAndAccuracy::_internal_mutable_minimum_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.minimum_position_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.minimum_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.minimum_position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL RectangleAndAccuracy::mutable_minimum_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_minimum_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangleAndAccuracy.minimum_position_and_accuracy)
  return _msg;
}
inline void RectangleAndAccuracy::set_allocated_minimum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.minimum_position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.minimum_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangleAndAccuracy.minimum_position_and_accuracy)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy maximum_position_and_accuracy = 2;
inline bool RectangleAndAccuracy::has_maximum_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.maximum_position_and_accuracy_ != nullptr);
  return value;
}
inline void RectangleAndAccuracy::clear_maximum_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.maximum_position_and_accuracy_ != nullptr) _impl_.maximum_position_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangleAndAccuracy::_internal_maximum_position_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.maximum_position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangleAndAccuracy::maximum_position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangleAndAccuracy.maximum_position_and_accuracy)
  return _internal_maximum_position_and_accuracy();
}
inline void RectangleAndAccuracy::unsafe_arena_set_allocated_maximum_position_and_accuracy(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.maximum_position_and_accuracy_);
  }
  _impl_.maximum_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangleAndAccuracy.maximum_position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE RectangleAndAccuracy::release_maximum_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.maximum_position_and_accuracy_;
  _impl_.maximum_position_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE RectangleAndAccuracy::unsafe_arena_release_maximum_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangleAndAccuracy.maximum_position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.maximum_position_and_accuracy_;
  _impl_.maximum_position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL RectangleAndAccuracy::_internal_mutable_maximum_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.maximum_position_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.maximum_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.maximum_position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL RectangleAndAccuracy::mutable_maximum_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_maximum_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangleAndAccuracy.maximum_position_and_accuracy)
  return _msg;
}
inline void RectangleAndAccuracy::set_allocated_maximum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.maximum_position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.maximum_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangleAndAccuracy.maximum_position_and_accuracy)
}

// repeated .google.protobuf.Any extension = 15;
inline int RectangleAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int RectangleAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL RectangleAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangleAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL RectangleAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.RectangleAndAccuracy.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& RectangleAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangleAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL RectangleAndAccuracy::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.RectangleAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& RectangleAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.RectangleAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
RectangleAndAccuracy::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
RectangleAndAccuracy::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// PolygonAndAccuracy

// repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
inline int PolygonAndAccuracy::_internal_position_and_accuracy_size() const {
  return _internal_position_and_accuracy().size();
}
inline int PolygonAndAccuracy::position_and_accuracy_size() const {
  return _internal_position_and_accuracy_size();
}
inline void PolygonAndAccuracy::clear_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_and_accuracy_.Clear();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL PolygonAndAccuracy::mutable_position_and_accuracy(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolygonAndAccuracy.position_and_accuracy)
  return _internal_mutable_position_and_accuracy()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>* PROTOBUF_NONNULL PolygonAndAccuracy::mutable_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PolygonAndAccuracy.position_and_accuracy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_position_and_accuracy();
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& PolygonAndAccuracy::position_and_accuracy(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolygonAndAccuracy.position_and_accuracy)
  return _internal_position_and_accuracy().Get(index);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL PolygonAndAccuracy::add_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _add = _internal_mutable_position_and_accuracy()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PolygonAndAccuracy.position_and_accuracy)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>& PolygonAndAccuracy::position_and_accuracy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PolygonAndAccuracy.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>&
PolygonAndAccuracy::_internal_position_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.position_and_accuracy_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>* PROTOBUF_NONNULL
PolygonAndAccuracy::_internal_mutable_position_and_accuracy() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.position_and_accuracy_;
}

// repeated .google.protobuf.Any extension = 15;
inline int PolygonAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int PolygonAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL PolygonAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolygonAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL PolygonAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PolygonAndAccuracy.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& PolygonAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolygonAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL PolygonAndAccuracy::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PolygonAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& PolygonAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PolygonAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
PolygonAndAccuracy::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
PolygonAndAccuracy::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// XyzVectorAndAccuracy_StdDev

// .google.protobuf.Int64Value x = 1;
inline bool XyzVectorAndAccuracy_StdDev::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::x() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
  return _internal_x();
}
inline void XyzVectorAndAccuracy_StdDev::unsafe_arena_set_allocated_x(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy_StdDev::release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.x_;
  _impl_.x_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy_StdDev::unsafe_arena_release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy_StdDev::_internal_mutable_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.x_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.x_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy_StdDev::mutable_x()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
  return _msg;
}
inline void XyzVectorAndAccuracy_StdDev::set_allocated_x(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
}

// .google.protobuf.Int64Value y = 2;
inline bool XyzVectorAndAccuracy_StdDev::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.y_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::y() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
  return _internal_y();
}
inline void XyzVectorAndAccuracy_StdDev::unsafe_arena_set_allocated_y(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy_StdDev::release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.y_;
  _impl_.y_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy_StdDev::unsafe_arena_release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy_StdDev::_internal_mutable_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.y_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.y_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy_StdDev::mutable_y()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
  return _msg;
}
inline void XyzVectorAndAccuracy_StdDev::set_allocated_y(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.y_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
}

// .google.protobuf.Int64Value z = 3;
inline bool XyzVectorAndAccuracy_StdDev::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.z_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.z_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::z() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
  return _internal_z();
}
inline void XyzVectorAndAccuracy_StdDev::unsafe_arena_set_allocated_z(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }
  _impl_.z_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy_StdDev::release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.z_;
  _impl_.z_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy_StdDev::unsafe_arena_release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.z_;
  _impl_.z_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy_StdDev::_internal_mutable_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.z_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.z_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy_StdDev::mutable_z()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
  return _msg;
}
inline void XyzVectorAndAccuracy_StdDev::set_allocated_z(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.z_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
}

// -------------------------------------------------------------------

// XyzVectorAndAccuracy_Metric

// .sensoris.protobuf.types.base.Int64Value x = 1;
inline bool XyzVectorAndAccuracy_Metric::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::x() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
  return _internal_x();
}
inline void XyzVectorAndAccuracy_Metric::unsafe_arena_set_allocated_x(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy_Metric::release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.x_;
  _impl_.x_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy_Metric::unsafe_arena_release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy_Metric::_internal_mutable_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.x_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy_Metric::mutable_x()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
  return _msg;
}
inline void XyzVectorAndAccuracy_Metric::set_allocated_x(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
}

// .sensoris.protobuf.types.base.Int64Value y = 2;
inline bool XyzVectorAndAccuracy_Metric::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.y_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::y() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
  return _internal_y();
}
inline void XyzVectorAndAccuracy_Metric::unsafe_arena_set_allocated_y(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy_Metric::release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.y_;
  _impl_.y_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy_Metric::unsafe_arena_release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy_Metric::_internal_mutable_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.y_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy_Metric::mutable_y()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
  return _msg;
}
inline void XyzVectorAndAccuracy_Metric::set_allocated_y(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
}

// .sensoris.protobuf.types.base.Int64Value z = 3;
inline bool XyzVectorAndAccuracy_Metric::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.z_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.z_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::z() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
  return _internal_z();
}
inline void XyzVectorAndAccuracy_Metric::unsafe_arena_set_allocated_z(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }
  _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy_Metric::release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.z_;
  _impl_.z_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy_Metric::unsafe_arena_release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.z_;
  _impl_.z_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy_Metric::_internal_mutable_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.z_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy_Metric::mutable_z()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
  return _msg;
}
inline void XyzVectorAndAccuracy_Metric::set_allocated_z(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
}

// -------------------------------------------------------------------

// XyzVectorAndAccuracy

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_vehicle = 1;
inline bool XyzVectorAndAccuracy::has_metric_vehicle() const {
  return geometry_case() == kMetricVehicle;
}
inline bool XyzVectorAndAccuracy::_internal_has_metric_vehicle() const {
  return geometry_case() == kMetricVehicle;
}
inline void XyzVectorAndAccuracy::set_has_metric_vehicle() {
  _impl_._oneof_case_[0] = kMetricVehicle;
}
inline void XyzVectorAndAccuracy::clear_metric_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (geometry_case() == kMetricVehicle) {
    if (GetArena() == nullptr) {
      delete _impl_.geometry_.metric_vehicle_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geometry_.metric_vehicle_);
    }
    clear_has_geometry();
  }
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE XyzVectorAndAccuracy::release_metric_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
  if (geometry_case() == kMetricVehicle) {
    clear_has_geometry();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(_impl_.geometry_.metric_vehicle_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.metric_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::_internal_metric_vehicle() const {
  return geometry_case() == kMetricVehicle ? *reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(_impl_.geometry_.metric_vehicle_) : reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_Metric_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::metric_vehicle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
  return _internal_metric_vehicle();
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE XyzVectorAndAccuracy::unsafe_arena_release_metric_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
  if (geometry_case() == kMetricVehicle) {
    clear_has_geometry();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(_impl_.geometry_.metric_vehicle_);
    _impl_.geometry_.metric_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_metric_vehicle(
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geometry();
  if (value) {
    set_has_metric_vehicle();
    _impl_.geometry_.metric_vehicle_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL XyzVectorAndAccuracy::_internal_mutable_metric_vehicle() {
  if (geometry_case() != kMetricVehicle) {
    clear_geometry();
    set_has_metric_vehicle();
    _impl_.geometry_.metric_vehicle_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(_impl_.geometry_.metric_vehicle_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL XyzVectorAndAccuracy::mutable_metric_vehicle()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* _msg = _internal_mutable_metric_vehicle();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
  return _msg;
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_event_group = 2;
inline bool XyzVectorAndAccuracy::has_metric_event_group() const {
  return geometry_case() == kMetricEventGroup;
}
inline bool XyzVectorAndAccuracy::_internal_has_metric_event_group() const {
  return geometry_case() == kMetricEventGroup;
}
inline void XyzVectorAndAccuracy::set_has_metric_event_group() {
  _impl_._oneof_case_[0] = kMetricEventGroup;
}
inline void XyzVectorAndAccuracy::clear_metric_event_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (geometry_case() == kMetricEventGroup) {
    if (GetArena() == nullptr) {
      delete _impl_.geometry_.metric_event_group_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geometry_.metric_event_group_);
    }
    clear_has_geometry();
  }
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE XyzVectorAndAccuracy::release_metric_event_group() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
  if (geometry_case() == kMetricEventGroup) {
    clear_has_geometry();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(_impl_.geometry_.metric_event_group_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.metric_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::_internal_metric_event_group() const {
  return geometry_case() == kMetricEventGroup ? *reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(_impl_.geometry_.metric_event_group_) : reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_Metric_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::metric_event_group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
  return _internal_metric_event_group();
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE XyzVectorAndAccuracy::unsafe_arena_release_metric_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
  if (geometry_case() == kMetricEventGroup) {
    clear_has_geometry();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(_impl_.geometry_.metric_event_group_);
    _impl_.geometry_.metric_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_metric_event_group(
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geometry();
  if (value) {
    set_has_metric_event_group();
    _impl_.geometry_.metric_event_group_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL XyzVectorAndAccuracy::_internal_mutable_metric_event_group() {
  if (geometry_case() != kMetricEventGroup) {
    clear_geometry();
    set_has_metric_event_group();
    _impl_.geometry_.metric_event_group_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(_impl_.geometry_.metric_event_group_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL XyzVectorAndAccuracy::mutable_metric_event_group()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* _msg = _internal_mutable_metric_event_group();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
  return _msg;
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_origin = 3;
inline bool XyzVectorAndAccuracy::has_metric_origin() const {
  return geometry_case() == kMetricOrigin;
}
inline bool XyzVectorAndAccuracy::_internal_has_metric_origin() const {
  return geometry_case() == kMetricOrigin;
}
inline void XyzVectorAndAccuracy::set_has_metric_origin() {
  _impl_._oneof_case_[0] = kMetricOrigin;
}
inline void XyzVectorAndAccuracy::clear_metric_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (geometry_case() == kMetricOrigin) {
    if (GetArena() == nullptr) {
      delete _impl_.geometry_.metric_origin_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geometry_.metric_origin_);
    }
    clear_has_geometry();
  }
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE XyzVectorAndAccuracy::release_metric_origin() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
  if (geometry_case() == kMetricOrigin) {
    clear_has_geometry();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(_impl_.geometry_.metric_origin_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.metric_origin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::_internal_metric_origin() const {
  return geometry_case() == kMetricOrigin ? *reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(_impl_.geometry_.metric_origin_) : reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_Metric_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::metric_origin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
  return _internal_metric_origin();
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE XyzVectorAndAccuracy::unsafe_arena_release_metric_origin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
  if (geometry_case() == kMetricOrigin) {
    clear_has_geometry();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(_impl_.geometry_.metric_origin_);
    _impl_.geometry_.metric_origin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_metric_origin(
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geometry();
  if (value) {
    set_has_metric_origin();
    _impl_.geometry_.metric_origin_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL XyzVectorAndAccuracy::_internal_mutable_metric_origin() {
  if (geometry_case() != kMetricOrigin) {
    clear_geometry();
    set_has_metric_origin();
    _impl_.geometry_.metric_origin_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(_impl_.geometry_.metric_origin_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* PROTOBUF_NONNULL XyzVectorAndAccuracy::mutable_metric_origin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* _msg = _internal_mutable_metric_origin();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
  return _msg;
}

// .google.protobuf.Int64Value combined_std_dev = 4;
inline bool XyzVectorAndAccuracy::has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline bool XyzVectorAndAccuracy::_internal_has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline void XyzVectorAndAccuracy::set_has_combined_std_dev() {
  _impl_._oneof_case_[1] = kCombinedStdDev;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy::release_combined_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy::_internal_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev ? *reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_) : reinterpret_cast<::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy::combined_std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
  return _internal_combined_std_dev();
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE XyzVectorAndAccuracy::unsafe_arena_release_combined_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_);
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_combined_std_dev(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy::_internal_mutable_combined_std_dev() {
  if (accuracy_case() != kCombinedStdDev) {
    clear_accuracy();
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena()));
  }
  return reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_);
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL XyzVectorAndAccuracy::mutable_combined_std_dev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_combined_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
  return _msg;
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev std_dev = 5;
inline bool XyzVectorAndAccuracy::has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline bool XyzVectorAndAccuracy::_internal_has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline void XyzVectorAndAccuracy::set_has_std_dev() {
  _impl_._oneof_case_[1] = kStdDev;
}
inline void XyzVectorAndAccuracy::clear_std_dev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.std_dev_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.std_dev_);
    }
    clear_has_accuracy();
  }
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* PROTOBUF_NULLABLE XyzVectorAndAccuracy::release_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev*>(_impl_.accuracy_.std_dev_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& XyzVectorAndAccuracy::_internal_std_dev() const {
  return accuracy_case() == kStdDev ? *reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev*>(_impl_.accuracy_.std_dev_) : reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_StdDev_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& XyzVectorAndAccuracy::std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
  return _internal_std_dev();
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* PROTOBUF_NULLABLE XyzVectorAndAccuracy::unsafe_arena_release_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev*>(_impl_.accuracy_.std_dev_);
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_std_dev(
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* PROTOBUF_NONNULL XyzVectorAndAccuracy::_internal_mutable_std_dev() {
  if (accuracy_case() != kStdDev) {
    clear_accuracy();
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev*>(_impl_.accuracy_.std_dev_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* PROTOBUF_NONNULL XyzVectorAndAccuracy::mutable_std_dev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* _msg = _internal_mutable_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
  return _msg;
}

// .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6;
inline bool XyzVectorAndAccuracy::has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline bool XyzVectorAndAccuracy::_internal_has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline void XyzVectorAndAccuracy::set_has_covariance() {
  _impl_._oneof_case_[1] = kCovariance;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE XyzVectorAndAccuracy::release_covariance() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& XyzVectorAndAccuracy::_internal_covariance() const {
  return accuracy_case() == kCovariance ? *reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_) : reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3&>(::sensoris::protobuf::types::base::_Int64Matrix3x3_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& XyzVectorAndAccuracy::covariance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
  return _internal_covariance();
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE XyzVectorAndAccuracy::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_);
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_covariance(
    ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_covariance();
    _impl_.accuracy_.covariance_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL XyzVectorAndAccuracy::_internal_mutable_covariance() {
  if (accuracy_case() != kCovariance) {
    clear_accuracy();
    set_has_covariance();
    _impl_.accuracy_.covariance_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Matrix3x3>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_);
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL XyzVectorAndAccuracy::mutable_covariance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Matrix3x3* _msg = _internal_mutable_covariance();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int XyzVectorAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int XyzVectorAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL XyzVectorAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL XyzVectorAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& XyzVectorAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL XyzVectorAndAccuracy::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& XyzVectorAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
XyzVectorAndAccuracy::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
XyzVectorAndAccuracy::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

inline bool XyzVectorAndAccuracy::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void XyzVectorAndAccuracy::clear_has_geometry() {
  _impl_._oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline bool XyzVectorAndAccuracy::has_accuracy() const {
  return accuracy_case() != ACCURACY_NOT_SET;
}
inline void XyzVectorAndAccuracy::clear_has_accuracy() {
  _impl_._oneof_case_[1] = ACCURACY_NOT_SET;
}
inline XyzVectorAndAccuracy::GeometryCase XyzVectorAndAccuracy::geometry_case() const {
  return XyzVectorAndAccuracy::GeometryCase(_impl_._oneof_case_[0]);
}
inline XyzVectorAndAccuracy::AccuracyCase XyzVectorAndAccuracy::accuracy_case() const {
  return XyzVectorAndAccuracy::AccuracyCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// RectangularBoxAndAccuracy_CornerVectors

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool RectangularBoxAndAccuracy_CornerVectors::has_first_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.first_and_accuracy_ != nullptr);
  return value;
}
inline void RectangularBoxAndAccuracy_CornerVectors::clear_first_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.first_and_accuracy_ != nullptr) _impl_.first_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::_internal_first_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.first_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::first_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
  return _internal_first_and_accuracy();
}
inline void RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_set_allocated_first_and_accuracy(
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.first_and_accuracy_);
  }
  _impl_.first_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE RectangularBoxAndAccuracy_CornerVectors::release_first_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.first_and_accuracy_;
  _impl_.first_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_release_first_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.first_and_accuracy_;
  _impl_.first_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CornerVectors::_internal_mutable_first_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.first_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.first_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.first_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CornerVectors::mutable_first_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_first_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
  return _msg;
}
inline void RectangularBoxAndAccuracy_CornerVectors::set_allocated_first_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.first_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.first_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool RectangularBoxAndAccuracy_CornerVectors::has_second_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.second_and_accuracy_ != nullptr);
  return value;
}
inline void RectangularBoxAndAccuracy_CornerVectors::clear_second_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.second_and_accuracy_ != nullptr) _impl_.second_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::_internal_second_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.second_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::second_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
  return _internal_second_and_accuracy();
}
inline void RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_set_allocated_second_and_accuracy(
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.second_and_accuracy_);
  }
  _impl_.second_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE RectangularBoxAndAccuracy_CornerVectors::release_second_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.second_and_accuracy_;
  _impl_.second_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_release_second_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.second_and_accuracy_;
  _impl_.second_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CornerVectors::_internal_mutable_second_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.second_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.second_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.second_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CornerVectors::mutable_second_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_second_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
  return _msg;
}
inline void RectangularBoxAndAccuracy_CornerVectors::set_allocated_second_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.second_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.second_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool RectangularBoxAndAccuracy_CornerVectors::has_third_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.third_and_accuracy_ != nullptr);
  return value;
}
inline void RectangularBoxAndAccuracy_CornerVectors::clear_third_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.third_and_accuracy_ != nullptr) _impl_.third_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::_internal_third_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.third_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::third_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
  return _internal_third_and_accuracy();
}
inline void RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_set_allocated_third_and_accuracy(
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.third_and_accuracy_);
  }
  _impl_.third_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE RectangularBoxAndAccuracy_CornerVectors::release_third_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.third_and_accuracy_;
  _impl_.third_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_release_third_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.third_and_accuracy_;
  _impl_.third_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CornerVectors::_internal_mutable_third_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.third_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.third_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.third_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CornerVectors::mutable_third_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_third_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
  return _msg;
}
inline void RectangularBoxAndAccuracy_CornerVectors::set_allocated_third_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.third_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.third_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
}

// -------------------------------------------------------------------

// RectangularBoxAndAccuracy_CenterOrientationSize

// .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
inline bool RectangularBoxAndAccuracy_CenterOrientationSize::has_center_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_position_and_accuracy_ != nullptr);
  return value;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::clear_center_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.center_position_and_accuracy_ != nullptr) _impl_.center_position_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::_internal_center_position_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.center_position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::center_position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
  return _internal_center_position_and_accuracy();
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_set_allocated_center_position_and_accuracy(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_position_and_accuracy_);
  }
  _impl_.center_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE RectangularBoxAndAccuracy_CenterOrientationSize::release_center_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.center_position_and_accuracy_;
  _impl_.center_position_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_release_center_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.center_position_and_accuracy_;
  _impl_.center_position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CenterOrientationSize::_internal_mutable_center_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.center_position_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.center_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.center_position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CenterOrientationSize::mutable_center_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_center_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
  return _msg;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
inline bool RectangularBoxAndAccuracy_CenterOrientationSize::has_orientation_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_and_accuracy_ != nullptr);
  return value;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::clear_orientation_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_and_accuracy_ != nullptr) _impl_.orientation_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::_internal_orientation_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy* p = _impl_.orientation_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::RotationAndAccuracy&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::orientation_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
  return _internal_orientation_and_accuracy();
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_set_allocated_orientation_and_accuracy(
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_and_accuracy_);
  }
  _impl_.orientation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE RectangularBoxAndAccuracy_CenterOrientationSize::release_orientation_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* released = _impl_.orientation_and_accuracy_;
  _impl_.orientation_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_release_orientation_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* temp = _impl_.orientation_and_accuracy_;
  _impl_.orientation_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CenterOrientationSize::_internal_mutable_orientation_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::RotationAndAccuracy>(GetArena());
    _impl_.orientation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(p);
  }
  return _impl_.orientation_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CenterOrientationSize::mutable_orientation_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* _msg = _internal_mutable_orientation_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
  return _msg;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.orientation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool RectangularBoxAndAccuracy_CenterOrientationSize::has_size_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.size_and_accuracy_ != nullptr);
  return value;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::clear_size_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.size_and_accuracy_ != nullptr) _impl_.size_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::_internal_size_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.size_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::size_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
  return _internal_size_and_accuracy();
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_set_allocated_size_and_accuracy(
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.size_and_accuracy_);
  }
  _impl_.size_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE RectangularBoxAndAccuracy_CenterOrientationSize::release_size_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.size_and_accuracy_;
  _impl_.size_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_release_size_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.size_and_accuracy_;
  _impl_.size_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CenterOrientationSize::_internal_mutable_size_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.size_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.size_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.size_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NONNULL RectangularBoxAndAccuracy_CenterOrientationSize::mutable_size_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_size_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
  return _msg;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::set_allocated_size_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.size_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.size_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
}

// -------------------------------------------------------------------

// RectangularBoxAndAccuracy

// .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors corner_vectors = 1;
inline bool RectangularBoxAndAccuracy::has_corner_vectors() const {
  return geometry_case() == kCornerVectors;
}
inline bool RectangularBoxAndAccuracy::_internal_has_corner_vectors() const {
  return geometry_case() == kCornerVectors;
}
inline void RectangularBoxAndAccuracy::set_has_corner_vectors() {
  _impl_._oneof_case_[0] = kCornerVectors;
}
inline void RectangularBoxAndAccuracy::clear_corner_vectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (geometry_case() == kCornerVectors) {
    if (GetArena() == nullptr) {
      delete _impl_.geometry_.corner_vectors_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geometry_.corner_vectors_);
    }
    clear_has_geometry();
  }
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NULLABLE RectangularBoxAndAccuracy::release_corner_vectors() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
  if (geometry_case() == kCornerVectors) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.corner_vectors_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.corner_vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& RectangularBoxAndAccuracy::_internal_corner_vectors() const {
  return geometry_case() == kCornerVectors ? *_impl_.geometry_.corner_vectors_ : reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors&>(::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_CornerVectors_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& RectangularBoxAndAccuracy::corner_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
  return _internal_corner_vectors();
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NULLABLE RectangularBoxAndAccuracy::unsafe_arena_release_corner_vectors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
  if (geometry_case() == kCornerVectors) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.corner_vectors_;
    _impl_.geometry_.corner_vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RectangularBoxAndAccuracy::unsafe_arena_set_allocated_corner_vectors(
    ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geometry();
  if (value) {
    set_has_corner_vectors();
    _impl_.geometry_.corner_vectors_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NONNULL RectangularBoxAndAccuracy::_internal_mutable_corner_vectors() {
  if (geometry_case() != kCornerVectors) {
    clear_geometry();
    set_has_corner_vectors();
    _impl_.geometry_.corner_vectors_ = 
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors>(GetArena());
  }
  return _impl_.geometry_.corner_vectors_;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_NONNULL RectangularBoxAndAccuracy::mutable_corner_vectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* _msg = _internal_mutable_corner_vectors();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
  return _msg;
}

// .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize center_orientation_size = 2;
inline bool RectangularBoxAndAccuracy::has_center_orientation_size() const {
  return geometry_case() == kCenterOrientationSize;
}
inline bool RectangularBoxAndAccuracy::_internal_has_center_orientation_size() const {
  return geometry_case() == kCenterOrientationSize;
}
inline void RectangularBoxAndAccuracy::set_has_center_orientation_size() {
  _impl_._oneof_case_[0] = kCenterOrientationSize;
}
inline void RectangularBoxAndAccuracy::clear_center_orientation_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (geometry_case() == kCenterOrientationSize) {
    if (GetArena() == nullptr) {
      delete _impl_.geometry_.center_orientation_size_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.geometry_.center_orientation_size_);
    }
    clear_has_geometry();
  }
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NULLABLE RectangularBoxAndAccuracy::release_center_orientation_size() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
  if (geometry_case() == kCenterOrientationSize) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.center_orientation_size_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.center_orientation_size_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& RectangularBoxAndAccuracy::_internal_center_orientation_size() const {
  return geometry_case() == kCenterOrientationSize ? *_impl_.geometry_.center_orientation_size_ : reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize&>(::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& RectangularBoxAndAccuracy::center_orientation_size() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
  return _internal_center_orientation_size();
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NULLABLE RectangularBoxAndAccuracy::unsafe_arena_release_center_orientation_size() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
  if (geometry_case() == kCenterOrientationSize) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.center_orientation_size_;
    _impl_.geometry_.center_orientation_size_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RectangularBoxAndAccuracy::unsafe_arena_set_allocated_center_orientation_size(
    ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geometry();
  if (value) {
    set_has_center_orientation_size();
    _impl_.geometry_.center_orientation_size_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NONNULL RectangularBoxAndAccuracy::_internal_mutable_center_orientation_size() {
  if (geometry_case() != kCenterOrientationSize) {
    clear_geometry();
    set_has_center_orientation_size();
    _impl_.geometry_.center_orientation_size_ = 
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize>(GetArena());
  }
  return _impl_.geometry_.center_orientation_size_;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_NONNULL RectangularBoxAndAccuracy::mutable_center_orientation_size()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* _msg = _internal_mutable_center_orientation_size();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int RectangularBoxAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int RectangularBoxAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL RectangularBoxAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL RectangularBoxAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& RectangularBoxAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL RectangularBoxAndAccuracy::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& RectangularBoxAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
RectangularBoxAndAccuracy::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
RectangularBoxAndAccuracy::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

inline bool RectangularBoxAndAccuracy::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void RectangularBoxAndAccuracy::clear_has_geometry() {
  _impl_._oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline RectangularBoxAndAccuracy::GeometryCase RectangularBoxAndAccuracy::geometry_case() const {
  return RectangularBoxAndAccuracy::GeometryCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RotationAndAccuracy_Euler

// .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_Euler::has_yaw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.yaw_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::_internal_yaw() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.yaw_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::yaw() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
  return _internal_yaw();
}
inline void RotationAndAccuracy_Euler::unsafe_arena_set_allocated_yaw(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }
  _impl_.yaw_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Euler::release_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Euler::unsafe_arena_release_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Euler::_internal_mutable_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.yaw_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.yaw_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.yaw_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Euler::mutable_yaw()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_yaw();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
  return _msg;
}
inline void RotationAndAccuracy_Euler::set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.yaw_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
}

// .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_Euler::has_pitch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pitch_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::_internal_pitch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.pitch_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::pitch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
  return _internal_pitch();
}
inline void RotationAndAccuracy_Euler::unsafe_arena_set_allocated_pitch(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }
  _impl_.pitch_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Euler::release_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Euler::unsafe_arena_release_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Euler::_internal_mutable_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pitch_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.pitch_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.pitch_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Euler::mutable_pitch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_pitch();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
  return _msg;
}
inline void RotationAndAccuracy_Euler::set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pitch_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
}

// .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_Euler::has_roll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.roll_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::_internal_roll() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.roll_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::roll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
  return _internal_roll();
}
inline void RotationAndAccuracy_Euler::unsafe_arena_set_allocated_roll(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }
  _impl_.roll_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Euler::release_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.roll_;
  _impl_.roll_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Euler::unsafe_arena_release_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.roll_;
  _impl_.roll_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Euler::_internal_mutable_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.roll_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.roll_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.roll_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Euler::mutable_roll()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_roll();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
  return _msg;
}
inline void RotationAndAccuracy_Euler::set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.roll_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
}

// -------------------------------------------------------------------

// RotationAndAccuracy_Quaternion

// .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool RotationAndAccuracy_Quaternion::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::x() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
  return _internal_x();
}
inline void RotationAndAccuracy_Quaternion::unsafe_arena_set_allocated_x(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Quaternion::release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.x_;
  _impl_.x_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Quaternion::unsafe_arena_release_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Quaternion::_internal_mutable_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.x_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.x_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Quaternion::mutable_x()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
  return _msg;
}
inline void RotationAndAccuracy_Quaternion::set_allocated_x(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
}

// .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool RotationAndAccuracy_Quaternion::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.y_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::y() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
  return _internal_y();
}
inline void RotationAndAccuracy_Quaternion::unsafe_arena_set_allocated_y(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Quaternion::release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.y_;
  _impl_.y_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Quaternion::unsafe_arena_release_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Quaternion::_internal_mutable_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.y_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.y_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Quaternion::mutable_y()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
  return _msg;
}
inline void RotationAndAccuracy_Quaternion::set_allocated_y(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
}

// .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool RotationAndAccuracy_Quaternion::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.z_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.z_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::z() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
  return _internal_z();
}
inline void RotationAndAccuracy_Quaternion::unsafe_arena_set_allocated_z(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }
  _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Quaternion::release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.z_;
  _impl_.z_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Quaternion::unsafe_arena_release_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.z_;
  _impl_.z_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Quaternion::_internal_mutable_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.z_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Quaternion::mutable_z()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
  return _msg;
}
inline void RotationAndAccuracy_Quaternion::set_allocated_z(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
}

// .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool RotationAndAccuracy_Quaternion::has_w() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.w_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_internal_w() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.w_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::w() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
  return _internal_w();
}
inline void RotationAndAccuracy_Quaternion::unsafe_arena_set_allocated_w(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.w_);
  }
  _impl_.w_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Quaternion::release_w() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.w_;
  _impl_.w_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_Quaternion::unsafe_arena_release_w() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.w_;
  _impl_.w_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Quaternion::_internal_mutable_w() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.w_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.w_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.w_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_Quaternion::mutable_w()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
  return _msg;
}
inline void RotationAndAccuracy_Quaternion::set_allocated_w(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.w_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.w_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
}

// -------------------------------------------------------------------

// RotationAndAccuracy_StdDev

// .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_StdDev::has_yaw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.yaw_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::_internal_yaw() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.yaw_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::yaw() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
  return _internal_yaw();
}
inline void RotationAndAccuracy_StdDev::unsafe_arena_set_allocated_yaw(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }
  _impl_.yaw_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_StdDev::release_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_StdDev::unsafe_arena_release_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_StdDev::_internal_mutable_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.yaw_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.yaw_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.yaw_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_StdDev::mutable_yaw()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_yaw();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
  return _msg;
}
inline void RotationAndAccuracy_StdDev::set_allocated_yaw(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.yaw_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
}

// .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_StdDev::has_pitch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pitch_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::_internal_pitch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.pitch_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::pitch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
  return _internal_pitch();
}
inline void RotationAndAccuracy_StdDev::unsafe_arena_set_allocated_pitch(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }
  _impl_.pitch_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_StdDev::release_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_StdDev::unsafe_arena_release_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_StdDev::_internal_mutable_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pitch_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.pitch_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.pitch_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_StdDev::mutable_pitch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_pitch();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
  return _msg;
}
inline void RotationAndAccuracy_StdDev::set_allocated_pitch(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pitch_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
}

// .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_StdDev::has_roll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.roll_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::_internal_roll() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.roll_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::roll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
  return _internal_roll();
}
inline void RotationAndAccuracy_StdDev::unsafe_arena_set_allocated_roll(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }
  _impl_.roll_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_StdDev::release_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.roll_;
  _impl_.roll_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy_StdDev::unsafe_arena_release_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.roll_;
  _impl_.roll_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_StdDev::_internal_mutable_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.roll_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.roll_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.roll_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy_StdDev::mutable_roll()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_roll();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
  return _msg;
}
inline void RotationAndAccuracy_StdDev::set_allocated_roll(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.roll_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
}

// -------------------------------------------------------------------

// RotationAndAccuracy

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_vehicle = 1;
inline bool RotationAndAccuracy::has_euler_vehicle() const {
  return euler_quaternion_case() == kEulerVehicle;
}
inline bool RotationAndAccuracy::_internal_has_euler_vehicle() const {
  return euler_quaternion_case() == kEulerVehicle;
}
inline void RotationAndAccuracy::set_has_euler_vehicle() {
  _impl_._oneof_case_[0] = kEulerVehicle;
}
inline void RotationAndAccuracy::clear_euler_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (euler_quaternion_case() == kEulerVehicle) {
    if (GetArena() == nullptr) {
      delete _impl_.euler_quaternion_.euler_vehicle_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.euler_quaternion_.euler_vehicle_);
    }
    clear_has_euler_quaternion();
  }
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE RotationAndAccuracy::release_euler_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
  if (euler_quaternion_case() == kEulerVehicle) {
    clear_has_euler_quaternion();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler*>(_impl_.euler_quaternion_.euler_vehicle_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.euler_quaternion_.euler_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::_internal_euler_vehicle() const {
  return euler_quaternion_case() == kEulerVehicle ? *reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler*>(_impl_.euler_quaternion_.euler_vehicle_) : reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Euler_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::euler_vehicle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
  return _internal_euler_vehicle();
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE RotationAndAccuracy::unsafe_arena_release_euler_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
  if (euler_quaternion_case() == kEulerVehicle) {
    clear_has_euler_quaternion();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler*>(_impl_.euler_quaternion_.euler_vehicle_);
    _impl_.euler_quaternion_.euler_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_euler_vehicle(
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_euler_quaternion();
  if (value) {
    set_has_euler_vehicle();
    _impl_.euler_quaternion_.euler_vehicle_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NONNULL RotationAndAccuracy::_internal_mutable_euler_vehicle() {
  if (euler_quaternion_case() != kEulerVehicle) {
    clear_euler_quaternion();
    set_has_euler_vehicle();
    _impl_.euler_quaternion_.euler_vehicle_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler*>(_impl_.euler_quaternion_.euler_vehicle_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NONNULL RotationAndAccuracy::mutable_euler_vehicle()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* _msg = _internal_mutable_euler_vehicle();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
  return _msg;
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_event_group = 2;
inline bool RotationAndAccuracy::has_euler_event_group() const {
  return euler_quaternion_case() == kEulerEventGroup;
}
inline bool RotationAndAccuracy::_internal_has_euler_event_group() const {
  return euler_quaternion_case() == kEulerEventGroup;
}
inline void RotationAndAccuracy::set_has_euler_event_group() {
  _impl_._oneof_case_[0] = kEulerEventGroup;
}
inline void RotationAndAccuracy::clear_euler_event_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (euler_quaternion_case() == kEulerEventGroup) {
    if (GetArena() == nullptr) {
      delete _impl_.euler_quaternion_.euler_event_group_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.euler_quaternion_.euler_event_group_);
    }
    clear_has_euler_quaternion();
  }
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE RotationAndAccuracy::release_euler_event_group() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
  if (euler_quaternion_case() == kEulerEventGroup) {
    clear_has_euler_quaternion();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler*>(_impl_.euler_quaternion_.euler_event_group_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.euler_quaternion_.euler_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::_internal_euler_event_group() const {
  return euler_quaternion_case() == kEulerEventGroup ? *reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler*>(_impl_.euler_quaternion_.euler_event_group_) : reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Euler_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::euler_event_group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
  return _internal_euler_event_group();
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE RotationAndAccuracy::unsafe_arena_release_euler_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
  if (euler_quaternion_case() == kEulerEventGroup) {
    clear_has_euler_quaternion();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler*>(_impl_.euler_quaternion_.euler_event_group_);
    _impl_.euler_quaternion_.euler_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_euler_event_group(
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_euler_quaternion();
  if (value) {
    set_has_euler_event_group();
    _impl_.euler_quaternion_.euler_event_group_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NONNULL RotationAndAccuracy::_internal_mutable_euler_event_group() {
  if (euler_quaternion_case() != kEulerEventGroup) {
    clear_euler_quaternion();
    set_has_euler_event_group();
    _impl_.euler_quaternion_.euler_event_group_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler*>(_impl_.euler_quaternion_.euler_event_group_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* PROTOBUF_NONNULL RotationAndAccuracy::mutable_euler_event_group()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* _msg = _internal_mutable_euler_event_group();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
  return _msg;
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_vehicle = 3;
inline bool RotationAndAccuracy::has_quaternion_vehicle() const {
  return euler_quaternion_case() == kQuaternionVehicle;
}
inline bool RotationAndAccuracy::_internal_has_quaternion_vehicle() const {
  return euler_quaternion_case() == kQuaternionVehicle;
}
inline void RotationAndAccuracy::set_has_quaternion_vehicle() {
  _impl_._oneof_case_[0] = kQuaternionVehicle;
}
inline void RotationAndAccuracy::clear_quaternion_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (euler_quaternion_case() == kQuaternionVehicle) {
    if (GetArena() == nullptr) {
      delete _impl_.euler_quaternion_.quaternion_vehicle_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.euler_quaternion_.quaternion_vehicle_);
    }
    clear_has_euler_quaternion();
  }
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE RotationAndAccuracy::release_quaternion_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
  if (euler_quaternion_case() == kQuaternionVehicle) {
    clear_has_euler_quaternion();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion*>(_impl_.euler_quaternion_.quaternion_vehicle_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.euler_quaternion_.quaternion_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::_internal_quaternion_vehicle() const {
  return euler_quaternion_case() == kQuaternionVehicle ? *reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion*>(_impl_.euler_quaternion_.quaternion_vehicle_) : reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Quaternion_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::quaternion_vehicle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
  return _internal_quaternion_vehicle();
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE RotationAndAccuracy::unsafe_arena_release_quaternion_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
  if (euler_quaternion_case() == kQuaternionVehicle) {
    clear_has_euler_quaternion();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion*>(_impl_.euler_quaternion_.quaternion_vehicle_);
    _impl_.euler_quaternion_.quaternion_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_quaternion_vehicle(
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_euler_quaternion();
  if (value) {
    set_has_quaternion_vehicle();
    _impl_.euler_quaternion_.quaternion_vehicle_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL RotationAndAccuracy::_internal_mutable_quaternion_vehicle() {
  if (euler_quaternion_case() != kQuaternionVehicle) {
    clear_euler_quaternion();
    set_has_quaternion_vehicle();
    _impl_.euler_quaternion_.quaternion_vehicle_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion*>(_impl_.euler_quaternion_.quaternion_vehicle_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL RotationAndAccuracy::mutable_quaternion_vehicle()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* _msg = _internal_mutable_quaternion_vehicle();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
  return _msg;
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_event_group = 4;
inline bool RotationAndAccuracy::has_quaternion_event_group() const {
  return euler_quaternion_case() == kQuaternionEventGroup;
}
inline bool RotationAndAccuracy::_internal_has_quaternion_event_group() const {
  return euler_quaternion_case() == kQuaternionEventGroup;
}
inline void RotationAndAccuracy::set_has_quaternion_event_group() {
  _impl_._oneof_case_[0] = kQuaternionEventGroup;
}
inline void RotationAndAccuracy::clear_quaternion_event_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (euler_quaternion_case() == kQuaternionEventGroup) {
    if (GetArena() == nullptr) {
      delete _impl_.euler_quaternion_.quaternion_event_group_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.euler_quaternion_.quaternion_event_group_);
    }
    clear_has_euler_quaternion();
  }
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE RotationAndAccuracy::release_quaternion_event_group() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
  if (euler_quaternion_case() == kQuaternionEventGroup) {
    clear_has_euler_quaternion();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion*>(_impl_.euler_quaternion_.quaternion_event_group_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.euler_quaternion_.quaternion_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::_internal_quaternion_event_group() const {
  return euler_quaternion_case() == kQuaternionEventGroup ? *reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion*>(_impl_.euler_quaternion_.quaternion_event_group_) : reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Quaternion_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::quaternion_event_group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
  return _internal_quaternion_event_group();
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE RotationAndAccuracy::unsafe_arena_release_quaternion_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
  if (euler_quaternion_case() == kQuaternionEventGroup) {
    clear_has_euler_quaternion();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion*>(_impl_.euler_quaternion_.quaternion_event_group_);
    _impl_.euler_quaternion_.quaternion_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_quaternion_event_group(
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_euler_quaternion();
  if (value) {
    set_has_quaternion_event_group();
    _impl_.euler_quaternion_.quaternion_event_group_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL RotationAndAccuracy::_internal_mutable_quaternion_event_group() {
  if (euler_quaternion_case() != kQuaternionEventGroup) {
    clear_euler_quaternion();
    set_has_quaternion_event_group();
    _impl_.euler_quaternion_.quaternion_event_group_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion*>(_impl_.euler_quaternion_.quaternion_event_group_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* PROTOBUF_NONNULL RotationAndAccuracy::mutable_quaternion_event_group()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* _msg = _internal_mutable_quaternion_event_group();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
  return _msg;
}

// .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy::has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline bool RotationAndAccuracy::_internal_has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline void RotationAndAccuracy::set_has_combined_std_dev() {
  _impl_._oneof_case_[1] = kCombinedStdDev;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy::release_combined_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy::_internal_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev ? *reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_) : reinterpret_cast<::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy::combined_std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
  return _internal_combined_std_dev();
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationAndAccuracy::unsafe_arena_release_combined_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_);
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_combined_std_dev(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy::_internal_mutable_combined_std_dev() {
  if (accuracy_case() != kCombinedStdDev) {
    clear_accuracy();
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena()));
  }
  return reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_);
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationAndAccuracy::mutable_combined_std_dev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_combined_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
  return _msg;
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev std_dev = 6;
inline bool RotationAndAccuracy::has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline bool RotationAndAccuracy::_internal_has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline void RotationAndAccuracy::set_has_std_dev() {
  _impl_._oneof_case_[1] = kStdDev;
}
inline void RotationAndAccuracy::clear_std_dev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.std_dev_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.std_dev_);
    }
    clear_has_accuracy();
  }
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* PROTOBUF_NULLABLE RotationAndAccuracy::release_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev*>(_impl_.accuracy_.std_dev_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& RotationAndAccuracy::_internal_std_dev() const {
  return accuracy_case() == kStdDev ? *reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev*>(_impl_.accuracy_.std_dev_) : reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_StdDev_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& RotationAndAccuracy::std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
  return _internal_std_dev();
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* PROTOBUF_NULLABLE RotationAndAccuracy::unsafe_arena_release_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev*>(_impl_.accuracy_.std_dev_);
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_std_dev(
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* PROTOBUF_NONNULL RotationAndAccuracy::_internal_mutable_std_dev() {
  if (accuracy_case() != kStdDev) {
    clear_accuracy();
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev*>(_impl_.accuracy_.std_dev_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* PROTOBUF_NONNULL RotationAndAccuracy::mutable_std_dev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* _msg = _internal_mutable_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
  return _msg;
}

// .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 7 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy::has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline bool RotationAndAccuracy::_internal_has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline void RotationAndAccuracy::set_has_covariance() {
  _impl_._oneof_case_[1] = kCovariance;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE RotationAndAccuracy::release_covariance() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationAndAccuracy::_internal_covariance() const {
  return accuracy_case() == kCovariance ? *reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_) : reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3&>(::sensoris::protobuf::types::base::_Int64Matrix3x3_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationAndAccuracy::covariance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
  return _internal_covariance();
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE RotationAndAccuracy::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_);
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_covariance(
    ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_covariance();
    _impl_.accuracy_.covariance_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL RotationAndAccuracy::_internal_mutable_covariance() {
  if (accuracy_case() != kCovariance) {
    clear_accuracy();
    set_has_covariance();
    _impl_.accuracy_.covariance_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Matrix3x3>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_);
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL RotationAndAccuracy::mutable_covariance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Matrix3x3* _msg = _internal_mutable_covariance();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int RotationAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int RotationAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL RotationAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL RotationAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& RotationAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL RotationAndAccuracy::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& RotationAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
RotationAndAccuracy::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
RotationAndAccuracy::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

inline bool RotationAndAccuracy::has_euler_quaternion() const {
  return euler_quaternion_case() != EULER_QUATERNION_NOT_SET;
}
inline void RotationAndAccuracy::clear_has_euler_quaternion() {
  _impl_._oneof_case_[0] = EULER_QUATERNION_NOT_SET;
}
inline bool RotationAndAccuracy::has_accuracy() const {
  return accuracy_case() != ACCURACY_NOT_SET;
}
inline void RotationAndAccuracy::clear_has_accuracy() {
  _impl_._oneof_case_[1] = ACCURACY_NOT_SET;
}
inline RotationAndAccuracy::EulerQuaternionCase RotationAndAccuracy::euler_quaternion_case() const {
  return RotationAndAccuracy::EulerQuaternionCase(_impl_._oneof_case_[0]);
}
inline RotationAndAccuracy::AccuracyCase RotationAndAccuracy::accuracy_case() const {
  return RotationAndAccuracy::AccuracyCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// RotationRateAndAccuracy_StdDev

// .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy_StdDev::has_yaw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.yaw_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::_internal_yaw() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.yaw_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::yaw() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
  return _internal_yaw();
}
inline void RotationRateAndAccuracy_StdDev::unsafe_arena_set_allocated_yaw(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }
  _impl_.yaw_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy_StdDev::release_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy_StdDev::unsafe_arena_release_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy_StdDev::_internal_mutable_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.yaw_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.yaw_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.yaw_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy_StdDev::mutable_yaw()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_yaw();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
  return _msg;
}
inline void RotationRateAndAccuracy_StdDev::set_allocated_yaw(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.yaw_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
}

// .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy_StdDev::has_pitch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pitch_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::_internal_pitch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.pitch_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::pitch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
  return _internal_pitch();
}
inline void RotationRateAndAccuracy_StdDev::unsafe_arena_set_allocated_pitch(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }
  _impl_.pitch_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy_StdDev::release_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy_StdDev::unsafe_arena_release_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy_StdDev::_internal_mutable_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pitch_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.pitch_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.pitch_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy_StdDev::mutable_pitch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_pitch();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
  return _msg;
}
inline void RotationRateAndAccuracy_StdDev::set_allocated_pitch(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pitch_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
}

// .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy_StdDev::has_roll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.roll_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::_internal_roll() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.roll_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::roll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
  return _internal_roll();
}
inline void RotationRateAndAccuracy_StdDev::unsafe_arena_set_allocated_roll(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }
  _impl_.roll_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy_StdDev::release_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.roll_;
  _impl_.roll_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy_StdDev::unsafe_arena_release_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.roll_;
  _impl_.roll_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy_StdDev::_internal_mutable_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.roll_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.roll_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.roll_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy_StdDev::mutable_roll()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_roll();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
  return _msg;
}
inline void RotationRateAndAccuracy_StdDev::set_allocated_roll(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.roll_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
}

// -------------------------------------------------------------------

// RotationRateAndAccuracy

// .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_yaw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.yaw_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::_internal_yaw() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.yaw_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::yaw() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
  return _internal_yaw();
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_yaw(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }
  _impl_.yaw_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy::release_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy::unsafe_arena_release_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy::_internal_mutable_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.yaw_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.yaw_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.yaw_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy::mutable_yaw()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_yaw();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
  return _msg;
}
inline void RotationRateAndAccuracy::set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.yaw_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
}

// .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_pitch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pitch_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::_internal_pitch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.pitch_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::pitch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
  return _internal_pitch();
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_pitch(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }
  _impl_.pitch_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy::release_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy::unsafe_arena_release_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy::_internal_mutable_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pitch_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.pitch_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.pitch_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy::mutable_pitch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_pitch();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
  return _msg;
}
inline void RotationRateAndAccuracy::set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pitch_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
}

// .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_roll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.roll_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::_internal_roll() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.roll_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::roll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
  return _internal_roll();
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_roll(
    ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }
  _impl_.roll_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy::release_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.roll_;
  _impl_.roll_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy::unsafe_arena_release_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.roll_;
  _impl_.roll_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy::_internal_mutable_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.roll_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.roll_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.roll_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy::mutable_roll()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_roll();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
  return _msg;
}
inline void RotationRateAndAccuracy::set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.roll_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
}

// .google.protobuf.Int64Value combined_std_dev = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline bool RotationRateAndAccuracy::_internal_has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline void RotationRateAndAccuracy::set_has_combined_std_dev() {
  _impl_._oneof_case_[0] = kCombinedStdDev;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy::release_combined_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy::_internal_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev ? *reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_) : reinterpret_cast<::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy::combined_std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
  return _internal_combined_std_dev();
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE RotationRateAndAccuracy::unsafe_arena_release_combined_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_);
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_combined_std_dev(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy::_internal_mutable_combined_std_dev() {
  if (accuracy_case() != kCombinedStdDev) {
    clear_accuracy();
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena()));
  }
  return reinterpret_cast<::google::protobuf::Int64Value*>(_impl_.accuracy_.combined_std_dev_);
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL RotationRateAndAccuracy::mutable_combined_std_dev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_combined_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
  return _msg;
}

// .sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev std_dev = 5;
inline bool RotationRateAndAccuracy::has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline bool RotationRateAndAccuracy::_internal_has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline void RotationRateAndAccuracy::set_has_std_dev() {
  _impl_._oneof_case_[0] = kStdDev;
}
inline void RotationRateAndAccuracy::clear_std_dev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (accuracy_case() == kStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.std_dev_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.accuracy_.std_dev_);
    }
    clear_has_accuracy();
  }
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* PROTOBUF_NULLABLE RotationRateAndAccuracy::release_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev*>(_impl_.accuracy_.std_dev_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& RotationRateAndAccuracy::_internal_std_dev() const {
  return accuracy_case() == kStdDev ? *reinterpret_cast<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev*>(_impl_.accuracy_.std_dev_) : reinterpret_cast<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev&>(::sensoris::protobuf::types::spatial::_RotationRateAndAccuracy_StdDev_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& RotationRateAndAccuracy::std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
  return _internal_std_dev();
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* PROTOBUF_NULLABLE RotationRateAndAccuracy::unsafe_arena_release_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev*>(_impl_.accuracy_.std_dev_);
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_std_dev(
    ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* PROTOBUF_NONNULL RotationRateAndAccuracy::_internal_mutable_std_dev() {
  if (accuracy_case() != kStdDev) {
    clear_accuracy();
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev*>(_impl_.accuracy_.std_dev_);
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* PROTOBUF_NONNULL RotationRateAndAccuracy::mutable_std_dev()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* _msg = _internal_mutable_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
  return _msg;
}

// .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline bool RotationRateAndAccuracy::_internal_has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline void RotationRateAndAccuracy::set_has_covariance() {
  _impl_._oneof_case_[0] = kCovariance;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE RotationRateAndAccuracy::release_covariance() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationRateAndAccuracy::_internal_covariance() const {
  return accuracy_case() == kCovariance ? *reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_) : reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3&>(::sensoris::protobuf::types::base::_Int64Matrix3x3_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationRateAndAccuracy::covariance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
  return _internal_covariance();
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE RotationRateAndAccuracy::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_);
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_covariance(
    ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_covariance();
    _impl_.accuracy_.covariance_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL RotationRateAndAccuracy::_internal_mutable_covariance() {
  if (accuracy_case() != kCovariance) {
    clear_accuracy();
    set_has_covariance();
    _impl_.accuracy_.covariance_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::base::Int64Matrix3x3>(GetArena()));
  }
  return reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3*>(_impl_.accuracy_.covariance_);
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PROTOBUF_NONNULL RotationRateAndAccuracy::mutable_covariance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Matrix3x3* _msg = _internal_mutable_covariance();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int RotationRateAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int RotationRateAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL RotationRateAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL RotationRateAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& RotationRateAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL RotationRateAndAccuracy::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& RotationRateAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
RotationRateAndAccuracy::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
RotationRateAndAccuracy::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

inline bool RotationRateAndAccuracy::has_accuracy() const {
  return accuracy_case() != ACCURACY_NOT_SET;
}
inline void RotationRateAndAccuracy::clear_has_accuracy() {
  _impl_._oneof_case_[0] = ACCURACY_NOT_SET;
}
inline RotationRateAndAccuracy::AccuracyCase RotationRateAndAccuracy::accuracy_case() const {
  return RotationRateAndAccuracy::AccuracyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MapLocationReference_TileIdLinkIdOffset

// .google.protobuf.Int64Value tile_id = 1;
inline bool MapLocationReference_TileIdLinkIdOffset::has_tile_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tile_id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::_internal_tile_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.tile_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::tile_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
  return _internal_tile_id();
}
inline void MapLocationReference_TileIdLinkIdOffset::unsafe_arena_set_allocated_tile_id(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tile_id_);
  }
  _impl_.tile_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE MapLocationReference_TileIdLinkIdOffset::release_tile_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.tile_id_;
  _impl_.tile_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE MapLocationReference_TileIdLinkIdOffset::unsafe_arena_release_tile_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.tile_id_;
  _impl_.tile_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL MapLocationReference_TileIdLinkIdOffset::_internal_mutable_tile_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tile_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.tile_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.tile_id_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL MapLocationReference_TileIdLinkIdOffset::mutable_tile_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_tile_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
  return _msg;
}
inline void MapLocationReference_TileIdLinkIdOffset::set_allocated_tile_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tile_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tile_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
}

// .google.protobuf.Int64Value link_id = 2;
inline bool MapLocationReference_TileIdLinkIdOffset::has_link_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.link_id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::_internal_link_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.link_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::link_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
  return _internal_link_id();
}
inline void MapLocationReference_TileIdLinkIdOffset::unsafe_arena_set_allocated_link_id(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.link_id_);
  }
  _impl_.link_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE MapLocationReference_TileIdLinkIdOffset::release_link_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.link_id_;
  _impl_.link_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE MapLocationReference_TileIdLinkIdOffset::unsafe_arena_release_link_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.link_id_;
  _impl_.link_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL MapLocationReference_TileIdLinkIdOffset::_internal_mutable_link_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.link_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.link_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.link_id_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL MapLocationReference_TileIdLinkIdOffset::mutable_link_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_link_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
  return _msg;
}
inline void MapLocationReference_TileIdLinkIdOffset::set_allocated_link_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.link_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.link_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
}

// .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool MapLocationReference_TileIdLinkIdOffset::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.offset_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::offset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
  return _internal_offset();
}
inline void MapLocationReference_TileIdLinkIdOffset::unsafe_arena_set_allocated_offset(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offset_);
  }
  _impl_.offset_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE MapLocationReference_TileIdLinkIdOffset::release_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.offset_;
  _impl_.offset_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE MapLocationReference_TileIdLinkIdOffset::unsafe_arena_release_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.offset_;
  _impl_.offset_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL MapLocationReference_TileIdLinkIdOffset::_internal_mutable_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.offset_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.offset_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.offset_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL MapLocationReference_TileIdLinkIdOffset::mutable_offset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_offset();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
  return _msg;
}
inline void MapLocationReference_TileIdLinkIdOffset::set_allocated_offset(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.offset_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
}

// repeated .google.protobuf.Any extension = 15;
inline int MapLocationReference_TileIdLinkIdOffset::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int MapLocationReference_TileIdLinkIdOffset::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL MapLocationReference_TileIdLinkIdOffset::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL MapLocationReference_TileIdLinkIdOffset::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& MapLocationReference_TileIdLinkIdOffset::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL MapLocationReference_TileIdLinkIdOffset::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& MapLocationReference_TileIdLinkIdOffset::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
MapLocationReference_TileIdLinkIdOffset::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
MapLocationReference_TileIdLinkIdOffset::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// MapLocationReference_TileIdObjectId

// .google.protobuf.Int64Value tile_id = 1;
inline bool MapLocationReference_TileIdObjectId::has_tile_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tile_id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::_internal_tile_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.tile_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::tile_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
  return _internal_tile_id();
}
inline void MapLocationReference_TileIdObjectId::unsafe_arena_set_allocated_tile_id(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tile_id_);
  }
  _impl_.tile_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE MapLocationReference_TileIdObjectId::release_tile_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.tile_id_;
  _impl_.tile_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE MapLocationReference_TileIdObjectId::unsafe_arena_release_tile_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.tile_id_;
  _impl_.tile_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL MapLocationReference_TileIdObjectId::_internal_mutable_tile_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tile_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.tile_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.tile_id_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL MapLocationReference_TileIdObjectId::mutable_tile_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_tile_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
  return _msg;
}
inline void MapLocationReference_TileIdObjectId::set_allocated_tile_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tile_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tile_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
}

// .google.protobuf.Int64Value object_id = 2;
inline bool MapLocationReference_TileIdObjectId::has_object_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::_internal_object_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.object_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::object_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
  return _internal_object_id();
}
inline void MapLocationReference_TileIdObjectId::unsafe_arena_set_allocated_object_id(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }
  _impl_.object_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE MapLocationReference_TileIdObjectId::release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE MapLocationReference_TileIdObjectId::unsafe_arena_release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL MapLocationReference_TileIdObjectId::_internal_mutable_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.object_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.object_id_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL MapLocationReference_TileIdObjectId::mutable_object_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
  return _msg;
}
inline void MapLocationReference_TileIdObjectId::set_allocated_object_id(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.object_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
}

// repeated .google.protobuf.Any extension = 15;
inline int MapLocationReference_TileIdObjectId::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int MapLocationReference_TileIdObjectId::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL MapLocationReference_TileIdObjectId::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL MapLocationReference_TileIdObjectId::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& MapLocationReference_TileIdObjectId::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL MapLocationReference_TileIdObjectId::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& MapLocationReference_TileIdObjectId::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
MapLocationReference_TileIdObjectId::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
MapLocationReference_TileIdObjectId::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// MapLocationReference

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
inline bool MapLocationReference::has_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_and_accuracy_ != nullptr);
  return value;
}
inline void MapLocationReference::clear_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_and_accuracy_ != nullptr) _impl_.position_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& MapLocationReference::_internal_position_and_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& MapLocationReference::position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline void MapLocationReference::unsafe_arena_set_allocated_position_and_accuracy(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }
  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE MapLocationReference::release_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE MapLocationReference::unsafe_arena_release_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL MapLocationReference::_internal_mutable_position_and_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_and_accuracy_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NONNULL MapLocationReference::mutable_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
  return _msg;
}
inline void MapLocationReference::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
}

// .google.protobuf.Int64Value z_level = 2;
inline bool MapLocationReference::has_z_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.z_level_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& MapLocationReference::_internal_z_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Int64Value* p = _impl_.z_level_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& MapLocationReference::z_level() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
  return _internal_z_level();
}
inline void MapLocationReference::unsafe_arena_set_allocated_z_level(
    ::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_level_);
  }
  _impl_.z_level_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE MapLocationReference::release_z_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.z_level_;
  _impl_.z_level_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NULLABLE MapLocationReference::unsafe_arena_release_z_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.z_level)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.z_level_;
  _impl_.z_level_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL MapLocationReference::_internal_mutable_z_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.z_level_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Int64Value>(GetArena());
    _impl_.z_level_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.z_level_;
}
inline ::google::protobuf::Int64Value* PROTOBUF_NONNULL MapLocationReference::mutable_z_level()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Int64Value* _msg = _internal_mutable_z_level();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
  return _msg;
}
inline void MapLocationReference::set_allocated_z_level(::google::protobuf::Int64Value* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_level_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.z_level_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
}

// .sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset tile_link_offset_reference = 3;
inline bool MapLocationReference::has_tile_link_offset_reference() const {
  return map_based_reference_case() == kTileLinkOffsetReference;
}
inline bool MapLocationReference::_internal_has_tile_link_offset_reference() const {
  return map_based_reference_case() == kTileLinkOffsetReference;
}
inline void MapLocationReference::set_has_tile_link_offset_reference() {
  _impl_._oneof_case_[0] = kTileLinkOffsetReference;
}
inline void MapLocationReference::clear_tile_link_offset_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (map_based_reference_case() == kTileLinkOffsetReference) {
    if (GetArena() == nullptr) {
      delete _impl_.map_based_reference_.tile_link_offset_reference_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.map_based_reference_.tile_link_offset_reference_);
    }
    clear_has_map_based_reference();
  }
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NULLABLE MapLocationReference::release_tile_link_offset_reference() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
  if (map_based_reference_case() == kTileLinkOffsetReference) {
    clear_has_map_based_reference();
    auto* temp = _impl_.map_based_reference_.tile_link_offset_reference_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.map_based_reference_.tile_link_offset_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& MapLocationReference::_internal_tile_link_offset_reference() const {
  return map_based_reference_case() == kTileLinkOffsetReference ? *_impl_.map_based_reference_.tile_link_offset_reference_ : reinterpret_cast<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset&>(::sensoris::protobuf::types::spatial::_MapLocationReference_TileIdLinkIdOffset_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& MapLocationReference::tile_link_offset_reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
  return _internal_tile_link_offset_reference();
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NULLABLE MapLocationReference::unsafe_arena_release_tile_link_offset_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
  if (map_based_reference_case() == kTileLinkOffsetReference) {
    clear_has_map_based_reference();
    auto* temp = _impl_.map_based_reference_.tile_link_offset_reference_;
    _impl_.map_based_reference_.tile_link_offset_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MapLocationReference::unsafe_arena_set_allocated_tile_link_offset_reference(
    ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_map_based_reference();
  if (value) {
    set_has_tile_link_offset_reference();
    _impl_.map_based_reference_.tile_link_offset_reference_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NONNULL MapLocationReference::_internal_mutable_tile_link_offset_reference() {
  if (map_based_reference_case() != kTileLinkOffsetReference) {
    clear_map_based_reference();
    set_has_tile_link_offset_reference();
    _impl_.map_based_reference_.tile_link_offset_reference_ = 
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset>(GetArena());
  }
  return _impl_.map_based_reference_.tile_link_offset_reference_;
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* PROTOBUF_NONNULL MapLocationReference::mutable_tile_link_offset_reference()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* _msg = _internal_mutable_tile_link_offset_reference();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
  return _msg;
}

// .sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId map_object_id = 4;
inline bool MapLocationReference::has_map_object_id() const {
  return map_based_reference_case() == kMapObjectId;
}
inline bool MapLocationReference::_internal_has_map_object_id() const {
  return map_based_reference_case() == kMapObjectId;
}
inline void MapLocationReference::set_has_map_object_id() {
  _impl_._oneof_case_[0] = kMapObjectId;
}
inline void MapLocationReference::clear_map_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (map_based_reference_case() == kMapObjectId) {
    if (GetArena() == nullptr) {
      delete _impl_.map_based_reference_.map_object_id_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.map_based_reference_.map_object_id_);
    }
    clear_has_map_based_reference();
  }
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NULLABLE MapLocationReference::release_map_object_id() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
  if (map_based_reference_case() == kMapObjectId) {
    clear_has_map_based_reference();
    auto* temp = _impl_.map_based_reference_.map_object_id_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.map_based_reference_.map_object_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& MapLocationReference::_internal_map_object_id() const {
  return map_based_reference_case() == kMapObjectId ? *_impl_.map_based_reference_.map_object_id_ : reinterpret_cast<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId&>(::sensoris::protobuf::types::spatial::_MapLocationReference_TileIdObjectId_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& MapLocationReference::map_object_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
  return _internal_map_object_id();
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NULLABLE MapLocationReference::unsafe_arena_release_map_object_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
  if (map_based_reference_case() == kMapObjectId) {
    clear_has_map_based_reference();
    auto* temp = _impl_.map_based_reference_.map_object_id_;
    _impl_.map_based_reference_.map_object_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MapLocationReference::unsafe_arena_set_allocated_map_object_id(
    ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_map_based_reference();
  if (value) {
    set_has_map_object_id();
    _impl_.map_based_reference_.map_object_id_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NONNULL MapLocationReference::_internal_mutable_map_object_id() {
  if (map_based_reference_case() != kMapObjectId) {
    clear_map_based_reference();
    set_has_map_object_id();
    _impl_.map_based_reference_.map_object_id_ = 
        ::google::protobuf::Message::DefaultConstruct<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId>(GetArena());
  }
  return _impl_.map_based_reference_.map_object_id_;
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* PROTOBUF_NONNULL MapLocationReference::mutable_map_object_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* _msg = _internal_mutable_map_object_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int MapLocationReference::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int MapLocationReference::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL MapLocationReference::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL MapLocationReference::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& MapLocationReference::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PROTOBUF_NONNULL MapLocationReference::add_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& MapLocationReference::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
MapLocationReference::_internal_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PROTOBUF_NONNULL
MapLocationReference::_internal_mutable_extension() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extension_;
}

inline bool MapLocationReference::has_map_based_reference() const {
  return map_based_reference_case() != MAP_BASED_REFERENCE_NOT_SET;
}
inline void MapLocationReference::clear_has_map_based_reference() {
  _impl_._oneof_case_[0] = MAP_BASED_REFERENCE_NOT_SET;
}
inline MapLocationReference::MapBasedReferenceCase MapLocationReference::map_based_reference_case() const {
  return MapLocationReference::MapBasedReferenceCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace spatial
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_2epb_2eh
